/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./_webpack/main.js":
/*!**************************!*\
  !*** ./_webpack/main.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _fortawesome_fontawesome_free_webfonts_fa_brands_400_woff2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @fortawesome/fontawesome-free/webfonts/fa-brands-400.woff2 */ \"./node_modules/@fortawesome/fontawesome-free/webfonts/fa-brands-400.woff2\");\n/* harmony import */ var codemirror_lib_codemirror_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! codemirror/lib/codemirror.css */ \"./node_modules/codemirror/lib/codemirror.css\");\n/* harmony import */ var codemirror_theme_hopscotch_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! codemirror/theme/hopscotch.css */ \"./node_modules/codemirror/theme/hopscotch.css\");\n/* harmony import */ var unpoly__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! unpoly */ \"./node_modules/unpoly/dist/unpoly.js\");\n/* harmony import */ var unpoly__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(unpoly__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! codemirror */ \"./node_modules/codemirror/lib/codemirror.js\");\n/* harmony import */ var codemirror__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(codemirror__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var codemirror_mode_ruby_ruby__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! codemirror/mode/ruby/ruby */ \"./node_modules/codemirror/mode/ruby/ruby.js\");\n/* harmony import */ var codemirror_mode_ruby_ruby__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(codemirror_mode_ruby_ruby__WEBPACK_IMPORTED_MODULE_5__);\n// import fonts from node modules\n // import styles from node modules\n\n\n // import javascript from node modules\n\n\n\n\nup.compiler('[code-editor]', function (element) {\n  var editor = codemirror__WEBPACK_IMPORTED_MODULE_4___default().fromTextArea(element, {\n    mode: \"ruby\",\n    tabMode: \"indent\",\n    matchBrackets: true,\n    indentUnit: 2,\n    lineNumbers: true,\n    value: \"#code-editor\",\n    theme: 'hopscotch'\n  });\n});\n\n//# sourceURL=webpack:///./_webpack/main.js?");

/***/ }),

/***/ "./node_modules/codemirror/lib/codemirror.js":
/*!***************************************************!*\
  !*** ./node_modules/codemirror/lib/codemirror.js ***!
  \***************************************************/
/***/ (function(module) {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, (function () { 'use strict';\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = !edge && /AppleWebKit/.test(userAgent) && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n  var android = /Android/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) { presto_version = Number(presto_version[1]); }\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  var rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      { e.removeChild(e.firstChild); }\n    return e\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e)\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) { e.className = className; }\n    if (style) { e.style.cssText = style; }\n    if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n    return e\n  }\n  // wrapper for elt, which removes the elt from the accessibility tree\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e\n  }\n\n  var range;\n  if (document.createRange) { range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r\n  }; }\n  else { range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r\n  }; }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      { child = child.parentNode; }\n    if (parent.contains)\n      { return parent.contains(child) }\n    do {\n      if (child.nodeType == 11) { child = child.host; }\n      if (child == parent) { return true }\n    } while (child = child.parentNode)\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n    try {\n      activeElement = document.activeElement;\n    } catch(e) {\n      activeElement = document.body || null;\n    }\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      { activeElement = activeElement.shadowRoot.activeElement; }\n    return activeElement\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n    return b\n  }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\n  else if (ie) // Suppress mysterious IE10 errors\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args)}\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) { target = {}; }\n    for (var prop in obj)\n      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        { target[prop] = obj[prop]; } }\n    return target\n  }\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) { end = string.length; }\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        { return n + (end - i) }\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function() {\n    this.id = null;\n    this.f = null;\n    this.time = 0;\n    this.handler = bind(this.onTimeout, this);\n  };\n  Delayed.prototype.onTimeout = function (self) {\n    self.id = 0;\n    if (self.time <= +new Date) {\n      self.f();\n    } else {\n      setTimeout(self.handler, self.time - +new Date);\n    }\n  };\n  Delayed.prototype.set = function (ms, f) {\n    this.f = f;\n    var time = +new Date + ms;\n    if (!this.id || time < this.time) {\n      clearTimeout(this.id);\n      this.id = setTimeout(this.handler, ms);\n      this.time = time;\n    }\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      { if (array[i] == elt) { return i } }\n    return -1\n  }\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 50;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) { nextTab = string.length; }\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        { return pos + Math.min(skipped, goal - col) }\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) { return pos }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      { spaceStrs.push(lst(spaceStrs) + \" \"); }\n    return spaceStrs[n]\n  }\n\n  function lst(arr) { return arr[arr.length-1] }\n\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n    return out\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value);\n    while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) { copyObj(props, inst); }\n    return inst\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  }\n  function isWordChar(ch, helper) {\n    if (!helper) { return isWordCharBasic(ch) }\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n    return helper.test(ch)\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n    return true\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n    return pos\n  }\n\n  // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n    for (;;) {\n      if (from == to) { return from }\n      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n      if (mid == from) { return pred(mid) ? from : to }\n      if (pred(mid)) { to = mid; }\n      else { from = mid + dir; }\n    }\n  }\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) { return f(from, to, \"ltr\", 0) }\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n    if (!found) { f(from, to, \"ltr\"); }\n  }\n\n  var bidiOther = null;\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < ch && cur.to > ch) { return i }\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n    }\n    return found != null ? found : bidiOther\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6f9\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n    function charType(code) {\n      if (code <= 0xf7) { return lowTypes.charAt(code) }\n      else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n      else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n      else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n      else if (code == 0x200c) { return \"b\" }\n      else { return \"L\" }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n      var len = str.length, types = [];\n      for (var i = 0; i < len; ++i)\n        { types.push(charType(str.charCodeAt(i))); }\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n        if (type == \"m\") { types[i$1] = prev; }\n        else { prev = type; }\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n        if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n        else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n                 (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n        prev$1 = type$2;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n        if (type$3 == \",\") { types[i$4] = \"N\"; }\n        else if (type$3 == \"%\") {\n          var end = (void 0);\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i$4; j < end; ++j) { types[j] = replace; }\n          i$4 = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n        if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n        else if (isStrong.test(type$4)) { cur$1 = type$4; }\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = (void 0);\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n          var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n          i$6 = end$1 - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7, at = order.length, isRTL = direction == \"rtl\" ? 1 : 0;\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }\n              var nstart = j$2;\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              at += isRTL;\n              pos = j$2;\n            } else { ++j$2; }\n          }\n          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n        }\n      }\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order\n    }\n  })();\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line, direction) {\n    var order = line.order;\n    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n    return order\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var noHandlers = [];\n\n  var on = function(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      map[type] = (map[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers, arr = map && map[type];\n      if (arr) {\n        var index = indexOf(arr, f);\n        if (index > -1)\n          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n      }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type);\n    if (!handlers.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) { return }\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n      { set.push(arr[i]); } }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) { e.stopPropagation(); }\n    else { e.cancelBubble = true; }\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\n  function e_target(e) {return e.target || e.srcElement}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) { b = 1; }\n      else if (e.button & 2) { b = 3; }\n      else if (e.button & 4) { b = 2; }\n    }\n    if (mac && e.ctrlKey && b == 1) { b = 3; }\n    return b\n  }\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) { return false }\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) { return badBidiRects }\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3)\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) { nl = string.length; }\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result\n  } : function (string) { return string.split(/\\r\\n?|\\n/); };\n\n  var hasSelection = window.getSelection ? function (te) {\n    try { return te.selectionStart != te.selectionEnd }\n    catch(e) { return false }\n  } : function (te) {\n    var range;\n    try {range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) { return false }\n    return range.compareEndPoints(\"StartToEnd\", range) != 0\n  };\n\n  var hasCopyEvent = (function () {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) { return true }\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\"\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) { return badZoomedRects }\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n  }\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  function defineMode(name, mode) {\n    if (arguments.length > 2)\n      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  }\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") { found = {name: found}; }\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\")\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\")\n    }\n    if (typeof spec == \"string\") { return {name: spec} }\n    else { return spec || {name: \"null\"} }\n  }\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) { return getMode(options, \"text/plain\") }\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) { continue }\n        if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) { modeObj.helperType = spec.helperType; }\n    if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n      { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n    return modeObj\n  }\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = {};\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) { return state }\n    if (mode.copyState) { return mode.copyState(state) }\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) { val = val.concat([]); }\n      nstate[n] = val;\n    }\n    return nstate\n  }\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  function innerMode(mode, state) {\n    var info;\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n      if (!info || info.mode == mode) { break }\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state}\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true\n  }\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = function(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {return this.pos >= this.string.length};\n  StringStream.prototype.sol = function () {return this.pos == this.lineStart};\n  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length)\n      { return this.string.charAt(this.pos++) }\n  };\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n    if (typeof match == \"string\") { ok = ch == match; }\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n    if (ok) {++this.pos; return ch}\n  };\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start\n  };\n  StringStream.prototype.eatSpace = function () {\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }\n    return this.pos > start\n  };\n  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true}\n  };\n  StringStream.prototype.backUp = function (n) {this.pos -= n;};\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) { this.pos += pattern.length; }\n        return true\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) { return null }\n      if (match && consume !== false) { this.pos += match[0].length; }\n      return match\n    }\n  };\n  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n    try { return inner() }\n    finally { this.lineStart -= n; }\n  };\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n)\n  };\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos)\n  };\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n    var chunk = doc;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n]\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) { text = text.slice(0, end.ch); }\n      if (n == start.line) { text = text.slice(start.ch); }\n      out.push(text);\n      ++n;\n    });\n    return out\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n    return out\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) { return null }\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) { break }\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1], ch = child.height;\n        if (h < ch) { chunk = child; continue outer }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n\n    } while (!chunk.lines)\n    var i = 0;\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) { break }\n      h -= lh;\n    }\n    return n + i\n  }\n\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber))\n  }\n\n  // A Pos instance represents a position within the text.\n  function Pos(line, ch, sticky) {\n    if ( sticky === void 0 ) sticky = null;\n\n    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  }\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\n  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\n  function copyPos(x) {return Pos(x.line, x.ch)}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) { return Pos(doc.first, 0) }\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n    return clipToLen(pos, getLine(doc, pos.line).text.length)\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n    else if (ch < 0) { return Pos(pos.line, 0) }\n    else { return pos }\n  }\n  function clipPosArray(doc, array) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n    return out\n  }\n\n  var SavedContext = function(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n    return line\n  };\n\n  Context.prototype.baseToken = function (n) {\n    if (!this.baseTokens) { return null }\n    while (this.baseTokens[this.baseTokenPos] <= n)\n      { this.baseTokenPos += 2; }\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n            size: this.baseTokens[this.baseTokenPos] - n}\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n    if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext)\n      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n    else\n      { return new Context(doc, copyState(doc.mode, saved), line) }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n  };\n\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n            lineClasses, forceToEnd);\n    var state = context.state;\n\n    // Run overlays, adjust style array.\n    var loop = function ( o ) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            { st.splice(i, 1, end, st[i+1], i_end); }\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) { return }\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n      if (resetState) { context.state = resetState; }\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n      if (result.classes) { line.styleClasses = result.classes; }\n      else if (line.styleClasses) { line.styleClasses = null; }\n      if (updateFrontier === cm.doc.highlightFrontier)\n        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n    }\n    return line.styles\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) { return new Context(doc, true, n) }\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n    if (precise) { doc.modeFrontier = context.line; }\n    return context\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") { callBlankLine(mode, context.state); }\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) { return mode.blankLine(state) }\n    if (!mode.innerMode) { return }\n    var inner = innerMode(mode, state);\n    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) { inner[0] = innerMode(mode, state).mode; }\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) { return style }\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n  }\n\n  var Token = function(stream, type, state) {\n    this.start = stream.start; this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  };\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n    if (asArray) { tokens = []; }\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n    }\n    return asArray ? tokens : new Token(stream, style, context.state)\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) { for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) { break }\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        { output[prop] = lineClass[2]; }\n      else if (!(new RegExp(\"(?:^|\\\\s)\" + lineClass[2] + \"(?:$|\\\\s)\")).test(output[prop]))\n        { output[prop] += \" \" + lineClass[2]; }\n    } }\n    return type\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) { return doc.first }\n      var line = getLine(doc, search - 1), after = line.stateAfter;\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n        { return search }\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n    if (doc.highlightFrontier < n - 10) { return }\n    var start = doc.first;\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter;\n      // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break\n      }\n    }\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  }\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) { return span }\n    } }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    var r;\n    for (var i = 0; i < spans.length; ++i)\n      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n    return r\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    } }\n    return nw\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    } }\n    return nw\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) { return null }\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) { return null }\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) { span.to = startCh; }\n          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n        if (span$1.to != null) { span$1.to += offset; }\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n          if (!found$1) {\n            span$1.from = offset;\n            if (sameLine) { (first || (first = [])).push(span$1); }\n          }\n        } else {\n          span$1.from += offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) { first = clearEmptySpans(first); }\n    if (last && last != first) { last = clearEmptySpans(last); }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        { for (var i$2 = 0; i$2 < first.length; ++i$2)\n          { if (first[i$2].to == null)\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n      for (var i$3 = 0; i$3 < gap; ++i$3)\n        { newMarkers.push(gapMarkers); }\n      newMarkers.push(last);\n    }\n    return newMarkers\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        { spans.splice(i--, 1); }\n    }\n    if (!spans.length) { return null }\n    return spans\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          { (markers || (markers = [])).push(mark); }\n      } }\n    });\n    if (!markers) { return null }\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          { newParts.push({from: p.from, to: m.from}); }\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          { newParts.push({from: m.to, to: p.to}); }\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n    return parts\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.detachLine(line); }\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.attachLine(line); }\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) { return lenDiff }\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) { return -fromCmp }\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) { return toCmp }\n    return b.id - a.id\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        { found = sp.marker; }\n    } }\n    return found\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }\n    } }\n    return found\n  }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        { return true }\n    } }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      { line = merged.find(-1, true).line; }\n    return line\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return line\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line\n      ;(lines || (lines = [])).push(line);\n    }\n    return lines\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) { return lineN }\n    return lineNo(vis)\n  }\n\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) { return lineN }\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) { return lineN }\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return lineNo(line) + 1\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      if (sp.from == null) { return true }\n      if (sp.marker.widgetNode) { continue }\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        { return true }\n    } }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      { return true }\n    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) { return true }\n    }\n  }\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) { break }\n      else { h += line.height; }\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n        if (cur == chunk) { break }\n        else { h += cur.height; }\n      }\n    }\n    return h\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) { return 0 }\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n    return len\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () { return lineNo(this) };\n  eventMixin(Line);\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n    if (line.order != null) { line.order = null; }\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) { return null }\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n        if (line.styleClasses.textClass)\n          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild;\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n        { builder.content.className = \"cm-tab-wrap-hack\"; }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n    return builder\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) { return }\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    var content;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) { mustWrap = true; }\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n          else { content.appendChild(txt); }\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) { break }\n        pos += skipped + 1;\n        var txt$1 = (void 0);\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n          else { content.appendChild(txt$1); }\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n    if (style || startStyle || endStyle || mustWrap || css || attributes) {\n      var fullStyle = style || \"\";\n      if (startStyle) { fullStyle += startStyle; }\n      if (endStyle) { fullStyle += endStyle; }\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (attributes) {\n        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\")\n          { token.setAttribute(attr, attributes[attr]); } }\n      }\n      return builder.content.appendChild(token)\n    }\n    builder.content.appendChild(content);\n  }\n\n  // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) { return text }\n    var spaceBefore = trailingBefore, result = \"\";\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        { ch = \"\\u00a0\"; }\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = (void 0);\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n          if (part.to > start && part.from <= start) { break }\n        }\n        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    }\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        { widget = builder.content.appendChild(document.createElement(\"span\")); }\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n      return\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles = (void 0);\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) { spanStyle += \" \" + m.className; }\n            if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n            if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n            // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n            if (m.title) { (attributes || (attributes = {})).title = m.title; }\n            if (m.attributes) {\n              for (var attr in m.attributes)\n                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\n            }\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              { collapsed = sp; }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) { return }\n          if (collapsed.to == pos) { collapsed = false; }\n        }\n      }\n      if (pos >= len) { break }\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        { callbacks[i].call(null); }\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n      }\n    } while (i < callbacks.length)\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n    if (!group) { return }\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type);\n    if (!arr.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    var loop = function ( i ) {\n      list.push(function () { return arr[i].apply(null, args); });\n    };\n\n    for (var i = 0; i < arr.length; ++i)\n      loop( i );\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") { updateLineText(cm, lineView); }\n      else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n      else if (type == \"class\") { updateLineClasses(cm, lineView); }\n      else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n    }\n    return lineView.node\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) { cls += \" CodeMirror-linebackground\"; }\n    if (lineView.background) {\n      if (cls) { lineView.background.className = cls; }\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built\n    }\n    return buildLineContent(cm, lineView)\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) { lineView.node = built.pre; }\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n    if (lineView.line.wrapClass)\n      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n    else if (lineView.node != lineView.text)\n      { lineView.node.className = \"\"; }\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        { lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                     (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n      } }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) { lineView.alignable = null; }\n    var isWidget = classTest(\"CodeMirror-linewidget\");\n    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n      next = node.nextSibling;\n      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) { lineView.bgClass = built.bgClass; }\n    if (built.textClass) { lineView.textClass = built.textClass; }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) { return }\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\" + (widget.className ? \" \" + widget.className : \"\"));\n      if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n      else\n        { wrap.appendChild(node); }\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n  (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) { return widget.height }\n    var cm = widget.doc.cm;\n    if (!cm) { return 0 }\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n      if (widget.noHScroll)\n        { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight\n  }\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        { return true }\n    }\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\n  function paddingH(display) {\n    if (display.cachedPaddingH) { return display.cachedPaddingH }\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\", \"CodeMirror-line-like\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n    return data\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n    for (var i = 0; i < lineView.rest.length; i++)\n      { if (lineView.rest[i] == line)\n        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n      { if (lineNo(lineView.rest[i$1]) > lineN)\n        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      { return cm.display.view[findViewIndex(cm, lineN)] }\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      { return ext }\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      { view = updateExternalMeasurement(cm, line); }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    }\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) { ch = -1; }\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) { prepared.cache[key] = found; }\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom}\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      mStart = map[i];\n      mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) { collapse = \"right\"; }\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          { collapse = bias; }\n        if (bias == \"left\" && start == 0)\n          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          } }\n        if (bias == \"right\" && start == mEnd - mStart)\n          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          } }\n        break\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n    if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) { break }\n    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n      if ((rect = rects[i$1]).left != rect.right) { break }\n    } }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          { rect = node.parentNode.getBoundingClientRect(); }\n        else\n          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n        if (rect.left || rect.right || start == 0) { break }\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) { collapse = bias = \"right\"; }\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n      else\n        { rect = node.getBoundingClientRect(); }\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n      else\n        { rect = nullRect; }\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n    for (; i < heights.length - 1; i++)\n      { if (mid < heights[i]) { break } }\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) { result.bogus = true; }\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      { return rect }\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n        { lineView.measure.caches[i] = {}; } }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      { clearLineMeasurementCacheFor(cm.display.view[i]); }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n  }\n  function pageScrollY() {\n    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop\n  }\n\n  function widgetTopHeight(lineObj) {\n    var height = 0;\n    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n      { height += widgetHeight(lineObj.widgets[i]); } } }\n    return height\n  }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height; rect.bottom += height;\n    }\n    if (context == \"line\") { return rect }\n    if (!context) { context = \"local\"; }\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") { yOff += paddingTop(cm.display); }\n    else { yOff -= cm.display.viewOffset; }\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") { return coords }\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) { m.left = m.right; } else { m.right = m.left; }\n      return intoCoordSystem(cm, lineObj, m, context)\n    }\n    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n    if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos], right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert)\n    }\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n    if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n    return val\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height}\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n    if (outside) { pos.outside = outside; }\n    return pos\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }\n    if (x < 0) { x = 0; }\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n      if (!collapsed) { return found }\n      var rangeEnd = collapsed.find(1);\n      if (rangeEnd.line == lineN) { return rangeEnd }\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n    return {begin: begin, end: end}\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n  }\n\n  // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    // Move y into line-local coordinate space\n    y -= heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n    var widgetHeight = widgetTopHeight(lineObj);\n    var begin = 0, end = lineObj.text.length, ltr = true;\n\n    var order = getOrder(lineObj, cm.doc.direction);\n    // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);\n      ltr = part.level != 1;\n      // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    }\n\n    // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n    var chAround = null, boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight; box.bottom += widgetHeight;\n      if (!boxIsAfter(box, x, y, false)) { return false }\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n      return true\n    }, begin, end);\n\n    var baseX, sticky, outside = false;\n    // If a box around the coordinates was found, use that\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) { ch++; }\n      // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?\n        \"after\" : \"before\";\n      // Now get accurate coordinates for this place, in order to get a\n      // base X position\n      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), \"line\", lineObj, preparedMeasure);\n      baseX = coords.left;\n      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i], ltr = part.level != 1;\n      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                     \"line\", lineObj, preparedMeasure), x, y, true)\n    }, 0, order.length - 1);\n    var part = order[index];\n    // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n    if (index > 0) {\n      var ltr = part.level != 1;\n      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                               \"line\", lineObj, preparedMeasure);\n      if (boxIsAfter(start, x, y, true) && start.top > y)\n        { part = order[index - 1]; }\n    }\n    return part\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n    var part = null, closestDist = null;\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n      if (p.from >= end || p.to <= begin) { continue }\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n      // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n    if (!part) { part = order[order.length - 1]; }\n    // Clip the part to the wrapped line.\n    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n    return part\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n    if (measureText == null) {\n      measureText = elt(\"pre\", null, \"CodeMirror-line-like\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) { display.cachedTextHeight = height; }\n    removeChildren(display.measure);\n    return height || 1\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor], \"CodeMirror-line-like\");\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) { display.cachedCharWidth = width; }\n    return width || 10\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      var id = cm.display.gutterSpecs[i].className;\n      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[id] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth}\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) { return 0 }\n\n      var widgetsHeight = 0;\n      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n      } }\n\n      if (wrapping)\n        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n      else\n        { return widgetsHeight + th }\n    }\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n    });\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e$1) { return null }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) { return null }\n    n -= cm.display.viewFrom;\n    if (n < 0) { return null }\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) { return i }\n    }\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) { from = cm.doc.first; }\n    if (to == null) { to = cm.doc.first + cm.doc.size; }\n    if (!lendiff) { lendiff = 0; }\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      { display.updateLineNumbers = from; }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        { resetView(cm); }\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        { ext.lineN += lendiff; }\n      else if (from < ext.lineN + ext.size)\n        { display.externalMeasured = null; }\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n\n    if (line < display.viewFrom || line >= display.viewTo) { return }\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) { return }\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) { arr.push(type); }\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      { return {index: index, lineN: newN} }\n    var n = cm.display.viewFrom;\n    for (var i = 0; i < index; i++)\n      { n += view[i].size; }\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) { return null }\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN}\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n      else if (display.viewFrom < from)\n        { display.view = display.view.slice(findViewIndex(cm, from)); }\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n      else if (display.viewTo > to)\n        { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n    }\n    return dirty\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if ( primary === void 0 ) primary = true;\n\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) { continue }\n      var range = doc.sel.ranges[i];\n      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        { drawSelectionCursor(cm, range.head, curFragment); }\n      if (!collapsed)\n        { drawSelectionRange(cm, range, selFragment); }\n    }\n    return result\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) { top = 0; }\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop]\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n        var first = i == 0, last = !order || i == order.length - 1;\n        if (toPos.top - fromPos.top <= 3) { // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else { // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n        if (cmpCoords(toPos, start) < 0) { start = toPos; }\n        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n        if (cmpCoords(toPos, end) < 0) { end = toPos; }\n      });\n      return {start: start, end: end}\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) { return }\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      { display.blinker = setInterval(function () {\n        if (!cm.hasFocus()) { onBlur(cm); }\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate); }\n    else if (cm.options.cursorBlinkRate < 0)\n      { display.cursorDiv.style.visibility = \"hidden\"; }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.hasFocus()) {\n      cm.display.input.focus();\n      if (!cm.state.focused) { onFocus(cm); }\n    }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n      if (cm.state.focused) { onBlur(cm); }\n    } }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }\n\n    if (cm.options.readOnly == \"nocursor\") { return }\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) { return }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], wrapping = cm.options.lineWrapping;\n      var height = (void 0), width = 0;\n      if (cur.hidden) { continue }\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n        // Check that lines don't extend past the right of the current\n        // editor width\n        if (!wrapping && cur.text.firstChild)\n          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\n      }\n      var diff = cur.line.height - height;\n      if (diff > .005 || diff < -.005) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n          { updateWidgetHeight(cur.rest[j]); } }\n      }\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n      var w = line.widgets[i], parent = w.node.parentNode;\n      if (parent) { w.height = parent.offsetHeight; }\n    } }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)}\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (rect.top + box.top < 0) { doScroll = true; }\n    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) { margin = 0; }\n    var rect;\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n    }\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n      var coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      rect = {left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n      }\n      if (!changed) { break }\n    }\n    return rect\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (rect.top < 0) { rect.top = 0; }\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n      if (newTop != screentop) { result.scrollTop = newTop; }\n    }\n\n    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n    var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n    var tooWide = rect.right - rect.left > screenw;\n    if (tooWide) { rect.right = rect.left + screenw; }\n    if (rect.left < 10)\n      { result.scrollLeft = 0; }\n    else if (rect.left < screenleft)\n      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }\n    else if (rect.right > screenw + screenleft - 3)\n      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n    return result\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollTop(cm, top) {\n    if (top == null) { return }\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) { resolveScrollToPos(cm); }\n    if (x != null) { cm.curOp.scrollLeft = x; }\n    if (y != null) { cm.curOp.scrollTop = y; }\n  }\n\n  function scrollToRange(cm, range) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range;\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      scrollToCoordsRange(cm, from, to, range.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  }\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n    if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n    setScrollTop(cm, val, true);\n    if (gecko) { updateDisplaySimple(cm); }\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n  }\n\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    }\n  }\n\n  var NativeScrollbars = function(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      this.vert.firstChild.style.height =\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width =\n        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) { this.zeroWidthHack(); }\n      this.checkedZeroWidth = true;\n    }\n\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n    this.disableHoriz = new Delayed;\n    this.disableVert = new Delayed;\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = \"auto\";\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n      if (elt != bar) { bar.style.pointerEvents = \"none\"; }\n      else { delay.set(1000, maybeDisable); }\n    }\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function () {};\n\n  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\n  NullScrollbars.prototype.setScrollLeft = function () {};\n  NullScrollbars.prototype.setScrollTop = function () {};\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) { measure = measureForScrollbars(cm); }\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        { updateHeightsInViewport(cm); }\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else { d.scrollbarFiller.style.display = \"\"; }\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else { d.gutterFiller.style.display = \"\"; }\n  }\n\n  var scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n      else { updateScrollTop(cm, pos); }\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: 0,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    pushOperation(cm.curOp);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (op) { finishOperation(op, function (group) {\n      for (var i = 0; i < group.ops.length; i++)\n        { group.ops[i].cm.curOp = null; }\n      endOperations(group);\n    }); }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      { endOperation_R1(ops[i]); }\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n      { endOperation_W1(ops[i$1]); }\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n      { endOperation_R2(ops[i$2]); }\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n      { endOperation_W2(ops[i$3]); }\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n      { endOperation_finish(ops[i$4]); }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) { findMaxLine(cm); }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      { op.preparedSelection = display.input.prepareSelection(); }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt();\n    if (op.preparedSelection)\n      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      { updateScrollbars(cm, op.barMeasure); }\n    if (op.updatedDisplay)\n      { setDocumentHeight(cm, op.barMeasure); }\n\n    if (op.selectionChanged) { restartBlink(cm); }\n\n    if (cm.state.focused && op.updateInput)\n      { cm.display.input.reset(op.typing); }\n    if (takeFocus) { ensureFocus(op.cm); }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      { display.wheelStartX = display.wheelStartY = null; }\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) { for (var i = 0; i < hidden.length; ++i)\n      { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n    if (display.wrapper.offsetHeight)\n      { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      { signal(cm, \"changes\", cm, op.changeObjs); }\n    if (op.update)\n      { op.update.finish(); }\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) { return f() }\n    startOperation(cm);\n    try { return f() }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) { return f.apply(cm, arguments) }\n      startOperation(cm);\n      try { return f.apply(cm, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) { return f.apply(this, arguments) }\n      startOperation(this);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(this); }\n    }\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) { return f.apply(this, arguments) }\n      startOperation(cm);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo)\n      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.highlightFrontier >= cm.display.viewTo) { return }\n    var end = +new Date + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n        if (resetState) { context.state = resetState; }\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) { line.styleClasses = newCls; }\n        else if (oldCls) { line.styleClasses = null; }\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n        if (ischange) { changedLines.push(context.line); }\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          { processLine(cm, line.text, context); }\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n    if (changedLines.length) { runInOp(cm, function () {\n      for (var i = 0; i < changedLines.length; i++)\n        { regLineChange(cm, changedLines[i], \"text\"); }\n    }); }\n  }\n\n  // DISPLAY DRAWING\n\n  var DisplayUpdate = function(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type))\n      { this.events.push(arguments); }\n  };\n  DisplayUpdate.prototype.finish = function () {\n    for (var i = 0; i < this.events.length; i++)\n      { signal.apply(null, this.events[i]); }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) { return null }\n    var active = activeElt();\n    if (!active || !contains(cm.display.lineDiv, active)) { return null }\n    var result = {activeElt: active};\n    if (window.getSelection) {\n      var sel = window.getSelection();\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n    return result\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n    snapshot.activeElt.focus();\n    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&\n        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(), range = document.createRange();\n      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      { return false }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      { return false }\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var selSnapshot = selectionSnapshot(cm);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    restoreSelection(selSnapshot);\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          { break }\n      } else if (first) {\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n      }\n      if (!updateDisplayIfNeeded(cm, update)) { break }\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        { node.style.display = \"none\"; }\n      else\n        { node.parentNode.removeChild(node); }\n      return next\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) { cur = rm(cur); }\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) { cur = rm(cur); }\n  }\n\n  function updateGutterSpace(display) {\n    var width = display.gutters.offsetWidth;\n    display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          { view[i].gutter.style.left = left; }\n        if (view[i].gutterBackground)\n          { view[i].gutterBackground.style.left = left; }\n      }\n      var align = view[i].alignable;\n      if (align) { for (var j = 0; j < align.length; j++)\n        { align[j].style.left = left; } }\n    } }\n    if (cm.options.fixedGutter)\n      { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) { return false }\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm.display);\n      return true\n    }\n    return false\n  }\n\n  function getGutters(gutters, lineNumbers) {\n    var result = [], sawLineNumbers = false;\n    for (var i = 0; i < gutters.length; i++) {\n      var name = gutters[i], style = null;\n      if (typeof name != \"string\") { style = name.style; name = name.className; }\n      if (name == \"CodeMirror-linenumbers\") {\n        if (!lineNumbers) { continue }\n        else { sawLineNumbers = true; }\n      }\n      result.push({className: name, style: style});\n    }\n    if (lineNumbers && !sawLineNumbers) { result.push({className: \"CodeMirror-linenumbers\", style: null}); }\n    return result\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function renderGutters(display) {\n    var gutters = display.gutters, specs = display.gutterSpecs;\n    removeChildren(gutters);\n    display.lineGutter = null;\n    for (var i = 0; i < specs.length; ++i) {\n      var ref = specs[i];\n      var className = ref.className;\n      var style = ref.style;\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n      if (style) { gElt.style.cssText = style; }\n      if (className == \"CodeMirror-linenumbers\") {\n        display.lineGutter = gElt;\n        gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = specs.length ? \"\" : \"none\";\n    updateGutterSpace(display);\n  }\n\n  function updateGutters(cm) {\n    renderGutters(cm.display);\n    regChange(cm);\n    alignHorizontally(cm);\n  }\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input, options) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [lines], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n    if (place) {\n      if (place.appendChild) { place.appendChild(d.wrapper); }\n      else { place(d.wrapper); }\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n    renderGutters(d);\n\n    input.init(d);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) { wheelPixelsPerUnit = -.53; }\n  else if (gecko) { wheelPixelsPerUnit = 15; }\n  else if (chrome) { wheelPixelsPerUnit = -.7; }\n  else if (safari) { wheelPixelsPerUnit = -1/3; }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n    else if (dy == null) { dy = e.wheelDelta; }\n    return {x: dx, y: dy}\n  }\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        { e_preventDefault(e); }\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) { return }\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) { return }\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  var Selection = function(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\n  Selection.prototype.equals = function (other) {\n    if (other == this) { return true }\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this.ranges[i], there = other.ranges[i];\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n    }\n    return true\n  };\n\n  Selection.prototype.deepCopy = function () {\n    var out = [];\n    for (var i = 0; i < this.ranges.length; i++)\n      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }\n    return new Selection(out, this.primIndex)\n  };\n\n  Selection.prototype.somethingSelected = function () {\n    for (var i = 0; i < this.ranges.length; i++)\n      { if (!this.ranges[i].empty()) { return true } }\n    return false\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n    if (!end) { end = pos; }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this.ranges[i];\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n        { return i }\n    }\n    return -1\n  };\n\n  var Range = function(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  };\n\n  Range.prototype.from = function () { return minPos(this.anchor, this.head) };\n  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\n  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) { --primIndex; }\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex)\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0)\n  }\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  function changeEnd(change) {\n    if (!change.text) { return change.to }\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n  }\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) { return pos }\n    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n    return Pos(line, ch)\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex)\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n    else\n      { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex)\n  }\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) { line.stateAfter = null; }\n      if (line.styles) { line.styles = null; }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) { regChange(cm); }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      var result = [];\n      for (var i = start; i < end; ++i)\n        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }\n      return result\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) { doc.remove(from.line, nlines); }\n      if (added.length) { doc.insert(from.line, added); }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) { continue }\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) { continue }\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      } }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) { throw new Error(\"This document is already in use.\") }\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    if (!cm.options.lineWrapping) { findMaxLine(cm); }\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n    return histChange\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) { array.pop(); }\n      else { break }\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done)\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done)\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done)\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n    var last;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        { pushSelectionToHistory(doc.sel, hist.done); }\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) { hist.done.shift(); }\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) { signal(doc, \"historyAdded\"); }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      { hist.done[hist.done.length - 1] = sel; }\n    else\n      { pushSelectionToHistory(sel, hist.done); }\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      { clearSelectionEvents(hist.undone); }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      { dest.push(sel); }\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans)\n        { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) { return null }\n    var out;\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n      else if (out) { out.push(spans[i]); }\n    }\n    return !out ? spans : out.length ? out : null\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) { return null }\n    var nw = [];\n    for (var i = 0; i < change.text.length; ++i)\n      { nw.push(removeClearedSpans(found[i])); }\n    return nw\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) { return stretched }\n    if (!stretched) { return old }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            { if (oldCur[k].marker == span.marker) { continue spans } }\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m = (void 0);\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        } } }\n      }\n    }\n    return copy\n  }\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head)\n    } else {\n      return new Range(other || head, head)\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    for (var i = 0; i < doc.sel.ranges.length; i++)\n      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head)); }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\n    else { return sel }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      { sel = filterSelectionChange(doc, sel, options); }\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      { ensureCursorVisible(doc.cm); }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) { return }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) { out = sel.ranges.slice(0, i); }\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n\n      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n      // is with selectLeft/Right\n      var preventCursorLeft = (\"selectLeft\" in m) ? !m.selectLeft : m.inclusiveLeft;\n      var preventCursorRight = (\"selectRight\" in m) ? !m.selectRight : m.inclusiveRight;\n\n      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) { break }\n            else {--i; continue}\n          }\n        }\n        if (!m.atomic) { continue }\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n          if (dir < 0 ? preventCursorRight : preventCursorLeft)\n            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? preventCursorLeft : preventCursorRight)\n          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n      }\n    } }\n    return pos\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0)\n    }\n    return found\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n      else { return null }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n      else { return null }\n    } else {\n      return new Pos(pos.line, pos.ch + dir)\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  }\n\n  // UPDATING\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function () { return obj.canceled = true; }\n    };\n    if (update) { obj.update = function (from, to, text, origin) {\n      if (from) { obj.from = clipPos(doc, from); }\n      if (to) { obj.to = clipPos(doc, to); }\n      if (text) { obj.text = text; }\n      if (origin !== undefined) { obj.origin = origin; }\n    }; }\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n    if (obj.canceled) {\n      if (doc.cm) { doc.cm.curOp.updateInput = 2; }\n      return null\n    }\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n      if (doc.cm.state.suppressEdits) { return }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) { return }\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n    if (suppress && !allowSelectionOnly) { return }\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    var i = 0;\n    for (; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        { break }\n    }\n    if (i == source.length) { return }\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return\n        }\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return\n      } else { break }\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function ( i ) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {}\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop( i$1 );\n\n      if ( returned ) return returned.v;\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) { return }\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n      Pos(range.anchor.line + distance, range.anchor.ch),\n      Pos(range.head.line + distance, range.head.ch)\n    ); }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        { regLineChange(doc.cm, l, \"gutter\"); }\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return\n    }\n    if (change.from.line > doc.lastLine()) { return }\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n    else { updateDoc(doc, change, spans); }\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\n    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))\n      { doc.cantEdit = false; }\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      { signalCursorActivity(cm); }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      { regChange(cm); }\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      { regLineChange(cm, from.line, \"text\"); }\n    else\n      { regChange(cm, from.line, to.line + 1, lendiff); }\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) { to = from; }\n    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\n    if (typeof code == \"string\") { code = doc.splitLines(code); }\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue\n      }\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n    else { no = lineNo(handle); }\n    if (no == null) { return null }\n    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n    return line\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length },\n\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }\n    },\n\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        { if (op(this.lines[at])) { return true } }\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size },\n\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }\n    },\n\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this.children.splice(++i, 0, leaf);\n              leaf.parent = this;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this.maybeSpill();\n          }\n          break\n        }\n        at -= sz;\n      }\n    },\n\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) { return }\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10)\n      me.parent.maybeSpill();\n    },\n\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) { return true }\n          if ((n -= used) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n    }\n  };\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function(doc, node, options) {\n    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n      { this[opt] = options[opt]; } } }\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) { return }\n    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }\n    if (!ws.length) { line.widgets = null; }\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n      var this$1 = this;\n\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) { return }\n    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      { addToScrollTop(cm, diff); }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) { widgets.push(widget); }\n      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) { addToScrollTop(cm, widget.height); }\n        cm.curOp.forceUpdate = true;\n      }\n      return true\n    });\n    if (cm) { signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle)); }\n    return widget\n  }\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  var TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) { startOperation(cm); }\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) { signalLater(this, \"clear\", found.from, found.to); }\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n      else if (cm) {\n        if (span.to != null) { max = lineNo(line); }\n        if (span.from != null) { min = lineNo(line); }\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        { updateLineHeight(line, textHeight(cm.display)); }\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    } }\n\n    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) { reCheckSelection(cm.doc); }\n    }\n    if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n    if (withOp) { endOperation(cm); }\n    if (this.parent) { this.parent.clear(); }\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function (side, lineObj) {\n    if (side == null && this.type == \"bookmark\") { side = 1; }\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) { return from }\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) { return to }\n      }\n    }\n    return from && {from: from, to: to}\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function () {\n      var this$1 = this;\n\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) { return }\n    runInOp(cm, function () {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          { updateLineHeight(line, line.height + dHeight); }\n      }\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n    }\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp\n      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n  eventMixin(TextMarker);\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) { copyObj(options, marker, false); }\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      { return marker }\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory)\n      { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        { updateMaxLine = true; }\n      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n    }); }\n\n    if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n      if (doc.history.done.length || doc.history.undone.length)\n        { doc.clearHistory(); }\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n      if (marker.collapsed)\n        { regChange(cm, from.line, to.line + 1); }\n      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\n               marker.attributes || marker.title)\n        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n      if (marker.atomic) { reCheckSelection(cm.doc); }\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      { markers[i].parent = this; }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) { return }\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      { this.markers[i].clear(); }\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj)\n  };\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) { options.widgetNode = widget.cloneNode(true); }\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        { if (doc.linked[i].isParent) { return } }\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary)\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function ( i ) {\n      var marker = markers[i], linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) loop( i );\n  }\n\n  var nextDocId = 0;\n  var Doc = function(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n    if (firstLine == null) { firstLine = 0; }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") { text = this.splitLines(text); }\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) { this.iterN(from - this.first, to - from, op); }\n      else { this.iterN(this.first, this.first + this.size, from); }\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n    getLineNumber: function(line) {return lineNo(line)},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") { line = getLine(this, line); }\n      return visualLine(line)\n    },\n\n    lineCount: function() {return this.size},\n    firstLine: function() {return this.first},\n    lastLine: function() {return this.first + this.size - 1},\n\n    clipPos: function(pos) {return clipPos(this, pos)},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") { pos = range.head; }\n      else if (start == \"anchor\") { pos = range.anchor; }\n      else if (start == \"end\" || start == \"to\" || start === false) { pos = range.to(); }\n      else { pos = range.from(); }\n      return pos\n    },\n    listSelections: function() { return this.sel.ranges },\n    somethingSelected: function() {return this.sel.somethingSelected()},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) { return }\n      var out = [];\n      for (var i = 0; i < ranges.length; i++)\n        { out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head)); }\n      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) { return lines }\n      else { return lines.join(lineSep || this.lineSeparator()) }\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }\n        parts[i] = sel;\n      }\n      return parts\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        { dup[i] = code; }\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n        { makeChange(this, changes[i$1]); }\n      if (newSel) { setSelectionReplaceHistory(this, newSel); }\n      else if (this.cm) { ensureCursorVisible(this.cm); }\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n      return {undo: done, redo: undone}\n    },\n    clearHistory: function() {\n      var this$1 = this;\n\n      this.history = new History(this.history.maxGeneration);\n      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);\n    },\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n      return this.history.generation\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration)\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)}\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    setGutterMarker: docMethodOp(function(line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n        return true\n      })\n    }),\n\n    clearGutter: docMethodOp(function(gutterID) {\n      var this$1 = this;\n\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n            return true\n          });\n        }\n      });\n    }),\n\n    lineInfo: function(line) {\n      var n;\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) { return null }\n        n = line;\n        line = getLine(this, line);\n        if (!line) { return null }\n      } else {\n        n = lineNo(line);\n        if (n == null) { return null }\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets}\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) { line[prop] = cls; }\n        else if (classTest(cls).test(line[prop])) { return false }\n        else { line[prop] += \" \" + cls; }\n        return true\n      })\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) { return false }\n        else if (cls == null) { line[prop] = null; }\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) { return false }\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true\n      })\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options)\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\")\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          { markers.push(span.marker.parent || span.marker); }\n      } }\n      return markers\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n        if (spans) { for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\n                span.from == null && lineNo != from.line ||\n                span.from != null && lineNo == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            { found.push(span.marker.parent || span.marker); }\n        } }\n        ++lineNo;\n      });\n      return found\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) { for (var i = 0; i < sps.length; ++i)\n          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n      });\n      return markers\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch))\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) { return 0 }\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc\n    },\n\n    linkedDoc: function(options) {\n      if (!options) { options = {}; }\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) { from = options.from; }\n      if (options.to != null && options.to < to) { to = options.to; }\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n      if (options.sharedHist) { copy.history = this.history\n      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) { other = other.doc; }\n      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) { continue }\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break\n      } }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode},\n    getEditor: function() {return this.cm},\n\n    splitLines: function(str) {\n      if (this.lineSep) { return str.split(this.lineSep) }\n      return splitLinesAuto(str)\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") { dir = \"ltr\"; }\n      if (dir == this.direction) { return }\n      this.direction = dir;\n      this.iter(function (line) { return line.order = null; });\n      if (this.cm) { directionChanged(this.cm); }\n    })\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      { return }\n    e_preventDefault(e);\n    if (ie) { lastDrop = +new Date; }\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) { return }\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var markAsReadAndPasteIfAllFilesAreRead = function () {\n        if (++read == n) {\n          operation(cm, function () {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(\n                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));\n          })();\n        }\n      };\n      var readTextFromFile = function (file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n          markAsReadAndPasteIfAllFilesAreRead();\n          return\n        }\n        var reader = new FileReader;\n        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };\n        reader.onload = function () {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n            markAsReadAndPasteIfAllFilesAreRead();\n            return\n          }\n          text[i] = content;\n          markAsReadAndPasteIfAllFilesAreRead();\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function () { return cm.display.input.focus(); }, 20);\n        return\n      }\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n        if (text$1) {\n          var selected;\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            { selected = cm.listSelections(); }\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n            { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e$1){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\";\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) { img.parentNode.removeChild(img); }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) { return }\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) { return }\n    var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) { editors.push(cm); }\n    }\n    if (editors.length) { editors[0].operation(function () {\n      for (var i = 0; i < editors.length; i++) { f(editors[i]); }\n    }); }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) { return }\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100); }\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n  }\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 145: \"ScrollLock\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 224: \"Mod\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n\n  // Number keys\n  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n  // Alphabetic keys\n  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n  // Function keys\n  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\n  var keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n    \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n      else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n      else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n      else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n    }\n    if (alt) { name = \"Alt-\" + name; }\n    if (ctrl) { name = \"Ctrl-\" + name; }\n    if (cmd) { name = \"Cmd-\" + name; }\n    if (shift) { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n      if (value == \"...\") { delete keymap[keyname]; continue }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val = (void 0), name = (void 0);\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) { copy[name] = val; }\n        else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n      }\n      delete keymap[keyname];\n    } }\n    for (var prop in copy) { keymap[prop] = copy[prop]; }\n    return keymap\n  }\n\n  function lookupKey(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) { return \"nothing\" }\n    if (found === \"...\") { return \"multi\" }\n    if (found != null && handle(found)) { return \"handled\" }\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n        { return lookupKey(key, map.fallthrough, handle, context) }\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) { return result }\n      }\n    }\n  }\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n    if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Mod\") { name = \"Cmd-\" + name; }\n    if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // Look up the name of a key as indicated by an event object.\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) { return false }\n    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n    if (event.keyCode == 3 && event.code) { name = event.code; }\n    return addModifierNames(name, event, noShift)\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      if (cm.doc.direction == \"rtl\") { dir = -dir; }\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = (dir < 0) == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch;\n        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n          if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n        } else { ch = dir < 0 ? part.to : part.from; }\n        return new Pos(lineNo, ch, sticky)\n      }\n    }\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n    if (!bidi) { return moveLogically(line, start, dir) }\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir)\n    }\n\n    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n    var prep;\n    var getWrappedLineExtent = function (ch) {\n      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch)\n    };\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = (part.level == 1) == (dir < 0);\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky)\n      }\n    }\n\n    // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n        ? new Pos(start.line, mv(ch, 1), \"before\")\n        : new Pos(start.line, ch, \"after\"); };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = (dir > 0) == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n      }\n    };\n\n    // Case 3a: Look for other bidi parts on the same visual line\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n    if (res) { return res }\n\n    // Case 3b: Look for other bidi parts on the next visual line\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n      if (res) { return res }\n    }\n\n    // Case 4: Nowhere to move\n    return null\n  }\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n    killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n      if (range.empty()) {\n        var len = getLine(cm.doc, range.head.line).text.length;\n        if (range.head.ch == len && range.head.line < cm.lastLine())\n          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n        else\n          { return {from: range.head, to: Pos(range.head.line, len)} }\n      } else {\n        return {from: range.from(), to: range.to()}\n      }\n    }); },\n    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0),\n      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n    }); }); },\n    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0), to: range.from()\n    }); }); },\n    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n      return {from: leftPos, to: range.from()}\n    }); },\n    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      return {from: range.from(), to: rightPos }\n    }); },\n    undo: function (cm) { return cm.undo(); },\n    redo: function (cm) { return cm.redo(); },\n    undoSelection: function (cm) { return cm.undoSelection(); },\n    redoSelection: function (cm) { return cm.redoSelection(); },\n    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n      {origin: \"+move\", bias: -1}\n    ); },\n    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: 0, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n      if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n      return pos\n    }, sel_move); },\n    goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n    goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n    goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n    goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n    goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n    goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n    goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n    goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n    goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n    goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n    goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n    goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n    delCharBefore: function (cm) { return cm.deleteH(-1, \"codepoint\"); },\n    delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n    delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n    delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n    delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n    delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n    indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n    indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n    indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n    insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n    insertSoftTab: function (cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function (cm) {\n      if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n      else { cm.execCommand(\"insertTab\"); }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function (cm) { return runInOp(cm, function () {\n      var ranges = cm.listSelections(), newSel = [];\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty()) { continue }\n        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n        if (line) {\n          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n          if (cur.ch > 0) {\n            cur = new Pos(cur.line, cur.ch + 1);\n            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                            Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n          } else if (cur.line > cm.doc.first) {\n            var prev = getLine(cm.doc, cur.line - 1).text;\n            if (prev) {\n              cur = new Pos(cur.line, 1);\n              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                              prev.charAt(prev.length - 1),\n                              Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n            }\n          }\n        }\n        newSel.push(new Range(cur, cur));\n      }\n      cm.setSelections(newSel);\n    }); },\n    newlineAndIndent: function (cm) { return runInOp(cm, function () {\n      var sels = cm.listSelections();\n      for (var i = sels.length - 1; i >= 0; i--)\n        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n      sels = cm.listSelections();\n      for (var i$1 = 0; i$1 < sels.length; i$1++)\n        { cm.indentLine(sels[i$1].from().line, null, true); }\n      ensureCursorVisible(cm);\n    }); },\n    openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n  };\n\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, visual, lineN, 1)\n  }\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, line, lineN, -1)\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n    }\n    return start\n  }\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) { return false }\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      if (dropShift) { cm.display.shift = false; }\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) { return result }\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm)\n  }\n\n  // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n  var stopSeq = new Delayed;\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) { return \"handled\" }\n      if (/\\'$/.test(name))\n        { cm.state.keySeq = null; }\n      else\n        { stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        }); }\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n    }\n    return dispatchKeyInner(cm, name, e, handle)\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      { cm.state.keySeq = name; }\n    if (result == \"handled\")\n      { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) { return false }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n          || dispatchKey(cm, name, e, function (b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 { return doHandleBinding(cm, b) }\n             })\n    } else {\n      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) { return }\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        { cm.replaceSelection(\"\", null, \"cut\"); }\n    }\n    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)\n      { document.execCommand(\"cut\"); }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      { showCrossHair(cm); }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) { this.doc.sel.shift = false; }\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (e.target && e.target != cm.display.input.getField()) { return }\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    // Some browsers fire keypress events for backspace\n    if (ch == \"\\x08\") { return }\n    if (handleCharBinding(cm, e, ch)) { return }\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time &&\n      cmp(pos, this.pos) == 0 && button == this.button\n  };\n\n  var lastClick, lastDoubleClick;\n  function clickRepeat(pos, button) {\n    var now = +new Date;\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\"\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\"\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\"\n    }\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () { return display.scroller.draggable = true; }, 100);\n      }\n      return\n    }\n    if (clickInGutter(cm, e)) { return }\n    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n    window.focus();\n\n    // #3261: make sure, that we're not starting a second selection\n    if (button == 1 && cm.state.selectingText)\n      { cm.state.selectingText(e); }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n    if (button == 1) {\n      if (pos) { leftButtonDown(cm, pos, repeat, e); }\n      else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n    } else if (button == 2) {\n      if (pos) { extendSelection(cm.doc, pos); }\n      setTimeout(function () { return display.input.focus(); }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) { cm.display.input.onContextMenu(e); }\n      else { delayBlurEvent(cm); }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n    if (repeat == \"double\") { name = \"Double\" + name; }\n    else if (repeat == \"triple\") { name = \"Triple\" + name; }\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") { bound = commands[bound]; }\n      if (!bound) { return false }\n      var done = false;\n      try {\n        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n      return done\n    })\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n    return value\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n    else { cm.curOp.focus = activeElt(); }\n\n    var behavior = configureMouse(cm, repeat, event);\n\n    var sel = cm.doc.sel, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n      { leftButtonStartDrag(cm, event, pos, behavior); }\n    else\n      { leftButtonSelect(cm, event, pos, behavior); }\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display, moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) { display.scroller.draggable = false; }\n      cm.state.draggingText = false;\n      if (cm.state.delayingBlurEvent) {\n        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }\n        else { delayBlurEvent(cm); }\n      }\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n      if (!moved) {\n        e_preventDefault(e);\n        if (!behavior.addNew)\n          { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if ((webkit && !safari) || ie && ie_version == 9)\n          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }\n        else\n          { display.input.focus(); }\n      }\n    });\n    var mouseMove = function(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n    var dragStart = function () { return moved = true; };\n    // Let the drag handler handle this.\n    if (webkit) { display.scroller.draggable = true; }\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { return display.input.focus(); }, 20);\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") { return new Range(pos, pos) }\n    if (unit == \"word\") { return cm.findWordAt(pos) }\n    if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to)\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, event, start, behavior) {\n    if (ie) { delayBlurEvent(cm); }\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(event);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        { ourRange = ranges[ourIndex]; }\n      else\n        { ourRange = new Range(start, start); }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) { ourRange = new Range(start, start); }\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range = rangeForUnit(cm, start, behavior.unit);\n      if (behavior.extend)\n        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }\n      else\n        { ourRange = range; }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) { return }\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n          else if (text.length > leftPos)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n        }\n        if (!ranges.length) { ranges.push(new Range(start, start)); }\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor, head;\n        if (cmp(range.anchor, anchor) > 0) {\n          head = range.head;\n          anchor = minPos(oldRange.from(), range.anchor);\n        } else {\n          head = range.anchor;\n          anchor = maxPos(oldRange.to(), range.head);\n        }\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n      if (!cur) { return }\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) { setTimeout(operation(cm, function () {\n          if (counter != curCount) { return }\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50); }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      // If e is null or undefined we interpret this as someone trying\n      // to explicitly cancel the selection rather than the user\n      // letting go of the mouse button.\n      if (e) {\n        e_preventDefault(e);\n        display.input.focus();\n      }\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) { done(e); }\n      else { extend(e); }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  }\n\n  // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n  function bidiSimplify(cm, range) {\n    var anchor = range.anchor;\n    var head = range.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }\n    var order = getOrder(anchorLine);\n    if (!order) { return range }\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n    if (part.from != anchor.ch && part.to != anchor.ch) { return range }\n    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n    if (boundary == 0 || boundary == order.length) { return range }\n\n    // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n    var leftSide;\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n      if (headIndex == boundary - 1 || headIndex == boundary)\n        { leftSide = dir < 0; }\n      else\n        { leftSide = dir > 0; }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)\n  }\n\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try { mX = e.clientX; mY = e.clientY; }\n      catch(e$1) { return false }\n    }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n    if (prevent) { e_preventDefault(e); }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.display.gutterSpecs[i];\n        signal(cm, type, cm, line, gutter.className, e);\n        return e_defaultPrevented(e)\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true)\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n    if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n    if (!captureRightClick) { cm.display.input.onContextMenu(e); }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n    return gutterEvent(cm, e, \"gutterContextMenu\", false)\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {toString: function(){return \"CodeMirror.Init\"}};\n\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n      if (handle) { optionHandlers[name] =\n        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n    }\n\n    CodeMirror.defineOption = option;\n\n    // Passed to option handlers when there is no old value.\n    CodeMirror.Init = Init;\n\n    // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n    option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n      if (!val) { return }\n      var newBreaks = [], lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n          if (found == -1) { break }\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n        lineNo++;\n      });\n      for (var i = newBreaks.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200c\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n      if (old != Init) { cm.refresh(); }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n    option(\"autocorrect\", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);\n    option(\"autocapitalize\", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      updateGutters(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n      if (prev && prev.detach) { prev.detach(cm, next); }\n      if (next.attach) { next.attach(cm, prev || null); }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm, val) {\n      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n      updateGutters(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm, val) {\n      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n      updateGutters(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, updateGutters, true);\n    option(\"lineNumberFormatter\", function (integer) { return integer; }, updateGutters, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n      cm.display.input.readOnlyChanged(val);\n    });\n\n    option(\"screenReaderLabel\", null, function (cm, val) {\n      val = (val === '') ? null : val;\n      cm.display.input.screenReaderLabelChanged(val);\n    });\n\n    option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) { cm.display.input.resetPosition(); }\n    });\n\n    option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n    option(\"phrases\", null);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () { return updateScrollbars(cm); }, 100);\n  }\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n    else if (options.mode) { doc.modeOption = options.mode; }\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input, options);\n    display.wrapper.CodeMirror = this;\n    themeChanged(this);\n    if (options.lineWrapping)\n      { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) { display.input.focus(); }\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || this.hasFocus())\n      { setTimeout(function () {\n        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }\n      }, 20); }\n    else\n      { onBlur(this); }\n\n    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n      { optionHandlers[opt](this, options[opt], Init); } }\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) { options.finishInit(this); }\n    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      { display.lineDiv.style.textRendering = \"auto\"; }\n  }\n\n  // The default configuration options.\n  CodeMirror.defaults = defaults;\n  // Functions to run when options are changed.\n  CodeMirror.optionHandlers = optionHandlers;\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) { return }\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      })); }\n    else\n      { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); });\n    on(d.input.getField(), \"contextmenu\", function (e) {\n      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }\n    });\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    }\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) { return false }\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1\n    }\n    function farAway(touch, other) {\n      if (other.left == null) { return true }\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20\n    }\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) { d.activeTouch.moved = true; }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          { range = new Range(pos, pos); }\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          { range = cm.findWordAt(pos); }\n        else // Triple tap\n          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n    on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function (e) { return onDragStart(cm, e); },\n      drop: operation(cm, onDrop),\n      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n    on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n  }\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) { how = \"add\"; }\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) { how = \"prev\"; }\n      else { state = getContextBefore(cm, n).state; }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) { line.stateAfter = null; }\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) { return }\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n      else { indentation = 0; }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n    if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break\n        }\n      }\n    }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) { sel = doc.sel; }\n\n    var recent = +new Date - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted), multiPaste = null;\n    // When pasting N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) { return [l]; });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput;\n    // Normal behavior is to insert the new text into every selection\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range = sel.ranges[i$1];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          { from = Pos(from.line, from.ch - deleted); }\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == textLines.join(\"\\n\"))\n          { from = to = Pos(from.line, 0); }\n      }\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      { triggerElectric(cm, inserted); }\n\n    ensureCursorVisible(cm);\n    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n      return true\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break\n          } }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          { indented = indentLine(cm, range.head.line, \"smart\"); }\n      }\n      if (indented) { signalLater(cm, \"electricInput\", cm, range.head.line); }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges}\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", autocorrect ? \"\" : \"off\");\n    field.setAttribute(\"autocapitalize\", autocapitalize ? \"\" : \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) { te.style.width = \"1000px\"; }\n    else { te.setAttribute(\"wrap\", \"off\"); }\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) { te.style.border = \"1px solid black\"; }\n    disableBrowserMagic(te);\n    return div\n  }\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    var helpers = CodeMirror.helpers = {};\n\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function(){window.focus(); this.display.input.focus();},\n\n      setOption: function(option, value) {\n        var options = this.options, old = options[option];\n        if (options[option] == value && option != \"mode\") { return }\n        options[option] = value;\n        if (optionHandlers.hasOwnProperty(option))\n          { operation(this, optionHandlers[option])(this, value, old); }\n        signal(this, \"optionChange\", this, option);\n      },\n\n      getOption: function(option) {return this.options[option]},\n      getDoc: function() {return this.doc},\n\n      addKeyMap: function(map, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n      },\n      removeKeyMap: function(map) {\n        var maps = this.state.keyMaps;\n        for (var i = 0; i < maps.length; ++i)\n          { if (maps[i] == map || maps[i].name == map) {\n            maps.splice(i, 1);\n            return true\n          } }\n      },\n\n      addOverlay: methodOp(function(spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n        if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n        insertSorted(this.state.overlays,\n                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                      priority: (options && options.priority) || 0},\n                     function (overlay) { return overlay.priority; });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function(spec) {\n        var overlays = this.state.overlays;\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this.state.modeGen++;\n            regChange(this);\n            return\n          }\n        }\n      }),\n\n      indentLine: methodOp(function(n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n          else { dir = dir ? \"add\" : \"subtract\"; }\n        }\n        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n      }),\n      indentSelection: methodOp(function(how) {\n        var ranges = this.doc.sel.ranges, end = -1;\n        for (var i = 0; i < ranges.length; i++) {\n          var range = ranges[i];\n          if (!range.empty()) {\n            var from = range.from(), to = range.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n            for (var j = start; j < end; ++j)\n              { indentLine(this, j, how); }\n            var newRanges = this.doc.sel.ranges;\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n          } else if (range.head.line > end) {\n            indentLine(this, range.head.line, how, true);\n            end = range.head.line;\n            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }\n          }\n        }\n      }),\n\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function(pos, precise) {\n        return takeToken(this, pos, precise)\n      },\n\n      getLineTokens: function(line, precise) {\n        return takeToken(this, Pos(line), precise, true)\n      },\n\n      getTokenTypeAt: function(pos) {\n        pos = clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n        var type;\n        if (ch == 0) { type = styles[2]; }\n        else { for (;;) {\n          var mid = (before + after) >> 1;\n          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n          else { type = styles[mid * 2 + 2]; break }\n        } }\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n      },\n\n      getModeAt: function(pos) {\n        var mode = this.doc.mode;\n        if (!mode.innerMode) { return mode }\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n      },\n\n      getHelper: function(pos, type) {\n        return this.getHelpers(pos, type)[0]\n      },\n\n      getHelpers: function(pos, type) {\n        var found = [];\n        if (!helpers.hasOwnProperty(type)) { return found }\n        var help = helpers[type], mode = this.getModeAt(pos);\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) { found.push(help[mode[type]]); }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n            if (val) { found.push(val); }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n            { found.push(cur.val); }\n        }\n        return found\n      },\n\n      getStateAfter: function(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n        return getContextBefore(this, line + 1, precise).state\n      },\n\n      cursorCoords: function(start, mode) {\n        var pos, range = this.doc.sel.primary();\n        if (start == null) { pos = range.head; }\n        else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n        else { pos = start ? range.from() : range.to(); }\n        return cursorCoords(this, pos, mode || \"page\")\n      },\n\n      charCoords: function(pos, mode) {\n        return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n      },\n\n      coordsChar: function(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return coordsChar(this, coords.left, coords.top)\n      },\n\n      lineAtHeight: function(height, mode) {\n        height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n        return lineAtHeight(this.doc, height + this.display.viewOffset)\n      },\n      heightAtLine: function(line, mode, includeWidgets) {\n        var end = false, lineObj;\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n          if (line < this.doc.first) { line = this.doc.first; }\n          else if (line > last) { line = last; end = true; }\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n          (end ? this.doc.height - heightAtLine(lineObj) : 0)\n      },\n\n      defaultTextHeight: function() { return textHeight(this.display) },\n      defaultCharWidth: function() { return charWidth(this.display) },\n\n      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = cursorCoords(this, clipPos(this.doc, pos));\n        var top = pos.bottom, left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n          // Default to positioning above (if specified and possible); otherwise default to positioning below\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n            { top = pos.top - node.offsetHeight; }\n          else if (pos.bottom + node.offsetHeight <= vspace)\n            { top = pos.bottom; }\n          if (left + node.offsetWidth > hspace)\n            { left = hspace - node.offsetWidth; }\n        }\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") { left = 0; }\n          else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n          node.style.left = left + \"px\";\n        }\n        if (scroll)\n          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n      },\n\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n\n      execCommand: function(cmd) {\n        if (commands.hasOwnProperty(cmd))\n          { return commands[cmd].call(null, this) }\n      },\n\n      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n      findPosH: function(from, amount, unit, visually) {\n        var dir = 1;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          cur = findPosH(this.doc, cur, dir, unit, visually);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveH: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        this.extendSelectionsBy(function (range) {\n          if (this$1.display.shift || this$1.doc.extend || range.empty())\n            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }\n          else\n            { return dir < 0 ? range.from() : range.to() }\n        }, sel_move);\n      }),\n\n      deleteH: methodOp(function(dir, unit) {\n        var sel = this.doc.sel, doc = this.doc;\n        if (sel.somethingSelected())\n          { doc.replaceSelection(\"\", null, \"+delete\"); }\n        else\n          { deleteNearSelection(this, function (range) {\n            var other = findPosH(doc, range.head, dir, unit, false);\n            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}\n          }); }\n      }),\n\n      findPosV: function(from, amount, unit, goalColumn) {\n        var dir = 1, x = goalColumn;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          var coords = cursorCoords(this, cur, \"div\");\n          if (x == null) { x = coords.left; }\n          else { coords.left = x; }\n          cur = findPosV(this, coords, dir, unit);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveV: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        var doc = this.doc, goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range) {\n          if (collapse)\n            { return dir < 0 ? range.from() : range.to() }\n          var headPos = cursorCoords(this$1, range.head, \"div\");\n          if (range.goalColumn != null) { headPos.left = range.goalColumn; }\n          goals.push(headPos.left);\n          var pos = findPosV(this$1, headPos, dir, unit);\n          if (unit == \"page\" && range == doc.sel.primary())\n            { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n          return pos\n        }, sel_move);\n        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n          { doc.sel.ranges[i].goalColumn = goals[i]; } }\n      }),\n\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function(pos) {\n        var doc = this.doc, line = getLine(doc, pos.line).text;\n        var start = pos.ch, end = pos.ch;\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n          if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper)\n            ? function (ch) { return isWordChar(ch, helper); }\n            : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n            : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n          while (start > 0 && check(line.charAt(start - 1))) { --start; }\n          while (end < line.length && check(line.charAt(end))) { ++end; }\n        }\n        return new Range(Pos(pos.line, start), Pos(pos.line, end))\n      },\n\n      toggleOverwrite: function(value) {\n        if (value != null && value == this.state.overwrite) { return }\n        if (this.state.overwrite = !this.state.overwrite)\n          { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n        else\n          { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function() { return this.display.input.getField() == activeElt() },\n      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n      getScrollInfo: function() {\n        var scroller = this.display.scroller;\n        return {left: scroller.scrollLeft, top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n      },\n\n      scrollIntoView: methodOp(function(range, margin) {\n        if (range == null) {\n          range = {from: this.doc.sel.primary().head, to: null};\n          if (margin == null) { margin = this.options.cursorScrollMargin; }\n        } else if (typeof range == \"number\") {\n          range = {from: Pos(range, 0), to: null};\n        } else if (range.from == null) {\n          range = {from: range, to: null};\n        }\n        if (!range.to) { range.to = range.from; }\n        range.margin = margin || 0;\n\n        if (range.from.line != null) {\n          scrollToRange(this, range);\n        } else {\n          scrollToCoordsRange(this, range.from, range.to, range.margin);\n        }\n      }),\n\n      setSize: methodOp(function(width, height) {\n        var this$1 = this;\n\n        var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n        if (width != null) { this.display.wrapper.style.width = interpret(width); }\n        if (height != null) { this.display.wrapper.style.height = interpret(height); }\n        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n        var lineNo = this.display.viewFrom;\n        this.doc.iter(lineNo, this.display.viewTo, function (line) {\n          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, \"widget\"); break } } }\n          ++lineNo;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n\n      operation: function(f){return runInOp(this, f)},\n      startOperation: function(){return startOperation(this)},\n      endOperation: function(){return endOperation(this)},\n\n      refresh: methodOp(function() {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this.display);\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)\n          { estimateLineHeights(this); }\n        signal(this, \"refresh\", this);\n      }),\n\n      swapDoc: methodOp(function(doc) {\n        var old = this.doc;\n        old.cm = null;\n        // Cancel the current text selection if any (#5821)\n        if (this.state.selectingText) { this.state.selectingText(); }\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old\n      }),\n\n      phrase: function(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\n      },\n\n      getInputField: function(){return this.display.input.getField()},\n      getWrapperElement: function(){return this.display.wrapper},\n      getScrollerElement: function(){return this.display.scroller},\n      getGutterElement: function(){return this.display.gutters}\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function(type, name, value) {\n      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n      helpers[type][name] = value;\n    };\n    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n      helpers[type]._global.push({pred: predicate, val: value});\n    };\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"codepoint\", \"char\", \"column\" (like char, but\n  // doesn't cross line boundaries), \"word\" (across next word), or\n  // \"group\" (to the start of next group of word or\n  // non-word-non-whitespace chars). The visually param controls\n  // whether, in right-to-left text, direction 1 means to move towards\n  // the next index in the string, or towards the character to the right\n  // of the current position. The resulting position will have a\n  // hitSide=true property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    var lineDir = visually && doc.direction == \"rtl\" ? -dir : dir;\n    function findNextLine() {\n      var l = pos.line + lineDir;\n      if (l < doc.first || l >= doc.first + doc.size) { return false }\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l)\n    }\n    function moveOnce(boundToLine) {\n      var next;\n      if (unit == \"codepoint\") {\n        var ch = lineObj.text.charCodeAt(pos.ch + (unit > 0 ? 0 : -1));\n        if (isNaN(ch)) { next = null; }\n        else { next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (ch >= 0xD800 && ch < 0xDC00 ? 2 : 1))),\n                            -dir); }\n      } else if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n      if (next == null) {\n        if (!boundToLine && findNextLine())\n          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }\n        else\n          { return false }\n      } else {\n        pos = next;\n      }\n      return true\n    }\n\n    if (unit == \"char\" || unit == \"codepoint\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) { break }\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) { type = \"s\"; }\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n          break\n        }\n\n        if (type) { sawType = type; }\n        if (dir > 0 && !moveOnce(!first)) { break }\n      }\n    }\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n    return result\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    var target;\n    for (;;) {\n      target = coordsChar(cm, x, y);\n      if (!target.outside) { break }\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n      y += dir * 5;\n    }\n    return target\n  }\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  var ContentEditableInput = function(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = input.cm;\n    var div = input.div = display.lineDiv;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    function belongsToInput(e) {\n      for (var t = e.target; t; t = t.parentNode) {\n        if (t == div) { return true }\n        if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) { break }\n      }\n      return false\n    }\n\n    on(div, \"paste\", function (e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n      // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n    });\n\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {data: e.data, done: false};\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n        this$1.composing.done = true;\n      }\n    });\n\n    on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n    on(div, \"input\", function () {\n      if (!this$1.composing) { this$1.readFromDOMSoon(); }\n    });\n\n    function onCopyCut(e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n        if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\");\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        e.clipboardData.setData(\"Text\", content);\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return\n        }\n      }\n      // Old-fashioned briefly-focus-a-textarea hack\n      var kludge = hiddenTextarea(), te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = document.activeElement;\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n        if (hadFocus == div) { input.showPrimarySelection(); }\n      }, 50);\n    }\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.div.setAttribute('aria-label', label);\n    } else {\n      this.div.removeAttribute('aria-label');\n    }\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = document.activeElement == this.div;\n    return result\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) { return }\n    if (info.focus || takeFocus) { this.showPrimarySelection(); }\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection()\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n    var from = prim.from(), to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n        cmp(minPos(curAnchor, curFocus), from) == 0 &&\n        cmp(maxPos(curAnchor, curFocus), to) == 0)\n      { return }\n\n    var view = cm.display.view;\n    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n        {node: view[0].measure.map[2], offset: 0};\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0), rng;\n    try { rng = range(start.node, start.offset, end.offset, end.node); }\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n      if (old && sel.anchorNode == null) { sel.addRange(old); }\n      else if (gecko) { this.startGracePeriod(); }\n    }\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n      var this$1 = this;\n\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n      if (this$1.selectionChanged())\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n    if (!sel.rangeCount) { return false }\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node)\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor() || document.activeElement != this.div)\n        { this.showSelection(this.prepareSelection(), true); }\n      this.div.focus();\n    }\n  };\n  ContentEditableInput.prototype.blur = function () { this.div.blur(); };\n  ContentEditableInput.prototype.getField = function () { return this.div };\n\n  ContentEditableInput.prototype.supportsTouch = function () { return true };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var input = this;\n    if (this.selectionInEditor())\n      { this.pollSelection(); }\n    else\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n    var sel = this.getSelection(), cm = this.cm;\n    // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n      this.blur();\n      this.focus();\n      return\n    }\n    if (this.composing) { return }\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (anchor && head) { runInOp(cm, function () {\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n    }); }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n    var from = sel.from(), to = sel.to();\n    if (from.ch == 0 && from.line > cm.firstLine())\n      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n      { to = Pos(to.line + 1, 0); }\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n    var fromIndex, fromLine, fromNode;\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) { return false }\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n      else { break }\n    }\n\n    var cutFront = 0, cutEnd = 0;\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n      { ++cutFront; }\n    var newBot = lst(newText), oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0));\n    while (cutEnd < maxCutEnd &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n      { ++cutEnd; }\n    // Try to move start of change to start of selection if ambiguous\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n      return true\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) { return }\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n      var this$1 = this;\n\n    if (this.readDOMTimeout != null) { return }\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n      if (this$1.composing) {\n        if (this$1.composing.done) { this$1.composing = null; }\n        else { return }\n      }\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n      var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent())\n      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) { return }\n    e.preventDefault();\n    if (!this.cm.isReadOnly())\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) { return null }\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line, cm.doc.direction), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode)\n      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n    return false\n  }\n\n  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n    function close() {\n      if (closing) {\n        text += lineSep;\n        if (extraLinebreak) { text += lineSep; }\n        closing = extraLinebreak = false;\n      }\n    }\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText) {\n          addText(cmText);\n          return\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find(0)))\n            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }\n          return\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }\n\n        if (isBlock) { close(); }\n        for (var i = 0; i < node.childNodes.length; i++)\n          { walk(node.childNodes[i]); }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\n        if (isBlock) { closing = true; }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) { break }\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n    return text\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        { return locateNodeInLineView(lineView, node, offset) }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad)\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) { offset = textNode.nodeValue.length; }\n    }\n    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }\n            return Pos(line, ch)\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) { return badPos(found, bad) }\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        { return badPos(Pos(found.line, found.ch - dist), bad) }\n      else\n        { dist += after.textContent.length; }\n    }\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n      else\n        { dist$1 += before.textContent.length; }\n    }\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  var TextareaInput = function(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n    if (ios) { te.style.width = \"0px\"; }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n      input.poll();\n    });\n\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n      cm.state.pasteIncoming = +new Date;\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n      if (e.type == \"cut\") { cm.state.cutIncoming = +new Date; }\n    }\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date;\n        input.focus();\n        return\n      }\n\n      // Pass the `paste` event to the textarea so it's handled by its event listener.\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    });\n\n    // Prevent normal selection in the editor (we handle our own)\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) { e_preventDefault(e); }\n    });\n\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n      if (input.composing) { input.composing.range.clear(); }\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea();\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if(label) {\n      this.textarea.setAttribute('aria-label', label);\n    } else {\n      this.textarea.removeAttribute('aria-label');\n    }\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm, display = cm.display, doc = cm.doc;\n    var result = prepareSelection(cm);\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm, display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  };\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) { return }\n    var cm = this.cm;\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n      if (cm.state.focused) { selectInput(this.textarea); }\n      if (ie && ie_version >= 9) { this.hasSelection = content; }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n      if (ie && ie_version >= 9) { this.hasSelection = null; }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () { return this.textarea };\n\n  TextareaInput.prototype.supportsTouch = function () { return false };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n      try { this.textarea.focus(); }\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n    }\n  };\n\n  TextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  TextareaInput.prototype.slowPoll = function () {\n      var this$1 = this;\n\n    if (this.pollingFast) { return }\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n      if (this$1.cm.state.focused) { this$1.slowPoll(); }\n    });\n  };\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false, input = this;\n    input.pollingFast = true;\n    function p() {\n      var changed = input.poll();\n      if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n      else {input.pollingFast = false; input.slowPoll();}\n    }\n    input.polling.set(20, p);\n  };\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  TextareaInput.prototype.poll = function () {\n      var this$1 = this;\n\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (this.contextMenuPending || !cm.state.focused ||\n        (hasSelection(input) && !prevInput && !this.composing) ||\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n      { return false }\n\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) { return false }\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && this.hasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n      if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n    }\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\n                     null, this$1.composing ? \"*compose\" : null);\n\n      // Don't leave long text in the textarea, since it makes further polling slow\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n      else { this$1.prevInput = text; }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                           {className: \"CodeMirror-composing\"});\n      }\n    });\n    return true\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n    if (input.contextMenuPending) { input.contextMenuPending(); }\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) { return } // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n    display.input.focus();\n    if (webkit) { window.scrollTo(null, oldScrollY); }\n    display.input.reset();\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200b\" + (selected ? te.value : \"\");\n        te.value = \"\\u21da\"; // Used to catch context-menu undo\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200b\";\n        te.selectionStart = 1; te.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      if (input.contextMenuPending != rehide) { return }\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n      // Try to detect the user choosing select-all\n      if (te.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n        var i = 0, poll = function () {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n              te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function () {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) { this.reset(); }\n    this.textarea.disabled = val == \"nocursor\";\n    this.textarea.readOnly = !!val;\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      { options.tabindex = textarea.tabIndex; }\n    if (!options.placeholder && textarea.placeholder)\n      { options.placeholder = textarea.placeholder; }\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n\n    var realSubmit;\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n      cm.getTextArea = function () { return textarea; };\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == \"function\")\n            { textarea.form.submit = realSubmit; }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n      options);\n    return cm\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  }\n\n  // EDITOR CONSTRUCTOR\n\n  defineOptions(CodeMirror);\n\n  addEditorMethods(CodeMirror);\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    { CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments)}\n    })(Doc.prototype[prop]); } }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name/*, mode, */) {\n    if (!CodeMirror.defaults.mode && name != \"null\") { CodeMirror.defaults.mode = name; }\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME;\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n\n  addLegacyProps(CodeMirror);\n\n  CodeMirror.version = \"5.59.0\";\n\n  return CodeMirror;\n\n})));\n\n\n//# sourceURL=webpack:///./node_modules/codemirror/lib/codemirror.js?");

/***/ }),

/***/ "./node_modules/codemirror/mode/ruby/ruby.js":
/*!***************************************************!*\
  !*** ./node_modules/codemirror/mode/ruby/ruby.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (true) // CommonJS\n    mod(__webpack_require__(/*! ../../lib/codemirror */ \"./node_modules/codemirror/lib/codemirror.js\"));\n  else {}\n})(function(CodeMirror) {\n\"use strict\";\n\nfunction wordObj(words) {\n  var o = {};\n  for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;\n  return o;\n}\n\nvar keywordList = [\n  \"alias\", \"and\", \"BEGIN\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"defined?\", \"do\", \"else\",\n  \"elsif\", \"END\", \"end\", \"ensure\", \"false\", \"for\", \"if\", \"in\", \"module\", \"next\", \"not\", \"or\",\n  \"redo\", \"rescue\", \"retry\", \"return\", \"self\", \"super\", \"then\", \"true\", \"undef\", \"unless\",\n  \"until\", \"when\", \"while\", \"yield\", \"nil\", \"raise\", \"throw\", \"catch\", \"fail\", \"loop\", \"callcc\",\n  \"caller\", \"lambda\", \"proc\", \"public\", \"protected\", \"private\", \"require\", \"load\",\n  \"require_relative\", \"extend\", \"autoload\", \"__END__\", \"__FILE__\", \"__LINE__\", \"__dir__\"\n], keywords = wordObj(keywordList);\n\nvar indentWords = wordObj([\"def\", \"class\", \"case\", \"for\", \"while\", \"until\", \"module\", \"then\",\n                           \"catch\", \"loop\", \"proc\", \"begin\"]);\nvar dedentWords = wordObj([\"end\", \"until\"]);\nvar opening = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\"};\nvar closing = {\"]\": \"[\", \"}\": \"{\", \")\": \"(\"};\n\nCodeMirror.defineMode(\"ruby\", function(config) {\n  var curPunc;\n\n  function chain(newtok, stream, state) {\n    state.tokenize.push(newtok);\n    return newtok(stream, state);\n  }\n\n  function tokenBase(stream, state) {\n    if (stream.sol() && stream.match(\"=begin\") && stream.eol()) {\n      state.tokenize.push(readBlockComment);\n      return \"comment\";\n    }\n    if (stream.eatSpace()) return null;\n    var ch = stream.next(), m;\n    if (ch == \"`\" || ch == \"'\" || ch == '\"') {\n      return chain(readQuoted(ch, \"string\", ch == '\"' || ch == \"`\"), stream, state);\n    } else if (ch == \"/\") {\n      if (regexpAhead(stream))\n        return chain(readQuoted(ch, \"string-2\", true), stream, state);\n      else\n        return \"operator\";\n    } else if (ch == \"%\") {\n      var style = \"string\", embed = true;\n      if (stream.eat(\"s\")) style = \"atom\";\n      else if (stream.eat(/[WQ]/)) style = \"string\";\n      else if (stream.eat(/[r]/)) style = \"string-2\";\n      else if (stream.eat(/[wxq]/)) { style = \"string\"; embed = false; }\n      var delim = stream.eat(/[^\\w\\s=]/);\n      if (!delim) return \"operator\";\n      if (opening.propertyIsEnumerable(delim)) delim = opening[delim];\n      return chain(readQuoted(delim, style, embed, true), stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    } else if (ch == \"<\" && (m = stream.match(/^<([-~])[\\`\\\"\\']?([a-zA-Z_?]\\w*)[\\`\\\"\\']?(?:;|$)/))) {\n      return chain(readHereDoc(m[2], m[1]), stream, state);\n    } else if (ch == \"0\") {\n      if (stream.eat(\"x\")) stream.eatWhile(/[\\da-fA-F]/);\n      else if (stream.eat(\"b\")) stream.eatWhile(/[01]/);\n      else stream.eatWhile(/[0-7]/);\n      return \"number\";\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+\\-]?[\\d_]+)?/);\n      return \"number\";\n    } else if (ch == \"?\") {\n      while (stream.match(/^\\\\[CM]-/)) {}\n      if (stream.eat(\"\\\\\")) stream.eatWhile(/\\w/);\n      else stream.next();\n      return \"string\";\n    } else if (ch == \":\") {\n      if (stream.eat(\"'\")) return chain(readQuoted(\"'\", \"atom\", false), stream, state);\n      if (stream.eat('\"')) return chain(readQuoted('\"', \"atom\", true), stream, state);\n\n      // :> :>> :< :<< are valid symbols\n      if (stream.eat(/[\\<\\>]/)) {\n        stream.eat(/[\\<\\>]/);\n        return \"atom\";\n      }\n\n      // :+ :- :/ :* :| :& :! are valid symbols\n      if (stream.eat(/[\\+\\-\\*\\/\\&\\|\\:\\!]/)) {\n        return \"atom\";\n      }\n\n      // Symbols can't start by a digit\n      if (stream.eat(/[a-zA-Z$@_\\xa1-\\uffff]/)) {\n        stream.eatWhile(/[\\w$\\xa1-\\uffff]/);\n        // Only one ? ! = is allowed and only as the last character\n        stream.eat(/[\\?\\!\\=]/);\n        return \"atom\";\n      }\n      return \"operator\";\n    } else if (ch == \"@\" && stream.match(/^@?[a-zA-Z_\\xa1-\\uffff]/)) {\n      stream.eat(\"@\");\n      stream.eatWhile(/[\\w\\xa1-\\uffff]/);\n      return \"variable-2\";\n    } else if (ch == \"$\") {\n      if (stream.eat(/[a-zA-Z_]/)) {\n        stream.eatWhile(/[\\w]/);\n      } else if (stream.eat(/\\d/)) {\n        stream.eat(/\\d/);\n      } else {\n        stream.next(); // Must be a special global like $: or $!\n      }\n      return \"variable-3\";\n    } else if (/[a-zA-Z_\\xa1-\\uffff]/.test(ch)) {\n      stream.eatWhile(/[\\w\\xa1-\\uffff]/);\n      stream.eat(/[\\?\\!]/);\n      if (stream.eat(\":\")) return \"atom\";\n      return \"ident\";\n    } else if (ch == \"|\" && (state.varList || state.lastTok == \"{\" || state.lastTok == \"do\")) {\n      curPunc = \"|\";\n      return null;\n    } else if (/[\\(\\)\\[\\]{}\\\\;]/.test(ch)) {\n      curPunc = ch;\n      return null;\n    } else if (ch == \"-\" && stream.eat(\">\")) {\n      return \"arrow\";\n    } else if (/[=+\\-\\/*:\\.^%<>~|]/.test(ch)) {\n      var more = stream.eatWhile(/[=+\\-\\/*:\\.^%<>~|]/);\n      if (ch == \".\" && !more) curPunc = \".\";\n      return \"operator\";\n    } else {\n      return null;\n    }\n  }\n\n  function regexpAhead(stream) {\n    var start = stream.pos, depth = 0, next, found = false, escaped = false\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (\"[{(\".indexOf(next) > -1) {\n          depth++\n        } else if (\"]})\".indexOf(next) > -1) {\n          depth--\n          if (depth < 0) break\n        } else if (next == \"/\" && depth == 0) {\n          found = true\n          break\n        }\n        escaped = next == \"\\\\\"\n      } else {\n        escaped = false\n      }\n    }\n    stream.backUp(stream.pos - start)\n    return found\n  }\n\n  function tokenBaseUntilBrace(depth) {\n    if (!depth) depth = 1;\n    return function(stream, state) {\n      if (stream.peek() == \"}\") {\n        if (depth == 1) {\n          state.tokenize.pop();\n          return state.tokenize[state.tokenize.length-1](stream, state);\n        } else {\n          state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth - 1);\n        }\n      } else if (stream.peek() == \"{\") {\n        state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth + 1);\n      }\n      return tokenBase(stream, state);\n    };\n  }\n  function tokenBaseOnce() {\n    var alreadyCalled = false;\n    return function(stream, state) {\n      if (alreadyCalled) {\n        state.tokenize.pop();\n        return state.tokenize[state.tokenize.length-1](stream, state);\n      }\n      alreadyCalled = true;\n      return tokenBase(stream, state);\n    };\n  }\n  function readQuoted(quote, style, embed, unescaped) {\n    return function(stream, state) {\n      var escaped = false, ch;\n\n      if (state.context.type === 'read-quoted-paused') {\n        state.context = state.context.prev;\n        stream.eat(\"}\");\n      }\n\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && (unescaped || !escaped)) {\n          state.tokenize.pop();\n          break;\n        }\n        if (embed && ch == \"#\" && !escaped) {\n          if (stream.eat(\"{\")) {\n            if (quote == \"}\") {\n              state.context = {prev: state.context, type: 'read-quoted-paused'};\n            }\n            state.tokenize.push(tokenBaseUntilBrace());\n            break;\n          } else if (/[@\\$]/.test(stream.peek())) {\n            state.tokenize.push(tokenBaseOnce());\n            break;\n          }\n        }\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      return style;\n    };\n  }\n  function readHereDoc(phrase, mayIndent) {\n    return function(stream, state) {\n      if (mayIndent) stream.eatSpace()\n      if (stream.match(phrase)) state.tokenize.pop();\n      else stream.skipToEnd();\n      return \"string\";\n    };\n  }\n  function readBlockComment(stream, state) {\n    if (stream.sol() && stream.match(\"=end\") && stream.eol())\n      state.tokenize.pop();\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: [tokenBase],\n              indented: 0,\n              context: {type: \"top\", indented: -config.indentUnit},\n              continuedLine: false,\n              lastTok: null,\n              varList: false};\n    },\n\n    token: function(stream, state) {\n      curPunc = null;\n      if (stream.sol()) state.indented = stream.indentation();\n      var style = state.tokenize[state.tokenize.length-1](stream, state), kwtype;\n      var thisTok = curPunc;\n      if (style == \"ident\") {\n        var word = stream.current();\n        style = state.lastTok == \".\" ? \"property\"\n          : keywords.propertyIsEnumerable(stream.current()) ? \"keyword\"\n          : /^[A-Z]/.test(word) ? \"tag\"\n          : (state.lastTok == \"def\" || state.lastTok == \"class\" || state.varList) ? \"def\"\n          : \"variable\";\n        if (style == \"keyword\") {\n          thisTok = word;\n          if (indentWords.propertyIsEnumerable(word)) kwtype = \"indent\";\n          else if (dedentWords.propertyIsEnumerable(word)) kwtype = \"dedent\";\n          else if ((word == \"if\" || word == \"unless\") && stream.column() == stream.indentation())\n            kwtype = \"indent\";\n          else if (word == \"do\" && state.context.indented < state.indented)\n            kwtype = \"indent\";\n        }\n      }\n      if (curPunc || (style && style != \"comment\")) state.lastTok = thisTok;\n      if (curPunc == \"|\") state.varList = !state.varList;\n\n      if (kwtype == \"indent\" || /[\\(\\[\\{]/.test(curPunc))\n        state.context = {prev: state.context, type: curPunc || style, indented: state.indented};\n      else if ((kwtype == \"dedent\" || /[\\)\\]\\}]/.test(curPunc)) && state.context.prev)\n        state.context = state.context.prev;\n\n      if (stream.eol())\n        state.continuedLine = (curPunc == \"\\\\\" || style == \"operator\");\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize[state.tokenize.length-1] != tokenBase) return CodeMirror.Pass;\n      var firstChar = textAfter && textAfter.charAt(0);\n      var ct = state.context;\n      var closed = ct.type == closing[firstChar] ||\n        ct.type == \"keyword\" && /^(?:end|until|else|elsif|when|rescue)\\b/.test(textAfter);\n      return ct.indented + (closed ? 0 : config.indentUnit) +\n        (state.continuedLine ? config.indentUnit : 0);\n    },\n\n    electricInput: /^\\s*(?:end|rescue|elsif|else|\\})$/,\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-ruby\", \"ruby\");\n\nCodeMirror.registerHelper(\"hintWords\", \"ruby\", keywordList);\n\n});\n\n\n//# sourceURL=webpack:///./node_modules/codemirror/mode/ruby/ruby.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/lib/codemirror.css":
/*!******************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/lib/codemirror.css ***!
  \******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* BASICS */\\n\\n.CodeMirror {\\n  /* Set height, width, borders, and global font properties here */\\n  font-family: monospace;\\n  height: 300px;\\n  color: black;\\n  direction: ltr;\\n}\\n\\n/* PADDING */\\n\\n.CodeMirror-lines {\\n  padding: 4px 0; /* Vertical padding around content */\\n}\\n.CodeMirror pre.CodeMirror-line,\\n.CodeMirror pre.CodeMirror-line-like {\\n  padding: 0 4px; /* Horizontal padding of content */\\n}\\n\\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\n  background-color: transparent; /* The little square between H and V scrollbars */\\n}\\n\\n/* GUTTER */\\n\\n.CodeMirror-gutters {\\n  border-right: 1px solid #ddd;\\n  background-color: #f7f7f7;\\n  white-space: nowrap;\\n}\\n.CodeMirror-linenumbers {}\\n.CodeMirror-linenumber {\\n  padding: 0 3px 0 5px;\\n  min-width: 20px;\\n  text-align: right;\\n  color: #999;\\n  white-space: nowrap;\\n}\\n\\n.CodeMirror-guttermarker { color: black; }\\n.CodeMirror-guttermarker-subtle { color: #999; }\\n\\n/* CURSOR */\\n\\n.CodeMirror-cursor {\\n  border-left: 1px solid black;\\n  border-right: none;\\n  width: 0;\\n}\\n/* Shown when moving in bi-directional text */\\n.CodeMirror div.CodeMirror-secondarycursor {\\n  border-left: 1px solid silver;\\n}\\n.cm-fat-cursor .CodeMirror-cursor {\\n  width: auto;\\n  border: 0 !important;\\n  background: #7e7;\\n}\\n.cm-fat-cursor div.CodeMirror-cursors {\\n  z-index: 1;\\n}\\n.cm-fat-cursor-mark {\\n  background-color: rgba(20, 255, 20, 0.5);\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\n  -moz-animation: blink 1.06s steps(1) infinite;\\n  animation: blink 1.06s steps(1) infinite;\\n}\\n.cm-animate-fat-cursor {\\n  width: auto;\\n  border: 0;\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\n  -moz-animation: blink 1.06s steps(1) infinite;\\n  animation: blink 1.06s steps(1) infinite;\\n  background-color: #7e7;\\n}\\n@-moz-keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n@-webkit-keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n@keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n\\n/* Can style cursor different in overwrite (non-insert) mode */\\n.CodeMirror-overwrite .CodeMirror-cursor {}\\n\\n.cm-tab { display: inline-block; text-decoration: inherit; }\\n\\n.CodeMirror-rulers {\\n  position: absolute;\\n  left: 0; right: 0; top: -50px; bottom: 0;\\n  overflow: hidden;\\n}\\n.CodeMirror-ruler {\\n  border-left: 1px solid #ccc;\\n  top: 0; bottom: 0;\\n  position: absolute;\\n}\\n\\n/* DEFAULT THEME */\\n\\n.cm-s-default .cm-header {color: blue;}\\n.cm-s-default .cm-quote {color: #090;}\\n.cm-negative {color: #d44;}\\n.cm-positive {color: #292;}\\n.cm-header, .cm-strong {font-weight: bold;}\\n.cm-em {font-style: italic;}\\n.cm-link {text-decoration: underline;}\\n.cm-strikethrough {text-decoration: line-through;}\\n\\n.cm-s-default .cm-keyword {color: #708;}\\n.cm-s-default .cm-atom {color: #219;}\\n.cm-s-default .cm-number {color: #164;}\\n.cm-s-default .cm-def {color: #00f;}\\n.cm-s-default .cm-variable,\\n.cm-s-default .cm-punctuation,\\n.cm-s-default .cm-property,\\n.cm-s-default .cm-operator {}\\n.cm-s-default .cm-variable-2 {color: #05a;}\\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\\n.cm-s-default .cm-comment {color: #a50;}\\n.cm-s-default .cm-string {color: #a11;}\\n.cm-s-default .cm-string-2 {color: #f50;}\\n.cm-s-default .cm-meta {color: #555;}\\n.cm-s-default .cm-qualifier {color: #555;}\\n.cm-s-default .cm-builtin {color: #30a;}\\n.cm-s-default .cm-bracket {color: #997;}\\n.cm-s-default .cm-tag {color: #170;}\\n.cm-s-default .cm-attribute {color: #00c;}\\n.cm-s-default .cm-hr {color: #999;}\\n.cm-s-default .cm-link {color: #00c;}\\n\\n.cm-s-default .cm-error {color: #f00;}\\n.cm-invalidchar {color: #f00;}\\n\\n.CodeMirror-composing { border-bottom: 2px solid; }\\n\\n/* Default styles for common addons */\\n\\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\\n.CodeMirror-activeline-background {background: #e8f2ff;}\\n\\n/* STOP */\\n\\n/* The rest of this file contains styles related to the mechanics of\\n   the editor. You probably shouldn't touch them. */\\n\\n.CodeMirror {\\n  position: relative;\\n  overflow: hidden;\\n  background: white;\\n}\\n\\n.CodeMirror-scroll {\\n  overflow: scroll !important; /* Things will break if this is overridden */\\n  /* 50px is the magic margin used to hide the element's real scrollbars */\\n  /* See overflow: hidden in .CodeMirror */\\n  margin-bottom: -50px; margin-right: -50px;\\n  padding-bottom: 50px;\\n  height: 100%;\\n  outline: none; /* Prevent dragging from highlighting the element */\\n  position: relative;\\n}\\n.CodeMirror-sizer {\\n  position: relative;\\n  border-right: 50px solid transparent;\\n}\\n\\n/* The fake, visible scrollbars. Used to force redraw during scrolling\\n   before actual scrolling happens, thus preventing shaking and\\n   flickering artifacts. */\\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\n  position: absolute;\\n  z-index: 6;\\n  display: none;\\n  outline: none;\\n}\\n.CodeMirror-vscrollbar {\\n  right: 0; top: 0;\\n  overflow-x: hidden;\\n  overflow-y: scroll;\\n}\\n.CodeMirror-hscrollbar {\\n  bottom: 0; left: 0;\\n  overflow-y: hidden;\\n  overflow-x: scroll;\\n}\\n.CodeMirror-scrollbar-filler {\\n  right: 0; bottom: 0;\\n}\\n.CodeMirror-gutter-filler {\\n  left: 0; bottom: 0;\\n}\\n\\n.CodeMirror-gutters {\\n  position: absolute; left: 0; top: 0;\\n  min-height: 100%;\\n  z-index: 3;\\n}\\n.CodeMirror-gutter {\\n  white-space: normal;\\n  height: 100%;\\n  display: inline-block;\\n  vertical-align: top;\\n  margin-bottom: -50px;\\n}\\n.CodeMirror-gutter-wrapper {\\n  position: absolute;\\n  z-index: 4;\\n  background: none !important;\\n  border: none !important;\\n}\\n.CodeMirror-gutter-background {\\n  position: absolute;\\n  top: 0; bottom: 0;\\n  z-index: 4;\\n}\\n.CodeMirror-gutter-elt {\\n  position: absolute;\\n  cursor: default;\\n  z-index: 4;\\n}\\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\\n\\n.CodeMirror-lines {\\n  cursor: text;\\n  min-height: 1px; /* prevents collapsing before first draw */\\n}\\n.CodeMirror pre.CodeMirror-line,\\n.CodeMirror pre.CodeMirror-line-like {\\n  /* Reset some styles that the rest of the page might have set */\\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\\n  border-width: 0;\\n  background: transparent;\\n  font-family: inherit;\\n  font-size: inherit;\\n  margin: 0;\\n  white-space: pre;\\n  word-wrap: normal;\\n  line-height: inherit;\\n  color: inherit;\\n  z-index: 2;\\n  position: relative;\\n  overflow: visible;\\n  -webkit-tap-highlight-color: transparent;\\n  -webkit-font-variant-ligatures: contextual;\\n  font-variant-ligatures: contextual;\\n}\\n.CodeMirror-wrap pre.CodeMirror-line,\\n.CodeMirror-wrap pre.CodeMirror-line-like {\\n  word-wrap: break-word;\\n  white-space: pre-wrap;\\n  word-break: normal;\\n}\\n\\n.CodeMirror-linebackground {\\n  position: absolute;\\n  left: 0; right: 0; top: 0; bottom: 0;\\n  z-index: 0;\\n}\\n\\n.CodeMirror-linewidget {\\n  position: relative;\\n  z-index: 2;\\n  padding: 0.1px; /* Force widget margins to stay inside of the container */\\n}\\n\\n.CodeMirror-widget {}\\n\\n.CodeMirror-rtl pre { direction: rtl; }\\n\\n.CodeMirror-code {\\n  outline: none;\\n}\\n\\n/* Force content-box sizing for the elements where we expect it */\\n.CodeMirror-scroll,\\n.CodeMirror-sizer,\\n.CodeMirror-gutter,\\n.CodeMirror-gutters,\\n.CodeMirror-linenumber {\\n  -moz-box-sizing: content-box;\\n  box-sizing: content-box;\\n}\\n\\n.CodeMirror-measure {\\n  position: absolute;\\n  width: 100%;\\n  height: 0;\\n  overflow: hidden;\\n  visibility: hidden;\\n}\\n\\n.CodeMirror-cursor {\\n  position: absolute;\\n  pointer-events: none;\\n}\\n.CodeMirror-measure pre { position: static; }\\n\\ndiv.CodeMirror-cursors {\\n  visibility: hidden;\\n  position: relative;\\n  z-index: 3;\\n}\\ndiv.CodeMirror-dragcursors {\\n  visibility: visible;\\n}\\n\\n.CodeMirror-focused div.CodeMirror-cursors {\\n  visibility: visible;\\n}\\n\\n.CodeMirror-selected { background: #d9d9d9; }\\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\\n.CodeMirror-crosshair { cursor: crosshair; }\\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }\\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\\n\\n.cm-searching {\\n  background-color: #ffa;\\n  background-color: rgba(255, 255, 0, .4);\\n}\\n\\n/* Used to force a border model for a node */\\n.cm-force-border { padding-right: .1px; }\\n\\n@media print {\\n  /* Hide the cursor when printing */\\n  .CodeMirror div.CodeMirror-cursors {\\n    visibility: hidden;\\n  }\\n}\\n\\n/* See issue #2901 */\\n.cm-tab-wrap-hack:after { content: ''; }\\n\\n/* Help users use markselection to safely style text background */\\nspan.CodeMirror-selectedtext { background: none; }\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./node_modules/codemirror/lib/codemirror.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/theme/hopscotch.css":
/*!*******************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/theme/hopscotch.css ***!
  \*******************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\n\\n    Name:       Hopscotch\\n    Author:     Jan T. Sott\\n\\n    CodeMirror template by Jan T. Sott (https://github.com/idleberg/base16-codemirror)\\n    Original Base16 color scheme by Chris Kempson (https://github.com/chriskempson/base16)\\n\\n*/\\n\\n.cm-s-hopscotch.CodeMirror {background: #322931; color: #d5d3d5;}\\n.cm-s-hopscotch div.CodeMirror-selected {background: #433b42 !important;}\\n.cm-s-hopscotch .CodeMirror-gutters {background: #322931; border-right: 0px;}\\n.cm-s-hopscotch .CodeMirror-linenumber {color: #797379;}\\n.cm-s-hopscotch .CodeMirror-cursor {border-left: 1px solid #989498 !important;}\\n\\n.cm-s-hopscotch span.cm-comment {color: #b33508;}\\n.cm-s-hopscotch span.cm-atom {color: #c85e7c;}\\n.cm-s-hopscotch span.cm-number {color: #c85e7c;}\\n\\n.cm-s-hopscotch span.cm-property, .cm-s-hopscotch span.cm-attribute {color: #8fc13e;}\\n.cm-s-hopscotch span.cm-keyword {color: #dd464c;}\\n.cm-s-hopscotch span.cm-string {color: #fdcc59;}\\n\\n.cm-s-hopscotch span.cm-variable {color: #8fc13e;}\\n.cm-s-hopscotch span.cm-variable-2 {color: #1290bf;}\\n.cm-s-hopscotch span.cm-def {color: #fd8b19;}\\n.cm-s-hopscotch span.cm-error {background: #dd464c; color: #989498;}\\n.cm-s-hopscotch span.cm-bracket {color: #d5d3d5;}\\n.cm-s-hopscotch span.cm-tag {color: #dd464c;}\\n.cm-s-hopscotch span.cm-link {color: #c85e7c;}\\n\\n.cm-s-hopscotch .CodeMirror-matchingbracket { text-decoration: underline; color: white !important;}\\n.cm-s-hopscotch .CodeMirror-activeline-background { background: #302020; }\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack:///./node_modules/codemirror/theme/hopscotch.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/@fortawesome/fontawesome-free/webfonts/fa-brands-400.woff2":
/*!*********************************************************************************!*\
  !*** ./node_modules/@fortawesome/fontawesome-free/webfonts/fa-brands-400.woff2 ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + \"../fonts/fa-brands-400.woff2\");\n\n//# sourceURL=webpack:///./node_modules/@fortawesome/fontawesome-free/webfonts/fa-brands-400.woff2?");

/***/ }),

/***/ "./node_modules/codemirror/lib/codemirror.css":
/*!****************************************************!*\
  !*** ./node_modules/codemirror/lib/codemirror.css ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_cjs_js_codemirror_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js!./codemirror.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/lib/codemirror.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_codemirror_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_codemirror_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});\n\n//# sourceURL=webpack:///./node_modules/codemirror/lib/codemirror.css?");

/***/ }),

/***/ "./node_modules/codemirror/theme/hopscotch.css":
/*!*****************************************************!*\
  !*** ./node_modules/codemirror/theme/hopscotch.css ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_cjs_js_hopscotch_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js!./hopscotch.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/codemirror/theme/hopscotch.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_hopscotch_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_hopscotch_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});\n\n//# sourceURL=webpack:///./node_modules/codemirror/theme/hopscotch.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/unpoly/dist/unpoly.js":
/*!********************************************!*\
  !*** ./node_modules/unpoly/dist/unpoly.js ***!
  \********************************************/
/***/ (function() {

eval("\n/***\n@module up\n */\n\n(function() {\n  window.up = {\n    version: \"0.62.1\"\n  };\n\n}).call(this);\n\n/***\nUtility functions\n=================\n\nThe `up.util` module contains functions to facilitate the work with basic JavaScript\nvalues like lists, strings or functions.\n\nYou will recognize many functions form other utility libraries like [Lodash](https://lodash.com/).\nWhile feature parity with Lodash is not a goal of `up.util`, you might find it sufficient\nto not include another library in your asset bundle.\n\n@module up.util\n */\n\n(function() {\n  var slice = [].slice,\n    hasProp = {}.hasOwnProperty;\n\n  up.util = (function() {\n\n    /***\n    A function that does nothing.\n    \n    @function up.util.noop\n    @experimental\n     */\n    var ESCAPE_HTML_ENTITY_MAP, always, arrayToSet, assign, assignPolyfill, asyncNoop, compact, contains, copy, deepCopy, each, eachIterator, endsWith, escapeHtml, escapePressed, escapeRegexp, evalOption, every, except, extractCallback, extractLastArg, extractOptions, fail, filterList, findInList, findResult, flatMap, flatten, horizontalScreenHalf, identity, intersect, isArguments, isArray, isBasicObjectProperty, isBlank, isBoolean, isCrossDomain, isDefined, isElement, isEqual, isEqualList, isFormData, isFunction, isGiven, isHTMLCollection, isJQuery, isList, isMissing, isNodeList, isNull, isNumber, isObject, isOptions, isPresent, isPromise, isStandardPort, isString, isTruthy, isUndefined, isUnmodifiedKeyEvent, isUnmodifiedMouseEvent, iteratee, last, map, mapObject, memoize, merge, methodAllowsPayload, muteRejection, newDeferred, newOptions, nextUid, noop, normalizeMethod, normalizeUrl, objectValues, only, parseUrl, partial, pluckKey, presence, previewable, queueMicrotask, queueTask, reject, rejectOnError, remove, renameKey, scheduleTimer, sequence, setToArray, simpleEase, some, splitValues, sum, times, toArray, uid, uniq, uniqBy, unresolvablePromise, valuesPolyfill, wrapList, wrapValue;\n    noop = (function() {});\n\n    /***\n    A function that returns a resolved promise.\n    \n    @function up.util.asyncNoop\n    @internal\n     */\n    asyncNoop = function() {\n      return Promise.resolve();\n    };\n\n    /***\n    Ensures that the given function can only be called a single time.\n    Subsequent calls will return the return value of the first call.\n    \n    Note that this is a simple implementation that\n    doesn't distinguish between argument lists.\n    \n    @function up.util.memoize\n    @internal\n     */\n    memoize = function(func) {\n      var cached, cachedValue;\n      cachedValue = void 0;\n      cached = false;\n      return function() {\n        var args;\n        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        if (cached) {\n          return cachedValue;\n        } else {\n          cached = true;\n          return cachedValue = func.apply(null, args);\n        }\n      };\n    };\n\n    /***\n    Returns if the given port is the default port for the given protocol.\n    \n    @function up.util.isStandardPort\n    @internal\n     */\n    isStandardPort = function(protocol, port) {\n      port = port.toString();\n      return ((port === \"\" || port === \"80\") && protocol === 'http:') || (port === \"443\" && protocol === 'https:');\n    };\n\n    /***\n    Normalizes relative paths and absolute paths to a full URL\n    that can be checked for equality with other normalized URLs.\n    \n    By default hashes are ignored, search queries are included.\n    \n    @function up.util.normalizeUrl\n    @param {boolean} [options.hash=false]\n      Whether to include an `#hash` anchor in the normalized URL\n    @param {boolean} [options.search=true]\n      Whether to include a `?query` string in the normalized URL\n    @param {boolean} [options.stripTrailingSlash=false]\n      Whether to strip a trailing slash from the pathname\n    @internal\n     */\n    normalizeUrl = function(urlOrAnchor, options) {\n      var normalized, parts, pathname;\n      parts = parseUrl(urlOrAnchor);\n      normalized = parts.protocol + \"//\" + parts.hostname;\n      if (!isStandardPort(parts.protocol, parts.port)) {\n        normalized += \":\" + parts.port;\n      }\n      pathname = parts.pathname;\n      if ((options != null ? options.stripTrailingSlash : void 0) === true) {\n        pathname = pathname.replace(/\\/$/, '');\n      }\n      normalized += pathname;\n      if ((options != null ? options.search : void 0) !== false) {\n        normalized += parts.search;\n      }\n      if ((options != null ? options.hash : void 0) === true) {\n        normalized += parts.hash;\n      }\n      return normalized;\n    };\n    isCrossDomain = function(targetUrl) {\n      var currentUrl;\n      currentUrl = parseUrl(location.href);\n      targetUrl = parseUrl(targetUrl);\n      return currentUrl.protocol !== targetUrl.protocol || currentUrl.hostname !== targetUrl.hostname;\n    };\n\n    /***\n    Parses the given URL into components such as hostname and path.\n    \n    If the given URL is not fully qualified, it is assumed to be relative\n    to the current page.\n    \n    @function up.util.parseUrl\n    @return {Object}\n      The parsed URL as an object with\n      `protocol`, `hostname`, `port`, `pathname`, `search` and `hash`\n      properties.\n    @stable\n     */\n    parseUrl = function(urlOrLink) {\n      var link;\n      if (isJQuery(urlOrLink)) {\n        link = up.element.get(urlOrLink);\n      } else if (urlOrLink.pathname) {\n        link = urlOrLink;\n      } else {\n        link = document.createElement('a');\n        link.href = urlOrLink;\n      }\n      if (!link.hostname) {\n        link.href = link.href;\n      }\n      if (link.pathname[0] !== '/') {\n        link = only(link, 'protocol', 'hostname', 'port', 'pathname', 'search', 'hash');\n        link.pathname = '/' + link.pathname;\n      }\n      return link;\n    };\n\n    /***\n    @function up.util.normalizeMethod\n    @internal\n     */\n    normalizeMethod = function(method) {\n      if (method) {\n        return method.toUpperCase();\n      } else {\n        return 'GET';\n      }\n    };\n\n    /***\n    @function up.util.methodAllowsPayload\n    @internal\n     */\n    methodAllowsPayload = function(method) {\n      return method !== 'GET' && method !== 'HEAD';\n    };\n    assignPolyfill = function() {\n      var i, key, len, source, sources, target, value;\n      target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      for (i = 0, len = sources.length; i < len; i++) {\n        source = sources[i];\n        for (key in source) {\n          if (!hasProp.call(source, key)) continue;\n          value = source[key];\n          target[key] = value;\n        }\n      }\n      return target;\n    };\n\n    /***\n    Merge the own properties of one or more `sources` into the `target` object.\n    \n    @function up.util.assign\n    @param {Object} target\n    @param {Array<Object>} sources...\n    @stable\n     */\n    assign = Object.assign || assignPolyfill;\n    valuesPolyfill = function(object) {\n      var key, results, value;\n      results = [];\n      for (key in object) {\n        value = object[key];\n        results.push(value);\n      }\n      return results;\n    };\n\n    /***\n    Returns an array of values of the given object.\n    \n    @function up.util.values\n    @param {Object} object\n    @return {Array<string>}\n    @stable\n     */\n    objectValues = Object.values || valuesPolyfill;\n    iteratee = function(block) {\n      if (isString(block)) {\n        return function(item) {\n          return item[block];\n        };\n      } else {\n        return block;\n      }\n    };\n\n    /***\n    Translate all items in an array to new array of items.\n    \n    @function up.util.map\n    @param {Array} array\n    @param {Function(element, index): any|String} block\n      A function that will be called with each element and (optional) iteration index.\n    \n      You can also pass a property name as a String,\n      which will be collected from each item in the array.\n    @return {Array}\n      A new array containing the result of each function call.\n    @stable\n     */\n    map = function(array, block) {\n      var i, index, item, len, results;\n      if (array.length === 0) {\n        return [];\n      }\n      block = iteratee(block);\n      results = [];\n      for (index = i = 0, len = array.length; i < len; index = ++i) {\n        item = array[index];\n        results.push(block(item, index));\n      }\n      return results;\n    };\n\n    /***\n    @function up.util.mapObject\n    @internal\n     */\n    mapObject = function(array, pairer) {\n      var merger;\n      merger = function(object, pair) {\n        object[pair[0]] = pair[1];\n        return object;\n      };\n      return map(array, pairer).reduce(merger, {});\n    };\n\n    /***\n    Calls the given function for each element (and, optional, index)\n    of the given array.\n    \n    @function up.util.each\n    @param {Array} array\n    @param {Function(element, index)} block\n      A function that will be called with each element and (optional) iteration index.\n    @stable\n     */\n    each = map;\n    eachIterator = function(iterator, callback) {\n      var entry, results;\n      results = [];\n      while ((entry = iterator.next()) && !entry.done) {\n        results.push(callback(entry.value));\n      }\n      return results;\n    };\n\n    /***\n    Calls the given function for the given number of times.\n    \n    @function up.util.times\n    @param {number} count\n    @param {Function()} block\n    @stable\n     */\n    times = function(count, block) {\n      var i, iteration, ref, results;\n      results = [];\n      for (iteration = i = 0, ref = count - 1; 0 <= ref ? i <= ref : i >= ref; iteration = 0 <= ref ? ++i : --i) {\n        results.push(block(iteration));\n      }\n      return results;\n    };\n\n    /***\n    Returns whether the given argument is `null`.\n    \n    @function up.util.isNull\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isNull = function(object) {\n      return object === null;\n    };\n\n    /***\n    Returns whether the given argument is `undefined`.\n    \n    @function up.util.isUndefined\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isUndefined = function(object) {\n      return object === void 0;\n    };\n\n    /***\n    Returns whether the given argument is not `undefined`.\n    \n    @function up.util.isDefined\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isDefined = function(object) {\n      return !isUndefined(object);\n    };\n\n    /***\n    Returns whether the given argument is either `undefined` or `null`.\n    \n    Note that empty strings or zero are *not* considered to be \"missing\".\n    \n    For the opposite of `up.util.isMissing()` see [`up.util.isGiven()`](/up.util.isGiven).\n    \n    @function up.util.isMissing\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isMissing = function(object) {\n      return isUndefined(object) || isNull(object);\n    };\n\n    /***\n    Returns whether the given argument is neither `undefined` nor `null`.\n    \n    Note that empty strings or zero *are* considered to be \"given\".\n    \n    For the opposite of `up.util.isGiven()` see [`up.util.isMissing()`](/up.util.isMissing).\n    \n    @function up.util.isGiven\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isGiven = function(object) {\n      return !isMissing(object);\n    };\n\n    /***\n    Return whether the given argument is considered to be blank.\n    \n    By default, this function returns `true` for:\n    \n    - `undefined`\n    - `null`\n    - Empty strings\n    - Empty arrays\n    - A plain object without own enumerable properties\n    \n    All other arguments return `false`.\n    \n    To check implement blank-ness checks for user-defined classes,\n    see `up.util.isBlank.key`.\n    \n    @function up.util.isBlank\n    @param value\n      The value is to check.\n    @return {boolean}\n      Whether the value is blank.\n    @stable\n     */\n    isBlank = function(value) {\n      if (isMissing(value)) {\n        return true;\n      }\n      if (isObject(value) && value[isBlank.key]) {\n        return value[isBlank.key]();\n      }\n      if (isString(value) || isList(value)) {\n        return value.length === 0;\n      }\n      if (isOptions(value)) {\n        return Object.keys(value).length === 0;\n      }\n      return false;\n    };\n\n    /***\n    This property contains the name of a method that user-defined classes\n    may implement to hook into the `up.util.isBlank()` protocol.\n    \n    \\#\\#\\# Example\n    \n    We have a user-defined `Account` class that we want to use with `up.util.isBlank()`:\n    \n    ```\n    class Account {\n      constructor(email) {\n        this.email = email\n      }\n    \n      [up.util.isBlank.key]() {\n        return up.util.isBlank(this.email)\n      }\n    }\n    ```\n    \n    Note that the protocol method is not actually named `'up.util.isBlank.key'`.\n    Instead it is named after the *value* of the `up.util.isBlank.key` property.\n    To do so, the code sample above is using a\n    [computed property name](https://medium.com/front-end-weekly/javascript-object-creation-356e504173a8)\n    in square brackets.\n    \n    We may now use `Account` instances with `up.util.isBlank()`:\n    \n    ```\n    foo = new Account('foo@foo.com')\n    bar = new Account('')\n    \n    console.log(up.util.isBlank(foo)) // prints false\n    console.log(up.util.isBlank(bar)) // prints true\n    ```\n    \n    @property up.util.isBlank.key\n    @experimental\n     */\n    isBlank.key = 'up.util.isBlank';\n\n    /***\n    Returns the given argument if the argument is [present](/up.util.isPresent),\n    otherwise returns `undefined`.\n    \n    @function up.util.presence\n    @param value\n    @param {Function(value): boolean} [tester=up.util.isPresent]\n      The function that will be used to test whether the argument is present.\n    @return {any|undefined}\n    @stable\n     */\n    presence = function(value, tester) {\n      if (tester == null) {\n        tester = isPresent;\n      }\n      if (tester(value)) {\n        return value;\n      } else {\n        return void 0;\n      }\n    };\n\n    /***\n    Returns whether the given argument is not [blank](/up.util.isBlank).\n    \n    @function up.util.isPresent\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isPresent = function(object) {\n      return !isBlank(object);\n    };\n\n    /***\n    Returns whether the given argument is a function.\n    \n    @function up.util.isFunction\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isFunction = function(object) {\n      return typeof object === 'function';\n    };\n\n    /***\n    Returns whether the given argument is a string.\n    \n    @function up.util.isString\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isString = function(object) {\n      return typeof object === 'string' || object instanceof String;\n    };\n\n    /***\n    Returns whether the given argument is a boolean value.\n    \n    @function up.util.isBoolean\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isBoolean = function(object) {\n      return typeof object === 'boolean' || object instanceof Boolean;\n    };\n\n    /***\n    Returns whether the given argument is a number.\n    \n    Note that this will check the argument's *type*.\n    It will return `false` for a string like `\"123\"`.\n    \n    @function up.util.isNumber\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isNumber = function(object) {\n      return typeof object === 'number' || object instanceof Number;\n    };\n\n    /***\n    Returns whether the given argument is an options hash,\n    \n    Differently from [`up.util.isObject()`], this returns false for\n    functions, jQuery collections, promises, `FormData` instances and arrays.\n    \n    @function up.util.isOptions\n    @param object\n    @return {boolean}\n    @internal\n     */\n    isOptions = function(object) {\n      return typeof object === 'object' && !isNull(object) && (isUndefined(object.constructor) || object.constructor === Object);\n    };\n\n    /***\n    Returns whether the given argument is an object.\n    \n    This also returns `true` for functions, which may behave like objects in JavaScript.\n    \n    @function up.util.isObject\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isObject = function(object) {\n      var typeOfResult;\n      typeOfResult = typeof object;\n      return (typeOfResult === 'object' && !isNull(object)) || typeOfResult === 'function';\n    };\n\n    /***\n    Returns whether the given argument is a [DOM element](https://developer.mozilla.org/de/docs/Web/API/Element).\n    \n    @function up.util.isElement\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isElement = function(object) {\n      return object instanceof Element;\n    };\n\n    /***\n    Returns whether the given argument is a [jQuery collection](https://learn.jquery.com/using-jquery-core/jquery-object/).\n    \n    @function up.util.isJQuery\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isJQuery = function(object) {\n      return !!(object != null ? object.jquery : void 0);\n    };\n\n    /***\n    Returns whether the given argument is an object with a `then` method.\n    \n    @function up.util.isPromise\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isPromise = function(object) {\n      return isObject(object) && isFunction(object.then);\n    };\n\n    /***\n    Returns whether the given argument is an array.\n    \n    @function up.util.isArray\n    @param object\n    @return {boolean}\n    @stable\n     */\n    isArray = Array.isArray;\n\n    /***\n    Returns whether the given argument is a `FormData` instance.\n    \n    Always returns `false` in browsers that don't support `FormData`.\n    \n    @function up.util.isFormData\n    @param object\n    @return {boolean}\n    @internal\n     */\n    isFormData = function(object) {\n      return object instanceof FormData;\n    };\n\n    /***\n    Converts the given [array-like value](/up.util.isList) into an array.\n    \n    If the given value is already an array, it is returned unchanged.\n    \n    @function up.util.toArray\n    @param object\n    @return {Array}\n    @stable\n     */\n    toArray = function(value) {\n      if (isArray(value)) {\n        return value;\n      } else {\n        return Array.prototype.slice.call(value);\n      }\n    };\n\n    /****\n    Returns whether the given argument is an array-like value.\n    \n    Return true for `Array`, a\n    [`NodeList`](https://developer.mozilla.org/en-US/docs/Web/API/NodeList),\n     the [arguments object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)\n     or a jQuery collection.\n    \n    Use [`up.util.isArray()`](/up.util.isArray) to test whether a value is an actual `Array`.\n    \n    @function up.util.isList\n    @param value\n    @return {Boolean}\n    @experimental\n     */\n    isList = function(value) {\n      return isArray(value) || isNodeList(value) || isArguments(value) || isJQuery(value) || isHTMLCollection(value);\n    };\n\n    /***\n    Returns whether the given value is a [`NodeList`](https://developer.mozilla.org/en-US/docs/Web/API/NodeList).\n    \n    `NodeLists` are array-like objects returned by [`document.querySelectorAll()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll).\n    \n    @function up.util.isNodeList\n    @param value\n    @return {Boolean}\n    @internal\n     */\n    isNodeList = function(value) {\n      return value instanceof NodeList;\n    };\n    isHTMLCollection = function(value) {\n      return value instanceof HTMLCollection;\n    };\n\n    /***\n    Returns whether the given value is an [arguments object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments).\n    \n    @function up.util.isArguments\n    @param value\n    @return {Boolean}\n    @internal\n     */\n    isArguments = function(value) {\n      return Object.prototype.toString.call(value) === '[object Arguments]';\n    };\n\n    /***\n    @function up.util.wrapList\n    @return {Array|NodeList|jQuery}\n    @internal\n     */\n    wrapList = function(value) {\n      if (isList(value)) {\n        return value;\n      } else if (isMissing(value)) {\n        return [];\n      } else {\n        return [value];\n      }\n    };\n\n    /***\n    Returns a shallow copy of the given value.\n    \n    \\#\\#\\# Copying protocol\n    \n    - By default `up.util.copy()` can copy [array-like values](/up.util.isList),\n      plain objects and `Date` instances.\n    - Array-like objects are copied into new arrays.\n    - Unsupported types of values are returned unchanged.\n    - To make the copying protocol work with user-defined class,\n      see `up.util.copy.key`.\n    - Immutable objects, like strings or numbers, do not need to be copied.\n    \n    @function up.util.copy\n    @param {any} object\n    @return {any}\n    @stable\n     */\n    copy = function(value, deep) {\n      var copied, k, v;\n      if (isObject(value) && value[copy.key]) {\n        value = value[copy.key]();\n      } else if (isList(value)) {\n        value = Array.prototype.slice.call(value);\n        copied = true;\n      } else if (isOptions(value)) {\n        value = assign({}, value);\n        copied = true;\n      }\n      if (copied && deep) {\n        for (k in value) {\n          v = value[k];\n          value[k] = copy(v, true);\n        }\n      }\n      return value;\n    };\n\n    /***\n    This property contains the name of a method that user-defined classes\n    may implement to hook into the `up.util.copy()` protocol.\n    \n    \\#\\#\\# Example\n    \n    We have a user-defined `Account` class that we want to use with `up.util.copy()`:\n    \n    ```\n    class Account {\n      constructor(email) {\n        this.email = email\n      }\n    \n      [up.util.copy.key]() {\n        return new Account(this.email)\n      }\n    }\n    ```\n    \n    Note that the protocol method is not actually named `'up.util.copy.key'`.\n    Instead it is named after the *value* of the `up.util.copy.key` property.\n    To do so, the code sample above is using a\n    [computed property name](https://medium.com/front-end-weekly/javascript-object-creation-356e504173a8)\n    in square brackets.\n    \n    We may now use `Account` instances with `up.util.copy()`:\n    \n    ```\n    original = new User('foo@foo.com')\n    \n    copy = up.util.copy(original)\n    console.log(copy.email) // prints 'foo@foo.com'\n    \n    original.email = 'bar@bar.com' // change the original\n    console.log(copy.email) // still prints 'foo@foo.com'\n    ```\n    \n    @property up.util.copy.key\n    @param {string} key\n    @experimental\n     */\n    copy.key = 'up.util.copy';\n    Date.prototype[copy.key] = function() {\n      return new Date(+this);\n    };\n\n    /***\n    Returns a deep copy of the given array or object.\n    \n    @function up.util.deepCopy\n    @param {Object|Array} object\n    @return {Object|Array}\n    @internal\n     */\n    deepCopy = function(object) {\n      return copy(object, true);\n    };\n\n    /***\n    Creates a new object by merging together the properties from the given objects.\n    \n    @function up.util.merge\n    @param {Array<Object>} sources...\n    @return Object\n    @stable\n     */\n    merge = function() {\n      var sources;\n      sources = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return assign.apply(null, [{}].concat(slice.call(sources)));\n    };\n\n    /***\n    Creates an options hash from the given argument and some defaults.\n    \n    The semantics of this function are confusing.\n    We want to get rid of this in the future.\n    \n    @function up.util.options\n    @param {Object} object\n    @param {Object} [defaults]\n    @return {Object}\n    @internal\n     */\n    newOptions = function(object, defaults) {\n      if (defaults) {\n        return merge(defaults, object);\n      } else if (object) {\n        return copy(object);\n      } else {\n        return {};\n      }\n    };\n\n    /***\n    Passes each element in the given [array-like value](/up.util.isList) to the given function.\n    Returns the first element for which the function returns a truthy value.\n    \n    If no object matches, returns `undefined`.\n    \n    @function up.util.find\n    @param {List<T>} list\n    @param {Function(value): boolean} tester\n    @return {T|undefined}\n    @stable\n     */\n    findInList = function(list, tester) {\n      var element, i, len, match;\n      match = void 0;\n      for (i = 0, len = list.length; i < len; i++) {\n        element = list[i];\n        if (tester(element)) {\n          match = element;\n          break;\n        }\n      }\n      return match;\n    };\n\n    /***\n    Returns whether the given function returns a truthy value\n    for any element in the given [array-like value](/up.util.isList).\n    \n    @function up.util.some\n    @param {List} list\n    @param {Function(value, index): boolean} tester\n      A function that will be called with each element and (optional) iteration index.\n    \n    @return {boolean}\n    @stable\n     */\n    some = function(list, tester) {\n      return !!findResult(list, tester);\n    };\n\n    /***\n    Consecutively calls the given function which each element\n    in the given array. Returns the first truthy return value.\n    \n    Returned `undefined` iff the function does not return a truthy\n    value for any element in the array.\n    \n    @function up.util.findResult\n    @param {Array} array\n    @param {Function(element): any} tester\n      A function that will be called with each element and (optional) iteration index.\n    \n    @return {any|undefined}\n    @experimental\n     */\n    findResult = function(array, tester) {\n      var element, i, index, len, result;\n      tester = iteratee(tester);\n      for (index = i = 0, len = array.length; i < len; index = ++i) {\n        element = array[index];\n        if (result = tester(element, index)) {\n          return result;\n        }\n      }\n      return void 0;\n    };\n\n    /***\n    Returns whether the given function returns a truthy value\n    for all elements in the given [array-like value](/up.util.isList).\n    \n    @function up.util.every\n    @param {List} list\n    @param {Function(element, index): boolean} tester\n      A function that will be called with each element and (optional) iteration index.\n    \n    @return {boolean}\n    @experimental\n     */\n    every = function(list, tester) {\n      var element, i, index, len, match;\n      tester = iteratee(tester);\n      match = true;\n      for (index = i = 0, len = list.length; i < len; index = ++i) {\n        element = list[index];\n        if (!tester(element, index)) {\n          match = false;\n          break;\n        }\n      }\n      return match;\n    };\n\n    /***\n    Returns all elements from the given array that are\n    neither `null` or `undefined`.\n    \n    @function up.util.compact\n    @param {Array<T>} array\n    @return {Array<T>}\n    @stable\n     */\n    compact = function(array) {\n      return filterList(array, isGiven);\n    };\n\n    /***\n    Returns the given array without duplicates.\n    \n    @function up.util.uniq\n    @param {Array<T>} array\n    @return {Array<T>}\n    @stable\n     */\n    uniq = function(array) {\n      if (array.length < 2) {\n        return array;\n      }\n      return setToArray(arrayToSet(array));\n    };\n\n    /***\n    This function is like [`uniq`](/up.util.uniq), accept that\n    the given function is invoked for each element to generate the value\n    for which uniquness is computed.\n    \n    @function up.util.uniqBy\n    @param {Array} array\n    @param {Function(value): any} array\n    @return {Array}\n    @experimental\n     */\n    uniqBy = function(array, mapper) {\n      var set;\n      if (array.length < 2) {\n        return array;\n      }\n      mapper = iteratee(mapper);\n      set = new Set();\n      return filterList(array, function(elem, index) {\n        var mapped;\n        mapped = mapper(elem, index);\n        if (set.has(mapped)) {\n          return false;\n        } else {\n          set.add(mapped);\n          return true;\n        }\n      });\n    };\n\n    /***\n    @function up.util.setToArray\n    @internal\n     */\n    setToArray = function(set) {\n      var array;\n      array = [];\n      set.forEach(function(elem) {\n        return array.push(elem);\n      });\n      return array;\n    };\n\n    /***\n    @function up.util.arrayToSet\n    @internal\n     */\n    arrayToSet = function(array) {\n      var set;\n      set = new Set();\n      array.forEach(function(elem) {\n        return set.add(elem);\n      });\n      return set;\n    };\n\n    /***\n    Returns all elements from the given [array-like value](/up.util.isList) that return\n    a truthy value when passed to the given function.\n    \n    @function up.util.filter\n    @param {List} list\n    @param {Function(value, index): boolean} tester\n    @return {Array}\n    @stable\n     */\n    filterList = function(list, tester) {\n      var matches;\n      tester = iteratee(tester);\n      matches = [];\n      each(list, function(element, index) {\n        if (tester(element, index)) {\n          return matches.push(element);\n        }\n      });\n      return matches;\n    };\n\n    /***\n    Returns all elements from the given [array-like value](/up.util.isList) that do not return\n    a truthy value when passed to the given function.\n    \n    @function up.util.reject\n    @param {List} list\n    @param {Function(element, index): boolean} tester\n    @return {Array}\n    @stable\n     */\n    reject = function(list, tester) {\n      tester = iteratee(tester);\n      return filterList(list, function(element, index) {\n        return !tester(element, index);\n      });\n    };\n\n    /***\n    Returns the intersection of the given two arrays.\n    \n    Implementation is not optimized. Don't use it for large arrays.\n    \n    @function up.util.intersect\n    @internal\n     */\n    intersect = function(array1, array2) {\n      return filterList(array1, function(element) {\n        return contains(array2, element);\n      });\n    };\n\n    /***\n    Waits for the given number of milliseconds, the runs the given callback.\n    \n    Instead of `up.util.timer(0, fn)` you can also use [`up.util.task(fn)`](/up.util.task).\n    \n    @function up.util.timer\n    @param {number} millis\n    @param {Function()} callback\n    @stable\n     */\n    scheduleTimer = function(millis, callback) {\n      return setTimeout(callback, millis);\n    };\n\n    /***\n    Pushes the given function to the [JavaScript task queue](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/) (also \"macrotask queue\").\n    \n    Equivalent to calling `setTimeout(fn, 0)`.\n    \n    Also see `up.util.microtask()`.\n    \n    @function up.util.task\n    @param {Function()} block\n    @stable\n     */\n    queueTask = function(block) {\n      return setTimeout(block, 0);\n    };\n\n    /***\n    Pushes the given function to the [JavaScript microtask queue](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/).\n    \n    @function up.util.microtask\n    @param {Function()} task\n    @return {Promise}\n    @experimental\n     */\n    queueMicrotask = function(task) {\n      return Promise.resolve().then(task);\n    };\n\n    /***\n    Returns the last element of the given array.\n    \n    @function up.util.last\n    @param {Array<T>} array\n    @return {T}\n     */\n    last = function(array) {\n      return array[array.length - 1];\n    };\n\n    /***\n    Returns whether the given keyboard event involved the ESC key.\n    \n    @function up.util.escapePressed\n    @internal\n     */\n    escapePressed = function(event) {\n      var key;\n      key = event.key;\n      return key === 'Escape' || key === 'Esc';\n    };\n\n    /***\n    Returns whether the given array or string contains the given element or substring.\n    \n    @function up.util.contains\n    @param {Array|string} arrayOrString\n    @param elementOrSubstring\n    @stable\n     */\n    contains = function(arrayOrString, elementOrSubstring) {\n      return arrayOrString.indexOf(elementOrSubstring) >= 0;\n    };\n\n    /***\n    Returns a copy of the given object that only contains\n    the given properties.\n    \n    @function up.util.only\n    @param {Object} object\n    @param {Array} keys...\n    @stable\n     */\n    only = function() {\n      var filtered, i, len, object, properties, property;\n      object = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      filtered = {};\n      for (i = 0, len = properties.length; i < len; i++) {\n        property = properties[i];\n        if (property in object) {\n          filtered[property] = object[property];\n        }\n      }\n      return filtered;\n    };\n\n    /***\n    Returns a copy of the given object that contains all except\n    the given properties.\n    \n    @function up.util.except\n    @param {Object} object\n    @param {Array} keys...\n    @stable\n     */\n    except = function() {\n      var filtered, i, len, object, properties, property;\n      object = arguments[0], properties = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      filtered = copy(object);\n      for (i = 0, len = properties.length; i < len; i++) {\n        property = properties[i];\n        delete filtered[property];\n      }\n      return filtered;\n    };\n\n    /***\n    @function up.util.isUnmodifiedKeyEvent\n    @internal\n     */\n    isUnmodifiedKeyEvent = function(event) {\n      return !(event.metaKey || event.shiftKey || event.ctrlKey);\n    };\n\n    /***\n    @function up.util.isUnmodifiedMouseEvent\n    @internal\n     */\n    isUnmodifiedMouseEvent = function(event) {\n      var isLeftButton;\n      isLeftButton = isUndefined(event.button) || event.button === 0;\n      return isLeftButton && isUnmodifiedKeyEvent(event);\n    };\n\n    /***\n    Returns a promise that will never be resolved.\n    \n    @function up.util.unresolvablePromise\n    @internal\n     */\n    unresolvablePromise = function() {\n      return new Promise(noop);\n    };\n\n    /***\n    Removes the given element from the given array.\n    \n    This changes the given array.\n    \n    @function up.util.remove\n    @param {Array<T>} array\n    @param {T} element\n    @stable\n     */\n    remove = function(array, element) {\n      var index;\n      index = array.indexOf(element);\n      if (index >= 0) {\n        array.splice(index, 1);\n        return element;\n      }\n    };\n\n    /***\n    If the given `value` is a function, calls the function with the given `args`.\n    Otherwise it just returns `value`.\n    \n    @function up.util.evalOption\n    @internal\n     */\n    evalOption = function() {\n      var args, value;\n      value = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (isFunction(value)) {\n        return value.apply(null, args);\n      } else {\n        return value;\n      }\n    };\n\n    /***\n    Throws a [JavaScript error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)\n    with the given message.\n    \n    The message will also be printed to the [error log](/up.log.error). Also a notification will be shown at the bottom of the screen.\n    \n    The message may contain [substitution marks](https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions).\n    \n    \\#\\#\\# Examples\n    \n        up.fail('Division by zero')\n        up.fail('Unexpected result %o', result)\n    \n    @function up.fail\n    @param {string} message\n      A message with details about the error.\n    \n      The message can contain [substitution marks](https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions)\n      like `%s` or `%o`.\n    @param {Array<string>} vars...\n      A list of variables to replace any substitution marks in the error message.\n    @experimental\n     */\n    fail = function() {\n      var args, asString, messageArgs, ref, ref1, toastOptions;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      if (isArray(args[0])) {\n        messageArgs = args[0];\n        toastOptions = args[1] || {};\n      } else {\n        messageArgs = args;\n        toastOptions = {};\n      }\n      (ref = up.log).error.apply(ref, messageArgs);\n      up.event.onReady(function() {\n        return up.toast.open(messageArgs, toastOptions);\n      });\n      asString = (ref1 = up.log).sprintf.apply(ref1, messageArgs);\n      throw new Error(asString);\n    };\n    ESCAPE_HTML_ENTITY_MAP = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': '&quot;'\n    };\n\n    /***\n    Escapes the given string of HTML by replacing control chars with their HTML entities.\n    \n    @function up.util.escapeHtml\n    @param {string} string\n      The text that should be escaped\n    @stable\n     */\n    escapeHtml = function(string) {\n      return string.replace(/[&<>\"]/g, function(char) {\n        return ESCAPE_HTML_ENTITY_MAP[char];\n      });\n    };\n\n    /***\n    @function up.util.escapeRegexp\n    @internal\n     */\n    escapeRegexp = function(string) {\n      return string.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n    };\n    pluckKey = function(object, key) {\n      var value;\n      value = object[key];\n      delete object[key];\n      return value;\n    };\n    renameKey = function(object, oldKey, newKey) {\n      return object[newKey] = pluckKey(object, oldKey);\n    };\n    extractLastArg = function(args, tester) {\n      var lastArg;\n      lastArg = last(args);\n      if (tester(lastArg)) {\n        return args.pop();\n      }\n    };\n    extractCallback = function(args) {\n      return extractLastArg(args, isFunction);\n    };\n    extractOptions = function(args) {\n      return extractLastArg(args, isOptions) || {};\n    };\n    partial = function() {\n      var fixedArgs, fn;\n      fn = arguments[0], fixedArgs = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      return function() {\n        var callArgs;\n        callArgs = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        return fn.apply(this, fixedArgs.concat(callArgs));\n      };\n    };\n    identity = function(arg) {\n      return arg;\n    };\n\n    /***\n    Given a function that will return a promise, returns a proxy function\n    with an additional `.promise` attribute.\n    \n    When the proxy is called, the inner function is called.\n    The proxy's `.promise` attribute is available even before the function is called\n    and will resolve when the inner function's returned promise resolves.\n    \n    If the inner function does not return a promise, the proxy's `.promise` attribute\n    will resolve as soon as the inner function returns.\n    \n    @function up.util.previewable\n    @internal\n     */\n    previewable = function(fun) {\n      var deferred, preview;\n      deferred = newDeferred();\n      preview = function() {\n        var args, funValue;\n        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n        funValue = fun.apply(null, args);\n        deferred.resolve(funValue);\n        return funValue;\n      };\n      preview.promise = deferred.promise();\n      return preview;\n    };\n\n    /***\n    @function up.util.sequence\n    @param {Array<Function()>} functions\n    @return {Function()}\n      A function that will call all `functions` if called.\n    \n    @internal\n     */\n    sequence = function(functions) {\n      if (functions.length === 1) {\n        return functions[0];\n      } else {\n        return function() {\n          return map(functions, function(f) {\n            return f();\n          });\n        };\n      }\n    };\n\n    /***\n    Returns `'left'` if the center of the given element is in the left 50% of the screen.\n    Otherwise returns `'right'`.\n    \n    @function up.util.horizontalScreenHalf\n    @internal\n     */\n    horizontalScreenHalf = function(element) {\n      var elementDims, elementMid, screenMid;\n      elementDims = element.getBoundingClientRect();\n      elementMid = elementDims.left + 0.5 * elementDims.width;\n      screenMid = 0.5 * up.viewport.rootWidth();\n      if (elementMid < screenMid) {\n        return 'left';\n      } else {\n        return 'right';\n      }\n    };\n\n    /***\n    Flattens the given `array` a single level deep.\n    \n    @function up.util.flatten\n    @param {Array} array\n      An array which might contain other arrays\n    @return {Array}\n      The flattened array\n    @experimental\n     */\n    flatten = function(array) {\n      var flattened, i, len, object;\n      flattened = [];\n      for (i = 0, len = array.length; i < len; i++) {\n        object = array[i];\n        if (isList(object)) {\n          flattened.push.apply(flattened, object);\n        } else {\n          flattened.push(object);\n        }\n      }\n      return flattened;\n    };\n\n    /***\n    Maps each element using a mapping function,\n    then flattens the result into a new array.\n    \n    @function up.util.flatMap\n    @param {Array} array\n    @param {Function(element)} mapping\n    @return {Array}\n    @experimental\n     */\n    flatMap = function(array, block) {\n      return flatten(map(array, block));\n    };\n\n    /***\n    Returns whether the given value is truthy.\n    \n    @function up.util.isTruthy\n    @internal\n     */\n    isTruthy = function(object) {\n      return !!object;\n    };\n\n    /***\n    Sets the given callback as both fulfillment and rejection handler for the given promise.\n    \n    @function up.util.always\n    @internal\n     */\n    always = function(promise, callback) {\n      return promise.then(callback, callback);\n    };\n\n    /***\n     * Registers an empty rejection handler with the given promise.\n     * This prevents browsers from printing \"Uncaught (in promise)\" to the error\n     * console when the promise is rejection.\n     *\n     * This is helpful for event handlers where it is clear that no rejection\n     * handler will be registered:\n     *\n     *     up.on('submit', 'form[up-target]', (event, $form) => {\n     *       promise = up.submit($form)\n     *       up.util.muteRejection(promise)\n     *     })\n     *\n     * Does nothing if passed a missing value.\n     *\n     * @function up.util.muteRejection\n     * @param {Promise|undefined|null} promise\n     * @return {Promise}\n     */\n    muteRejection = function(promise) {\n      return promise != null ? promise[\"catch\"](noop) : void 0;\n    };\n\n    /***\n    @function up.util.newDeferred\n    @internal\n     */\n\n    /***\n    @function up.util.newDeferred\n    @internal\n     */\n    newDeferred = function() {\n      var nativePromise, rejectFn, resolveFn;\n      resolveFn = void 0;\n      rejectFn = void 0;\n      nativePromise = new Promise(function(givenResolve, givenReject) {\n        resolveFn = givenResolve;\n        return rejectFn = givenReject;\n      });\n      nativePromise.resolve = resolveFn;\n      nativePromise.reject = rejectFn;\n      nativePromise.promise = function() {\n        return nativePromise;\n      };\n      return nativePromise;\n    };\n\n    /***\n    Calls the given block. If the block throws an exception,\n    a rejected promise is returned instead.\n    \n    @function up.util.rejectOnError\n    @internal\n     */\n    rejectOnError = function(block) {\n      var error;\n      try {\n        return block();\n      } catch (error1) {\n        error = error1;\n        return Promise.reject(error);\n      }\n    };\n    sum = function(list, block) {\n      var entry, entryValue, i, len, totalValue;\n      block = iteratee(block);\n      totalValue = 0;\n      for (i = 0, len = list.length; i < len; i++) {\n        entry = list[i];\n        entryValue = block(entry);\n        if (isGiven(entryValue)) {\n          totalValue += entryValue;\n        }\n      }\n      return totalValue;\n    };\n    isBasicObjectProperty = function(k) {\n      return Object.prototype.hasOwnProperty(k);\n    };\n\n    /***\n    Returns whether the two arguments are equal by value.\n    \n    \\#\\#\\# Comparison protocol\n    \n    - By default `up.util.isEqual()` can compare strings, numbers,\n      [array-like values](/up.util.isList), plain objects and `Date` objects.\n    - To make the copying protocol work with user-defined classes,\n      see `up.util.isEqual.key`.\n    - Objects without a defined comparison protocol are\n      defined by reference (`===`).\n    \n    @function up.util.isEqual\n    @param {any} a\n    @param {any} b\n    @return {boolean}\n      Whether the arguments are equal by value.\n    @experimental\n     */\n    isEqual = function(a, b) {\n      var aKeys, bKeys;\n      if (a != null ? a.valueOf : void 0) {\n        a = a.valueOf();\n      }\n      if (b != null ? b.valueOf : void 0) {\n        b = b.valueOf();\n      }\n      if (typeof a !== typeof b) {\n        return false;\n      } else if (isList(a) && isList(b)) {\n        return isEqualList(a, b);\n      } else if (isObject(a) && a[isEqual.key]) {\n        return a[isEqual.key](b);\n      } else if (isOptions(a) && isOptions(b)) {\n        aKeys = Object.keys(a);\n        bKeys = Object.keys(b);\n        if (isEqualList(aKeys, bKeys)) {\n          return every(aKeys, function(aKey) {\n            return isEqual(a[aKey], b[aKey]);\n          });\n        } else {\n          return false;\n        }\n      } else {\n        return a === b;\n      }\n    };\n\n    /***\n    This property contains the name of a method that user-defined classes\n    may implement to hook into the `up.util.isEqual()` protocol.\n    \n    \\#\\#\\# Example\n    \n    We have a user-defined `Account` class that we want to use with `up.util.isEqual()`:\n    \n    ```\n    class Account {\n      constructor(email) {\n        this.email = email\n      }\n    \n      [up.util.isEqual.key](other) {\n        return this.email === other.email;\n      }\n    }\n    ```\n    \n    Note that the protocol method is not actually named `'up.util.isEqual.key'`.\n    Instead it is named after the *value* of the `up.util.isEqual.key` property.\n    To do so, the code sample above is using a\n    [computed property name](https://medium.com/front-end-weekly/javascript-object-creation-356e504173a8)\n    in square brackets.\n    \n    We may now use `Account` instances with `up.util.isEqual()`:\n    \n    ```\n    one = new User('foo@foo.com')\n    two = new User('foo@foo.com')\n    three = new User('bar@bar.com')\n    \n    isEqual = up.util.isEqual(one, two)\n    // isEqual is now true\n    \n    isEqual = up.util.isEqual(one, three)\n    // isEqual is now false\n    ```\n    \n    @property up.util.isEqual.key\n    @param {string} key\n    @experimental\n     */\n    isEqual.key = 'up.util.isEqual';\n    isEqualList = function(a, b) {\n      return a.length === b.length && every(a, function(elem, index) {\n        return isEqual(elem, b[index]);\n      });\n    };\n    splitValues = function(value, separator) {\n      var values;\n      if (separator == null) {\n        separator = ' ';\n      }\n      values = value.split(separator);\n      values = map(values, function(v) {\n        return v.trim();\n      });\n      values = filterList(values, isPresent);\n      return values;\n    };\n    endsWith = function(string, search) {\n      if (search.length > string.length) {\n        return false;\n      } else {\n        return string.substring(string.length - search.length) === search;\n      }\n    };\n    simpleEase = function(x) {\n      if (x < 0.5) {\n        return 2 * x * x;\n      } else {\n        return x * (4 - x * 2) - 1;\n      }\n    };\n    wrapValue = function(object, constructor) {\n      if (object instanceof constructor) {\n        return object;\n      } else {\n        return new constructor(object);\n      }\n    };\n    nextUid = 0;\n    uid = function() {\n      return nextUid++;\n    };\n    return {\n      parseUrl: parseUrl,\n      normalizeUrl: normalizeUrl,\n      normalizeMethod: normalizeMethod,\n      methodAllowsPayload: methodAllowsPayload,\n      assign: assign,\n      assignPolyfill: assignPolyfill,\n      copy: copy,\n      deepCopy: deepCopy,\n      merge: merge,\n      options: newOptions,\n      fail: fail,\n      each: each,\n      eachIterator: eachIterator,\n      map: map,\n      flatMap: flatMap,\n      mapObject: mapObject,\n      times: times,\n      findResult: findResult,\n      some: some,\n      any: function() {\n        up.legacy.warn('up.util.any() has been renamed to up.util.some()');\n        return some.apply(null, arguments);\n      },\n      every: every,\n      all: function() {\n        up.legacy.warn('up.util.all() has been renamed to up.util.every()');\n        return every.apply(null, arguments);\n      },\n      detect: function() {\n        up.legacy.warn('up.util.find() has been renamed to up.util.find()');\n        return findInList.apply(null, arguments);\n      },\n      find: findInList,\n      select: function() {\n        up.legacy.warn('up.util.select() has been renamed to up.util.filter()');\n        return filterList.apply(null, arguments);\n      },\n      filter: filterList,\n      reject: reject,\n      intersect: intersect,\n      compact: compact,\n      uniq: uniq,\n      uniqBy: uniqBy,\n      last: last,\n      isNull: isNull,\n      isDefined: isDefined,\n      isUndefined: isUndefined,\n      isGiven: isGiven,\n      isMissing: isMissing,\n      isPresent: isPresent,\n      isBlank: isBlank,\n      presence: presence,\n      isObject: isObject,\n      isFunction: isFunction,\n      isString: isString,\n      isBoolean: isBoolean,\n      isNumber: isNumber,\n      isElement: isElement,\n      isJQuery: isJQuery,\n      isPromise: isPromise,\n      isOptions: isOptions,\n      isArray: isArray,\n      isFormData: isFormData,\n      isNodeList: isNodeList,\n      isArguments: isArguments,\n      isList: isList,\n      isUnmodifiedKeyEvent: isUnmodifiedKeyEvent,\n      isUnmodifiedMouseEvent: isUnmodifiedMouseEvent,\n      timer: scheduleTimer,\n      setTimer: function() {\n        up.legacy.warn('up.util.setTimer() has been renamed to up.util.timer()');\n        return scheduleTimer.apply(null, arguments);\n      },\n      escapePressed: escapePressed,\n      contains: contains,\n      toArray: toArray,\n      only: only,\n      except: except,\n      unresolvablePromise: unresolvablePromise,\n      remove: remove,\n      memoize: memoize,\n      error: fail,\n      pluckKey: pluckKey,\n      renameKey: renameKey,\n      extractOptions: extractOptions,\n      extractCallback: extractCallback,\n      noop: noop,\n      asyncNoop: asyncNoop,\n      identity: identity,\n      escapeHtml: escapeHtml,\n      escapeRegexp: escapeRegexp,\n      sequence: sequence,\n      previewable: previewable,\n      evalOption: evalOption,\n      horizontalScreenHalf: horizontalScreenHalf,\n      flatten: flatten,\n      isTruthy: isTruthy,\n      newDeferred: newDeferred,\n      always: always,\n      muteRejection: muteRejection,\n      rejectOnError: rejectOnError,\n      isBasicObjectProperty: isBasicObjectProperty,\n      isCrossDomain: isCrossDomain,\n      selectorForElement: function() {\n        up.legacy.warn('up.util.selectorForElement() has been renamed to up.element.toSelector()');\n        return up.element.toSelector.apply(null, arguments);\n      },\n      nextFrame: function() {\n        up.legacy.warn('up.util.nextFrame() has been renamed to up.util.task()');\n        return queueTask.apply(null, arguments);\n      },\n      task: queueTask,\n      microtask: queueMicrotask,\n      isEqual: isEqual,\n      splitValues: splitValues,\n      endsWith: endsWith,\n      sum: sum,\n      wrapList: wrapList,\n      wrapValue: wrapValue,\n      simpleEase: simpleEase,\n      values: objectValues,\n      partial: partial,\n      arrayToSet: arrayToSet,\n      setToArray: setToArray,\n      uid: uid\n    };\n  })();\n\n  up.fail = up.util.fail;\n\n}).call(this);\n(function() {\n  var u,\n    slice = [].slice;\n\n  u = up.util;\n\n  up.legacy = (function() {\n    var fixKey, renamedModule, warn, warnedMessages;\n    fixKey = function(object, oldKey, newKey) {\n      if (oldKey in object) {\n        warn('Property { %s } has been renamed to { %s } (found in %o)', oldKey, newKey, object);\n        return u.renameKey(object, oldKey, newKey);\n      }\n    };\n    renamedModule = function(oldName, newName) {\n      return Object.defineProperty(up, oldName, {\n        get: function() {\n          warn(\"up.\" + oldName + \" has been renamed to up.\" + newName);\n          return up[newName];\n        }\n      });\n    };\n    warnedMessages = {};\n    warn = function() {\n      var args, message, ref;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      message = \"[DEPRECATION] \" + message;\n      message = (ref = up.log).sprintf.apply(ref, [message].concat(slice.call(args)));\n      if (!warnedMessages[message]) {\n        warnedMessages[message] = true;\n        return up.warn(message);\n      }\n    };\n    return {\n      renamedModule: renamedModule,\n      fixKey: fixKey,\n      warn: warn\n    };\n  })();\n\n}).call(this);\n\n/***\nBrowser support\n===============\n\nUnpoly supports all modern browsers.\n\nChrome, Firefox, Edge, Safari\n: Full support\n\nInternet Explorer 11\n: Full support with a `Promise` polyfill like [es6-promise](https://github.com/stefanpenner/es6-promise) (2.4 KB).\n\nInternet Explorer 10 or lower\n: Unpoly prevents itself from booting itself, leaving you with a classic server-side application.\n\n@module up.browser\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.browser = (function() {\n    var callJQuery, canAnimationFrame, canConsole, canControlScrollRestoration, canCssTransition, canCustomElements, canDOMParser, canFormData, canInputEvent, canInspectFormData, canJQuery, canPromise, canPushState, isIE10OrWorse, isIE11, isSupported, navigate, popCookie, submitForm, u, url, whenConfirmed;\n    u = up.util;\n\n    /***\n    @method up.browser.navigate\n    @param {string} url\n    @param {string} [options.method='get']\n    @param {object|Array|FormData|string} [options.params]\n    @internal\n     */\n    navigate = function(url, options) {\n      var request, requestOpts;\n      requestOpts = u.merge(options, {\n        url: url\n      });\n      request = new up.Request(requestOpts);\n      return request.navigate();\n    };\n\n    /***\n    For mocking in specs.\n    \n    @method submitForm\n     */\n    submitForm = function(form) {\n      return form.submit();\n    };\n    url = function() {\n      return location.href;\n    };\n    isIE10OrWorse = u.memoize(function() {\n      return !window.atob;\n    });\n    isIE11 = u.memoize(function() {\n      return 'ActiveXObject' in window;\n    });\n\n    /***\n    Returns whether this browser supports manipulation of the current URL\n    via [`history.pushState`](https://developer.mozilla.org/en-US/docs/Web/API/History/pushState).\n    \n    When `pushState`  (e.g. through [`up.follow()`](/up.follow)), it will gracefully\n    fall back to a full page load.\n    \n    Note that Unpoly will not use `pushState` if the initial page was loaded with\n    a request method other than GET.\n    \n    @function up.browser.canPushState\n    @return {boolean}\n    @experimental\n     */\n    canPushState = function() {\n      return u.isDefined(history.pushState) && up.protocol.initialRequestMethod() === 'get';\n    };\n\n    /***\n    Returns whether this browser supports animation using\n    [CSS transitions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions).\n    \n    When Unpoly is asked to animate history on a browser that doesn't support\n    CSS transitions (e.g. through [`up.animate()`](/up.animate)), it will skip the\n    animation by instantly jumping to the last frame.\n    \n    @function up.browser.canCssTransition\n    @return {boolean}\n    @internal\n     */\n    canCssTransition = u.memoize(function() {\n      return 'transition' in document.documentElement.style;\n    });\n\n    /***\n    Returns whether this browser supports the DOM event [`input`](https://developer.mozilla.org/de/docs/Web/Events/input).\n    \n    @function up.browser.canInputEvent\n    @return {boolean}\n    @internal\n     */\n    canInputEvent = u.memoize(function() {\n      return 'oninput' in document.createElement('input');\n    });\n\n    /***\n    Returns whether this browser supports promises.\n    \n    @function up.browser.canPromise\n    @return {boolean}\n    @internal\n     */\n    canPromise = u.memoize(function() {\n      return !!window.Promise;\n    });\n\n    /***\n    Returns whether this browser supports the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n    interface.\n    \n    @function up.browser.canFormData\n    @return {boolean}\n    @experimental\n     */\n    canFormData = u.memoize(function() {\n      return !!window.FormData;\n    });\n\n    /***\n    @function up.browser.canInspectFormData\n    @return {boolean}\n    @internal\n     */\n    canInspectFormData = u.memoize(function() {\n      return canFormData() && !!FormData.prototype.entries;\n    });\n\n    /***\n    Returns whether this browser supports the [`DOMParser`](https://developer.mozilla.org/en-US/docs/Web/API/DOMParser)\n    interface.\n    \n    @function up.browser.canDOMParser\n    @return {boolean}\n    @internal\n     */\n    canDOMParser = u.memoize(function() {\n      return !!window.DOMParser;\n    });\n\n    /***\n    Returns whether this browser supports the [`debugging console`](https://developer.mozilla.org/en-US/docs/Web/API/Console).\n    \n    @function up.browser.canConsole\n    @return {boolean}\n    @internal\n     */\n    canConsole = u.memoize(function() {\n      return window.console && console.debug && console.info && console.warn && console.error && console.group && console.groupCollapsed && console.groupEnd;\n    });\n    canCustomElements = u.memoize(function() {\n      return !!window.customElements;\n    });\n    canAnimationFrame = u.memoize(function() {\n      return 'requestAnimationFrame' in window;\n    });\n    canControlScrollRestoration = u.memoize(function() {\n      return 'scrollRestoration' in history;\n    });\n    canJQuery = function() {\n      return !!window.jQuery;\n    };\n    popCookie = function(name) {\n      var ref, value;\n      value = (ref = document.cookie.match(new RegExp(name + \"=(\\\\w+)\"))) != null ? ref[1] : void 0;\n      if (u.isPresent(value)) {\n        document.cookie = name + '=; expires=Thu, 01-Jan-70 00:00:01 GMT; path=/';\n      }\n      return value;\n    };\n\n    /***\n    @function up,browser.whenConfirmed\n    @return {Promise}\n    @param {string} options.confirm\n    @param {boolean} options.preload\n    @internal\n     */\n    whenConfirmed = function(options) {\n      if (options.preload || u.isBlank(options.confirm) || window.confirm(options.confirm)) {\n        return Promise.resolve();\n      } else {\n        return Promise.reject(new Error('User canceled action'));\n      }\n    };\n\n    /***\n    Returns whether Unpoly supports the current browser.\n    \n    If this returns `false` Unpoly will prevent itself from [booting](/up.boot)\n    and ignores all registered [event handlers](/up.on) and [compilers](/up.compiler).\n    This leaves you with a classic server-side application.\n    This is usually a better fallback than loading incompatible Javascript and causing\n    many errors on load.\n    \n    @function up.browser.isSupported\n    @stable\n     */\n    isSupported = function() {\n      return !isIE10OrWorse() && canConsole() && canDOMParser() && canFormData() && canCssTransition() && canInputEvent() && canPromise() && canAnimationFrame();\n    };\n    callJQuery = function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      canJQuery() || up.fail(\"jQuery must be published as window.jQuery\");\n      return jQuery.apply(null, args);\n    };\n    return {\n      url: url,\n      navigate: navigate,\n      submitForm: submitForm,\n      canPushState: canPushState,\n      canFormData: canFormData,\n      canInspectFormData: canInspectFormData,\n      canCustomElements: canCustomElements,\n      canControlScrollRestoration: canControlScrollRestoration,\n      canJQuery: canJQuery,\n      whenConfirmed: whenConfirmed,\n      isSupported: isSupported,\n      popCookie: popCookie,\n      jQuery: callJQuery,\n      isIE11: isIE11\n    };\n  })();\n\n}).call(this);\n(function() {\n  var u;\n\n  u = up.util;\n\n  up.Selector = (function() {\n    var CSS_HAS_SUFFIX_PATTERN, MATCH_FN_NAME;\n\n    CSS_HAS_SUFFIX_PATTERN = new RegExp(\"\\\\:has\\\\(([^\\\\)]+)\\\\)$\");\n\n    MATCH_FN_NAME = up.browser.isIE11() ? 'msMatchesSelector' : 'matches';\n\n    function Selector(selector1, filterFn) {\n      this.selector = selector1;\n      this.filterFn = filterFn;\n    }\n\n    Selector.prototype.matches = function(element) {\n      var doesMatch;\n      doesMatch = element[MATCH_FN_NAME](this.selector);\n      if (this.filterFn) {\n        doesMatch && (doesMatch = this.filterFn(element));\n      }\n      return doesMatch;\n    };\n\n    Selector.prototype.descendants = function(root) {\n      var matches;\n      matches = root.querySelectorAll(this.selector);\n      if (this.filterFn) {\n        matches = u.filter(matches, this.filterFn);\n      }\n      return matches;\n    };\n\n    Selector.prototype.descendant = function(root) {\n      var candidates;\n      if (!this.filterFn) {\n        return root.querySelector(this.selector);\n      } else {\n        candidates = root.querySelectorAll(this.selector);\n        return u.find(candidates, this.filterFn);\n      }\n    };\n\n    Selector.prototype.subtree = function(root) {\n      var matches;\n      matches = [];\n      if (this.matches(root)) {\n        matches.push(root);\n      }\n      matches.push.apply(matches, this.descendants(root));\n      return matches;\n    };\n\n    Selector.prototype.closest = function(root) {\n      if (root.closest && !this.filterFn) {\n        return root.closest(this.selector);\n      } else {\n        return this.closestPolyfill(root);\n      }\n    };\n\n    Selector.prototype.closestPolyfill = function(root) {\n      if (this.matches(root, this.selector)) {\n        return root;\n      } else {\n        return this.ancestor(root);\n      }\n    };\n\n    Selector.prototype.ancestor = function(element) {\n      var parentElement;\n      if (parentElement = element.parentElement) {\n        if (this.matches(parentElement)) {\n          return parentElement;\n        } else {\n          return this.ancestor(parentElement);\n        }\n      }\n    };\n\n    Selector.parse = function(selector) {\n      var filter;\n      filter = null;\n      selector = selector.replace(CSS_HAS_SUFFIX_PATTERN, function(match, descendantSelector) {\n        filter = function(element) {\n          return element.querySelector(descendantSelector);\n        };\n        return '';\n      });\n      return new this(selector, filter);\n    };\n\n    return Selector;\n\n  })();\n\n}).call(this);\n\n/***\nDOM helpers\n===========\n\nThe `up.element` module offers functions for DOM manipulation and traversal.\n\nIt complements [native `Element` methods](https://www.w3schools.com/jsref/dom_obj_all.asp) and works across all [supported browsers](/up.browser).\n\n@module up.element\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.element = (function() {\n    var CSS_LENGTH_PROPS, NONE, affix, all, ancestor, attributeSelector, booleanAttr, booleanOrStringAttr, closest, computedStyle, computedStyleNumber, concludeCssTransition, createDocumentFromHtml, createFromHtml, createFromSelector, cssLength, elementTagName, extractFromStyleObject, first, fixedToAbsolute, getList, getOne, getRoot, hasCssTransition, hide, inlineStyle, insertBefore, isSingleton, isVisible, jsonAttr, matches, metaContent, nonUpClasses, normalizeStyleValueForWrite, numberAttr, paint, parseSelector, remove, replace, resolveSelector, setAttrs, setInlineStyle, setMissingAttrs, setTemporaryStyle, show, subtree, toSelector, toggle, toggleClass, u, unwrap, valueToList;\n    u = up.util;\n\n    /***\n    Returns a null-object that mostly behaves like an `Element`.\n    \n    @function up.element.none()\n    @internal\n     */\n    NONE = {\n      getAttribute: function() {\n        return void 0;\n      }\n    };\n\n    /***\n    Matches all elements that have a descendant matching the given selector.\n    \n    \\#\\#\\# Example\n    \n    `up.element.all('div:has(span)')`  matches all `<div>` elements with at least one `<span>` among its descendants:\n    \n    ```html\n    <div>\n      <span>Will be matched</span>\n    </div>\n    <div>\n      Will NOT be matched\n    </div>\n    <div>\n      <span>Will be matched</span>\n    </div>\n    ```\n    \n    \\#\\#\\# Compatibility\n    \n    `:has()` is supported by all Unpoly functions (like `up.element.all()`) and\n     selectors (like `a[up-target]`).\n    \n    As a [level 4 CSS selector](https://drafts.csswg.org/selectors-4/#relational),\n    `:has()` [has yet to be implemented](https://caniuse.com/#feat=css-has)\n    in native browser functions like [`document.querySelectorAll()`](https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll).\n    \n    You can also use [`:has()` in jQuery](https://api.jquery.com/has-selector/).\n    \n    @selector :has()\n    @experimental\n     */\n    parseSelector = function(selector) {\n      return up.Selector.parse(selector);\n    };\n\n    /***\n    Returns the first descendant element matching the given selector.\n    \n    It is similar to [`element.querySelector()`](https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector),\n    but also supports the [`:has()`](/has) selector.\n    \n    @function up.element.first\n    @param {Element} [parent=document]\n      The parent element whose descendants to search.\n    \n      If omitted, all elements in the `document` will be searched.\n    @param {string} selector\n      The CSS selector to match.\n    @return {Element|undefined|null}\n      The first element matching the selector.\n    \n      Returns `null` or `undefined` if no element macthes.\n    @experimental\n     */\n    first = function() {\n      var args, parent, ref, selector;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      selector = args.pop();\n      parent = (ref = args[0]) != null ? ref : document;\n      return parseSelector(selector).descendant(parent);\n    };\n\n    /***\n    Returns all descendant elements matching the given selector.\n    \n    @function up.element.all\n    @param {Element} [parent=document]\n      The parent element whose descendants to search.\n    \n      If omitted, all elements in the `document` will be searched.\n    @param {string} selector\n      The CSS selector to match.\n    @return {NodeList<Element>|Array<Element>}\n      A list of all elements matching the selector.\n    \n      Returns an empty list if there are no matches.\n    @experimental\n     */\n    all = function() {\n      var args, parent, ref, selector;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      selector = args.pop();\n      parent = (ref = args[0]) != null ? ref : document;\n      return parseSelector(selector).descendants(parent);\n    };\n\n    /***\n    Returns a list of the given parent's descendants matching the given selector.\n    The list will also include the parent element if it matches the selector itself.\n    \n    @function up.element.subtree\n    @param {Element} parent\n      The parent element for the search.\n    @param {string} selector\n      The CSS selector to match.\n    @return {NodeList<Element>|Array<Element>}\n      A list of all matching elements.\n    @experimental\n     */\n    subtree = function(root, selector) {\n      return parseSelector(selector).subtree(root);\n    };\n\n    /***\n    Returns the first element that matches the selector by testing the element itself\n    and traversing up through its ancestors in the DOM tree.\n    \n    @function up.element.closest\n    @param {Element} element\n      The element on which to start the search.\n    @param {string} selector\n      The CSS selector to match.\n    @return {Element|null|undefined} element\n      The matching element.\n    \n      Returns `null` or `undefined` if no element matches.\n    @experimental\n     */\n    closest = function(element, selector) {\n      return parseSelector(selector).closest(element);\n    };\n\n    /***\n    Returns whether the given element matches the given CSS selector.\n    \n    @function up.element.matches\n    @param {Element} element\n      The element to check.\n    @param {string} selector\n      The CSS selector to match.\n    @return {boolean}\n      Whether `element` matches `selector`.\n    @experimental\n     */\n    matches = function(element, selector) {\n      return parseSelector(selector).matches(element);\n    };\n\n    /***\n    @function up.element.ancestor\n    @internal\n     */\n    ancestor = function(element, selector) {\n      return parseSelector(selector).ancestor(element);\n    };\n\n    /***\n    Casts the given value to a native [Element](https://developer.mozilla.org/en-US/docs/Web/API/Element).\n    \n    This is useful when working with jQuery values, or to allow callers to pass CSS selectors\n    instead of elements.\n    \n    \\#\\#\\# Casting rules\n    \n    - If given an element, returns that element.\n    - If given a CSS selector string, returns the [first element matching](/up.element.first) that selector.\n    - If given a jQuery collection , returns the first element in the collection.\n      Throws an error if the collection contains more than one element.\n    - If given any other argument (`undefined`, `null`, `document`, `window`), returns the argument unchanged.\n    \n    @function up.element.get\n    @param {Element|jQuery|string} value\n      The value to cast.\n    @return {Element}\n      The obtained `Element`.\n    @experimental\n     */\n    getOne = function(value) {\n      if (u.isElement(value)) {\n        return value;\n      } else if (u.isString(value)) {\n        return first(value);\n      } else if (u.isJQuery(value)) {\n        if (value.length > 1) {\n          up.fail('up.element.get(): Cannot cast multiple elements (%o) to a single element', value);\n        }\n        return value[0];\n      } else {\n        return value;\n      }\n    };\n\n    /***\n    Composes a list of elements from the given arguments.\n    \n    \\#\\#\\# Casting rules\n    \n    - If given a string, returns the all elements matching that string.\n    - If given any other argument, returns the argument [wrapped as a list](/up.util.wrapList).\n    \n    \\#\\#\\# Example\n    \n    ```javascript\n    $jquery = $('.jquery')                          // returns jQuery (2) [div.jquery, div.jquery]\n    nodeList = document.querySelectorAll('.node')   // returns NodeList (2) [div.node, div.node]\n    element = document.querySelector('.element')    // returns Element div.element\n    selector = '.selector'                          // returns String '.selector'\n    \n    elements = up.element.list($jquery, nodeList, undefined, element, selector)\n    // returns [div.jquery, div.jquery, div.node, div.node, div.element, div.selector]\n    ```\n    \n    @function up.element.list\n    @param {Array<jQuery|Element|Array<Element>|String|undefined|null>} ...args\n    @return {Array<Element>}\n    @internal\n     */\n    getList = function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return u.flatMap(args, valueToList);\n    };\n    valueToList = function(value) {\n      if (u.isString(value)) {\n        return all(value);\n      } else {\n        return u.wrapList(value);\n      }\n    };\n\n    /***\n    Removes the given element from the DOM tree.\n    \n    If you don't need IE11 support you may also use the built-in\n    [`Element#remove()`](https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/remove) to the same effect.\n    \n    @function up.element.remove\n    @param {Element} element\n      The element to remove.\n    @experimental\n     */\n    remove = function(element) {\n      var parent;\n      if (element.remove) {\n        return element.remove();\n      } else if (parent = element.parentNode) {\n        return parent.removeChild(element);\n      }\n    };\n\n    /***\n    Hides the given element.\n    \n    The element is hidden by setting an [inline style](https://www.codecademy.com/articles/html-inline-styles)\n    of `{ display: none }`.\n    \n    Also see `up.element.show()`.\n    \n    @function up.element.hide\n    @param {Element} element\n    @experimental\n     */\n    hide = function(element) {\n      return element.style.display = 'none';\n    };\n\n    /***\n    Shows the given element.\n    \n    Also see `up.element.hide()`.\n    \n    \\#\\#\\# Limitations\n    \n    The element is shown by setting an [inline style](https://www.codecademy.com/articles/html-inline-styles)\n    of `{ display: '' }`.\n    \n    You might have CSS rules causing the element to remain hidden after calling `up.element.show(element)`.\n    Unpoly will not handle such cases in order to keep this function performant. As a workaround, you may\n    manually set the `element.style.display` property. Also see discussion\n    in jQuery issues [#88](https://github.com/jquery/jquery.com/issues/88),\n    [#2057](https://github.com/jquery/jquery/issues/2057) and\n    [this WHATWG mailing list post](http://lists.w3.org/Archives/Public/public-whatwg-archive/2014Apr/0094.html).\n    \n    @function up.element.show\n    @experimental\n     */\n    show = function(element) {\n      return element.style.display = '';\n    };\n\n    /***\n    Display or hide the given element, depending on its current visibility.\n    \n    @function up.element.toggle\n    @param {Element} element\n    @param {Boolean} [newVisible]\n      Pass `true` to show the element or `false` to hide it.\n    \n      If omitted, the element will be hidden if shown and shown if hidden.\n    @experimental\n     */\n    toggle = function(element, newVisible) {\n      if (newVisible == null) {\n        newVisible = !isVisible(element);\n      }\n      if (newVisible) {\n        return show(element);\n      } else {\n        return hide(element);\n      }\n    };\n\n    /***\n    Adds or removes the given class from the given element.\n    \n    If you don't need IE11 support you may also use the built-in\n    [`Element#classList.toggle(className)`](https://developer.mozilla.org/en-US/docs/Web/API/Element/classList) to the same effect.\n    \n    @function up.element.toggleClass\n    @param {Element} element\n      The element for which to add or remove the class.\n    @param {String} className\n      A boolean value to determine whether the class should be added or removed.\n    @param {String} state\n      If omitted, the class will be added if missing and removed if present.\n    @experimental\n     */\n    toggleClass = function(element, klass, newPresent) {\n      var list;\n      list = element.classList;\n      if (newPresent == null) {\n        newPresent = !list.contains(klass);\n      }\n      if (newPresent) {\n        return list.add(klass);\n      } else {\n        return list.remove(klass);\n      }\n    };\n\n    /***\n    Sets all key/values from the given object as attributes on the given element.\n    \n    \\#\\#\\# Example\n    \n        up.element.setAttrs(element, { title: 'Tooltip', tabindex: 1 })\n    \n    @function up.element.setAttrs\n    @param {Element} element\n      The element on which to set attributes.\n    @param {object} attributes\n      An object of attributes to set.\n    @experimental\n     */\n    setAttrs = function(element, attributes) {\n      var key, results, value;\n      results = [];\n      for (key in attributes) {\n        value = attributes[key];\n        results.push(element.setAttribute(key, value));\n      }\n      return results;\n    };\n\n    /***\n    @function up.element.metaContent\n    @internal\n     */\n    metaContent = function(name) {\n      var ref, selector;\n      selector = \"meta\" + attributeSelector('name', name);\n      return (ref = first(selector)) != null ? ref.getAttribute('content') : void 0;\n    };\n\n    /***\n    @function up.element.insertBefore\n    @internal\n     */\n    insertBefore = function(existingElement, newElement) {\n      return existingElement.insertAdjacentElement('beforebegin', newElement);\n    };\n\n    /***\n    Replaces the given old element with the given new element.\n    \n    The old element will be removed from the DOM tree.\n    \n    If you don't need IE11 support you may also use the built-in\n    [`Element#replaceWith()`](https://developer.mozilla.org/en-US/docs/Web/API/ChildNode/replaceWith) to the same effect.\n    \n    @function up.element.replace\n    @param {Element} oldElement\n    @param {Element} newElement\n    @experimental\n     */\n    replace = function(oldElement, newElement) {\n      return oldElement.parentElement.replaceChild(newElement, oldElement);\n    };\n\n    /***\n    Creates an element matching the given CSS selector.\n    \n    The created element will not yet be attached to the DOM tree.\n    Attach it with [`Element#appendChild()`](https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild)\n    or use `up.element.affix()` to create an attached element.\n    \n    \\#\\#\\# Examples\n    \n    To create an element with a given tag name:\n    \n        element = up.element.createFromSelector('span')\n        // element is <span></span>\n    \n    To create an element with a given class:\n    \n        element = up.element.createFromSelector('.klass')\n        // element is <div class=\"klass\"></div>\n    \n    To create an element with a given ID:\n    \n        element = up.element.createFromSelector('#foo')\n        // element is <div id=\"foo\"></div>\n    \n    To create an element with a given boolean attribute:\n    \n        element = up.element.createFromSelector('[attr]')\n        // element is <div attr></div>\n    \n    To create an element with a given attribute value:\n    \n        element = up.element.createFromSelector('[attr=\"value\"]')\n        // element is <div attr=\"value\"></div>\n    \n    You may also pass an object of attribute names/values as a second argument:\n    \n        element = up.element.createFromSelector('div', { attr: 'value' })\n        // element is <div attr=\"value\"></div>\n    \n    You may set the element's inner text by passing a `{ text }` option:\n    \n        element = up.element.createFromSelector('div', { text: 'inner text' })\n        // element is <div>inner text</div>\n    \n    You may set inline styles by passing an object of CSS properties as a second argument:\n    \n        element = up.element.createFromSelector('div', { style: { color: 'red' }})\n        // element is <div style=\"color: red\"></div>\n    \n    @function up.element.createFromSelector\n    @param {string} selector\n      The CSS selector from which to create an element.\n    @param {Object} [attrs]\n      An object of attributes to set on the created element.\n    @param {Object} [attrs.text]\n      The [text content](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent) of the created element.\n    @param {Object} [attrs.style]\n      An object of CSS properties that will be set as the inline style\n      of the created element.\n    @return {Element}\n      The created element.\n    @experimental\n     */\n    createFromSelector = function(selector, attrs) {\n      var attrValues, classValue, depthElement, depthSelector, depths, i, j, klass, len, len1, previousElement, ref, rootElement, selectorWithoutAttrValues, styleValue, tagName, textValue;\n      attrValues = [];\n      selectorWithoutAttrValues = selector.replace(/\\[([\\w-]+)(?:=([\"'])?([^\"'\\]]*?)\\2)?\\]/g, function(_match, attrName, _quote, attrValue) {\n        attrValues.push(attrValue || '');\n        return \"[\" + attrName + \"]\";\n      });\n      depths = selectorWithoutAttrValues.split(/[ >]+/);\n      rootElement = void 0;\n      depthElement = void 0;\n      previousElement = void 0;\n      for (i = 0, len = depths.length; i < len; i++) {\n        depthSelector = depths[i];\n        tagName = void 0;\n        depthSelector = depthSelector.replace(/^[\\w-]+/, function(match) {\n          tagName = match;\n          return '';\n        });\n        depthElement = document.createElement(tagName || 'div');\n        rootElement || (rootElement = depthElement);\n        depthSelector = depthSelector.replace(/\\#([\\w-]+)/, function(_match, id) {\n          depthElement.id = id;\n          return '';\n        });\n        depthSelector = depthSelector.replace(/\\.([\\w-]+)/g, function(_match, className) {\n          depthElement.classList.add(className);\n          return '';\n        });\n        if (attrValues.length) {\n          depthSelector = depthSelector.replace(/\\[([\\w-]+)\\]/g, function(_match, attrName) {\n            depthElement.setAttribute(attrName, attrValues.shift());\n            return '';\n          });\n        }\n        if (depthSelector !== '') {\n          throw new Error('Cannot parse selector: ' + selector);\n        }\n        if (previousElement != null) {\n          previousElement.appendChild(depthElement);\n        }\n        previousElement = depthElement;\n      }\n      if (attrs) {\n        if (classValue = u.pluckKey(attrs, 'class')) {\n          ref = u.wrapList(classValue);\n          for (j = 0, len1 = ref.length; j < len1; j++) {\n            klass = ref[j];\n            rootElement.classList.add(klass);\n          }\n        }\n        if (styleValue = u.pluckKey(attrs, 'style')) {\n          setInlineStyle(rootElement, styleValue);\n        }\n        if (textValue = u.pluckKey(attrs, 'text')) {\n          rootElement.innerText = textValue;\n        }\n        setAttrs(rootElement, attrs);\n      }\n      return rootElement;\n    };\n\n    /***\n    Creates an element matching the given CSS selector and attaches it to the given parent element.\n    \n    To create a detached element from a selector,\n    see `up.element.createFromSelector()`.\n    \n    \\#\\#\\# Example\n    \n        element = up.element.affix(document.body, '.klass')\n        element.parentElement // returns document.body\n        element.className // returns 'klass'\n    \n    @function up.element.affix\n    @param {Element} parent\n      The parent to which to attach the created element.\n    @param {string} selector\n      The CSS selector from which to create an element.\n    @param {Object} attrs\n      An object of attributes to set on the created element.\n    @param {Object} attrs.text\n      The [text content](https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent) of the created element.\n    @param {Object} attrs.style\n      An object of CSS properties that will be set as the inline style\n      of the created element.\n    @return {Element}\n      The created element.\n    @experimental\n     */\n    affix = function(parent, selector, attributes) {\n      var element;\n      element = createFromSelector(selector, attributes);\n      parent.appendChild(element);\n      return element;\n    };\n\n    /***\n    Returns a CSS selector that matches the given element as good as possible.\n    \n    To build the selector, the following element properties are used in decreasing\n    order of priority:\n    \n    - The element's `[up-id]` attribute\n    - The element's `[id]` attribute\n    - The element's `[name]` attribute\n    - The element's `[class]` names\n    - The element's [`[aria-label]`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-label_attribute) attribute\n    - The element's tag name\n    \n    \\#\\#\\# Example\n    \n        element = document.createElement('span')\n        element.className = 'klass'\n        selector = up.element.toSelector(element) // returns '.klass'\n    \n    @function up.element.toSelector\n    @param {string|Element|jQuery}\n      The element for which to create a selector.\n    @experimental\n     */\n    toSelector = function(element) {\n      var ariaLabel, classes, i, id, klass, len, name, selector, upId;\n      if (u.isString(element)) {\n        return element;\n      }\n      element = getOne(element);\n      selector = void 0;\n      if (isSingleton(element)) {\n        selector = elementTagName(element);\n      } else if (upId = element.getAttribute(\"up-id\")) {\n        selector = attributeSelector('up-id', upId);\n      } else if (id = element.getAttribute(\"id\")) {\n        if (id.match(/^[a-z0-9\\-_]+$/i)) {\n          selector = \"#\" + id;\n        } else {\n          selector = attributeSelector('id', id);\n        }\n      } else if (name = element.getAttribute(\"name\")) {\n        selector = elementTagName(element) + attributeSelector('name', name);\n      } else if (classes = u.presence(nonUpClasses(element))) {\n        selector = '';\n        for (i = 0, len = classes.length; i < len; i++) {\n          klass = classes[i];\n          selector += \".\" + klass;\n        }\n      } else if (ariaLabel = element.getAttribute(\"aria-label\")) {\n        selector = attributeSelector('aria-label', ariaLabel);\n      } else {\n        selector = elementTagName(element);\n      }\n      return selector;\n    };\n\n    /***\n    Sets an unique identifier for this element.\n    \n    This identifier is used by `up.element.toSelector()`\n    to create a CSS selector that matches this element precisely.\n    \n    If the element already has other attributes that make a good identifier,\n    like a `[id]`, `[class]` or `[aria-label]`, it is not necessary to\n    set `[up-id]`.\n    \n    \\#\\#\\# Example\n    \n    Take this element:\n    \n        <a href=\"/\">Homepage</a>\n    \n    Unpoly cannot generate a good CSS selector for this element:\n    \n        up.element.toSelector(element)\n        // returns 'a'\n    \n    We can improve this by assigning an `[up-id]`:\n    \n        <a href=\"/\" up-id=\"link-to-home\">Open user 4</a>\n    \n    The attribute value is used to create a better selector:\n    \n        up.element.toSelector(element)\n        // returns '[up-id=\"link-to-home\"]'\n    \n    @selector [up-id]\n    @param {string} up-id\n      A string that uniquely identifies this element.\n    @stable\n     */\n\n    /***\n    @function up.element.isSingleton\n    @internal\n     */\n    isSingleton = function(element) {\n      return matches(element, 'html, body, head, title');\n    };\n    elementTagName = function(element) {\n      return element.tagName.toLowerCase();\n    };\n\n    /***\n    @function up.element.attributeSelector\n    @internal\n     */\n    attributeSelector = function(attribute, value) {\n      value = value.replace(/\"/g, '\\\\\"');\n      return \"[\" + attribute + \"=\\\"\" + value + \"\\\"]\";\n    };\n    nonUpClasses = function(element) {\n      var classString, classes;\n      classString = element.className;\n      classes = u.splitValues(classString);\n      return u.reject(classes, function(klass) {\n        return klass.match(/^up-/);\n      });\n    };\n\n    /***\n    @function up.element.createDocumentFromHtml\n    @internal\n     */\n    createDocumentFromHtml = function(html) {\n      var parser;\n      parser = new DOMParser();\n      return parser.parseFromString(html, 'text/html');\n    };\n\n    /***\n    Creates an element from the given HTML fragment.\n    \n    \\#\\#\\# Example\n    \n        element = up.element.createFromHtml('<div class=\"foo\"><span>text</span></div>')\n        element.className // returns 'foo'\n        element.children[0] // returns <span> element\n        element.children[0].textContent // returns 'text'\n    \n    @function up.element.createFromHtml\n    @experimental\n     */\n    createFromHtml = function(html) {\n      var doc;\n      doc = createDocumentFromHtml(html);\n      return doc.body.children[0];\n    };\n\n    /***\n    @function up.element.root\n    @internal\n     */\n    getRoot = function() {\n      return document.documentElement;\n    };\n\n    /***\n    Forces the browser to paint the given element now.\n    \n    @function up.element.paint\n    @internal\n     */\n    paint = function(element) {\n      return element.offsetHeight;\n    };\n\n    /***\n    @function up.element.concludeCssTransition\n    @internal\n     */\n    concludeCssTransition = function(element) {\n      var undo;\n      undo = setTemporaryStyle(element, {\n        transition: 'none'\n      });\n      paint(element);\n      return undo;\n    };\n\n    /***\n    Returns whether the given element has a CSS transition set.\n    \n    @function up.element.hasCssTransition\n    @return {boolean}\n    @internal\n     */\n    hasCssTransition = function(elementOrStyleHash) {\n      var duration, noTransition, prop, styleHash;\n      if (u.isOptions(elementOrStyleHash)) {\n        styleHash = elementOrStyleHash;\n      } else {\n        styleHash = computedStyle(elementOrStyleHash);\n      }\n      prop = styleHash.transitionProperty;\n      duration = styleHash.transitionDuration;\n      noTransition = prop === 'none' || (prop === 'all' && duration === 0);\n      return !noTransition;\n    };\n\n    /***\n    @function up.element.fixedToAbsolute\n    @internal\n     */\n    fixedToAbsolute = function(element) {\n      var elementRectAsFixed, offsetParentRect;\n      elementRectAsFixed = element.getBoundingClientRect();\n      element.style.position = 'absolute';\n      offsetParentRect = element.offsetParent.getBoundingClientRect();\n      return setInlineStyle(element, {\n        left: elementRectAsFixed.left - computedStyleNumber(element, 'margin-left') - offsetParentRect.left,\n        top: elementRectAsFixed.top - computedStyleNumber(element, 'margin-top') - offsetParentRect.top,\n        right: '',\n        bottom: ''\n      });\n    };\n\n    /***\n    On the given element, set attributes that are still missing.\n    \n    @function up.element.setMissingAttrs\n    @internal\n     */\n    setMissingAttrs = function(element, attrs) {\n      var key, results, value;\n      results = [];\n      for (key in attrs) {\n        value = attrs[key];\n        if (u.isMissing(element.getAttribute(key))) {\n          results.push(element.setAttribute(key, value));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n    /***\n    @function up.element.unwrap\n    @internal\n     */\n    unwrap = function(wrapper) {\n      var parent, wrappedNodes;\n      parent = wrapper.parentNode;\n      wrappedNodes = u.toArray(wrapper.childNodes);\n      u.each(wrappedNodes, function(wrappedNode) {\n        return parent.insertBefore(wrappedNode, wrapper);\n      });\n      return parent.removeChild(wrapper);\n    };\n\n    /***\n    Returns the value of the given attribute on the given element, cast as a boolean value.\n    \n    If the attribute value cannot be cast to `true` or `false`, `undefined` is returned.\n    \n    \\#\\#\\# Casting rules\n    \n    This function deviates from the\n    [HTML Standard for boolean attributes](https://html.spec.whatwg.org/multipage/common-microsyntaxes.html#boolean-attributes)\n    in order to allow `undefined` values. When an attribute is missing, Unpoly considers the value to be `undefined`\n    (where the standard would assume `false`).\n    \n    Unpoly also allows `\"true\"` and `\"false\"` as attribute values.\n    \n    The table below shows return values for `up.element.booleanAttr(element, 'foo')` given different elements:\n    \n    | Element             | Return value |\n    |---------------------|--------------|\n    | `<div foo>`         | `true`       |\n    | `<div foo=\"foo\">`   | `true`       |\n    | `<div foo=\"true\">`  | `true`       |\n    | `<div foo=\"\">`      | `true`       |\n    | `<div foo=\"false\">` | `false`      |\n    | `<div>`             | `undefined`  |\n    | `<div foo=\"bar\">`   | `undefined`  |\n    \n    @function up.element.booleanAttr\n    @param {Element} element\n      The element from which to retrieve the attribute value.\n    @param {String} attribute\n      The attribute name.\n    @return {boolean|undefined}\n      The cast attribute value.\n    @experimental\n     */\n    booleanAttr = function(element, attribute, pass) {\n      var value;\n      value = element.getAttribute(attribute);\n      switch (value) {\n        case 'false':\n          return false;\n        case 'true':\n        case '':\n        case attribute:\n          return true;\n        default:\n          if (pass) {\n            return value;\n          }\n      }\n    };\n\n    /***\n    Returns the given attribute value cast as boolean.\n    \n    If the attribute value cannot be cast, returns the attribute value unchanged.\n    \n    @internal\n     */\n    booleanOrStringAttr = function(element, attribute) {\n      return booleanAttr(element, attribute, true);\n    };\n\n    /***\n    Returns the value of the given attribute on the given element, cast to a number.\n    \n    If the attribute value cannot be cast to a number, `undefined` is returned.\n    \n    @function up.element.numberAttr\n    @param {Element} element\n      The element from which to retrieve the attribute value.\n    @param {String} attribute\n      The attribute name.\n    @return {number|undefined}\n      The cast attribute value.\n    @experimental\n     */\n    numberAttr = function(element, attribute) {\n      var value;\n      value = element.getAttribute(attribute);\n      if (value != null ? value.match(/^[\\d\\.]+$/) : void 0) {\n        return parseFloat(value);\n      }\n    };\n\n    /***\n    Reads the given attribute from the element, parsed as [JSON](https://www.json.org/).\n    \n    Returns `undefined` if the attribute value is [blank](/up.util.isBlank).\n    \n    Throws a `SyntaxError` if the attribute value is an invalid JSON string.\n    \n    @function up.element.jsonAttr\n    @param {Element} element\n      The element from which to retrieve the attribute value.\n    @param {String} attribute\n      The attribute name.\n    @return {Object|undefined}\n      The cast attribute value.\n    @experimental\n     */\n    jsonAttr = function(element, attribute) {\n      var json, ref;\n      if (json = typeof element.getAttribute === \"function\" ? (ref = element.getAttribute(attribute)) != null ? ref.trim() : void 0 : void 0) {\n        return JSON.parse(json);\n      }\n    };\n\n    /***\n    Temporarily sets the inline CSS styles on the given element.\n    \n    Returns a function that restores the original inline styles when called.\n    \n    \\#\\#\\# Example\n    \n        element = document.querySelector('div')\n        unhide = up.element.setTemporaryStyle(element, { 'visibility': 'hidden' })\n        // do things while element is invisible\n        unhide()\n        // element is visible again\n    \n    @function up.element.setTemporaryStyle\n    @param {Element} element\n      The element to style.\n    @param {Object} styles\n      An object of CSS property names and values.\n    @return {Function()}\n      A function that restores the original inline styles when called.\n    @internal\n     */\n    setTemporaryStyle = function(element, newStyles, block) {\n      var oldStyles;\n      oldStyles = inlineStyle(element, Object.keys(newStyles));\n      setInlineStyle(element, newStyles);\n      return function() {\n        return setInlineStyle(element, oldStyles);\n      };\n    };\n\n    /***\n    Receives [computed CSS styles](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)\n    for the given element.\n    \n    \\#\\#\\# Examples\n    \n    When requesting a single CSS property, its value will be returned as a string:\n    \n        value = up.element.style(element, 'font-size')\n        // value is '16px'\n    \n    When requesting multiple CSS properties, the function returns an object of property names and values:\n    \n        value = up.element.style(element, ['font-size', 'margin-top'])\n        // value is { 'font-size': '16px', 'margin-top': '10px' }\n    \n    @function up.element.style\n    @param {Element} element\n    @param {String|Array} propOrProps\n      One or more CSS property names in kebab-case or camelCase.\n    @return {string|object}\n    @experimental\n     */\n    computedStyle = function(element, props) {\n      var style;\n      style = window.getComputedStyle(element);\n      return extractFromStyleObject(style, props);\n    };\n\n    /***\n    Receives a [computed CSS property value](https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle)\n    for the given element, casted as a number.\n    \n    The value is casted by removing the property's [unit](https://www.w3schools.com/cssref/css_units.asp) (which is usually `px` for computed properties).\n    The result is then parsed as a floating point number.\n    \n    Returns `undefined` if the property value is missing, or if it cannot\n    be parsed as a number.\n    \n    \\#\\#\\# Examples\n    \n    When requesting a single CSS property, its value will be returned as a string:\n    \n        value = up.element.style(element, 'font-size')\n        // value is '16px'\n    \n        value = up.element.styleNumber(element, 'font-size')\n        // value is 16\n    \n    @function up.element.styleNumber\n    @param {Element} element\n    @param {String} prop\n      A single property name in kebab-case or camelCase.\n    @return {number|undefined}\n    @experimental\n     */\n    computedStyleNumber = function(element, prop) {\n      var rawValue;\n      rawValue = computedStyle(element, prop);\n      if (u.isGiven(rawValue)) {\n        return parseFloat(rawValue);\n      } else {\n        return void 0;\n      }\n    };\n\n    /***\n    Gets the given inline style(s) from the given element's `[style]` attribute.\n    \n    @function up.element.inlineStyle\n    @param {Element} element\n    @param {String|Array} propOrProps\n      One or more CSS property names in kebab-case or camelCase.\n    @return {string|object}\n    @internal\n     */\n    inlineStyle = function(element, props) {\n      var style;\n      style = element.style;\n      return extractFromStyleObject(style, props);\n    };\n    extractFromStyleObject = function(style, keyOrKeys) {\n      if (u.isString(keyOrKeys)) {\n        return style[keyOrKeys];\n      } else {\n        return u.only.apply(u, [style].concat(slice.call(keyOrKeys)));\n      }\n    };\n\n    /***\n    Sets the given CSS properties as inline styles on the given element.\n    \n    @function up.element.setStyle\n    @param {Element} element\n    @param {Object} props\n      One or more CSS properties with kebab-case keys or camelCase keys.\n    @return {string|object}\n    @experimental\n     */\n    setInlineStyle = function(element, props) {\n      var key, results, style, value;\n      style = element.style;\n      results = [];\n      for (key in props) {\n        value = props[key];\n        value = normalizeStyleValueForWrite(key, value);\n        results.push(style[key] = value);\n      }\n      return results;\n    };\n    normalizeStyleValueForWrite = function(key, value) {\n      if (u.isMissing(value)) {\n        value = '';\n      } else if (CSS_LENGTH_PROPS.has(key.toLowerCase().replace(/-/, ''))) {\n        value = cssLength(value);\n      }\n      return value;\n    };\n    CSS_LENGTH_PROPS = u.arrayToSet(['top', 'right', 'bottom', 'left', 'padding', 'paddingtop', 'paddingright', 'paddingbottom', 'paddingleft', 'margin', 'margintop', 'marginright', 'marginbottom', 'marginleft', 'borderwidth', 'bordertopwidth', 'borderrightwidth', 'borderbottomwidth', 'borderleftwidth', 'width', 'height', 'maxwidth', 'maxheight', 'minwidth', 'minheight']);\n\n    /***\n    Converts the given value to a CSS length value, adding a `px` unit if required.\n    \n    @function cssLength\n    @internal\n     */\n    cssLength = function(obj) {\n      if (u.isNumber(obj) || (u.isString(obj) && /^\\d+$/.test(obj))) {\n        return obj.toString() + \"px\";\n      } else {\n        return obj;\n      }\n    };\n\n    /***\n    Resolves the given CSS selector (which might contain `&` references)\n    to a full CSS selector without ampersands.\n    \n    If passed an `Element` or `jQuery` element, returns a CSS selector string\n    for that element.\n    \n    @function up.element.resolveSelector\n    @param {string|Element|jQuery} selectorOrElement\n    @param {string|Element|jQuery} origin\n      The element that this selector resolution is relative to.\n      That element's selector will be substituted for `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @return {string}\n    @internal\n     */\n    resolveSelector = function(selectorOrElement, origin) {\n      var originSelector, selector;\n      if (u.isString(selectorOrElement)) {\n        selector = selectorOrElement;\n        if (u.contains(selector, '&')) {\n          if (u.isPresent(origin)) {\n            originSelector = toSelector(origin);\n            selector = selector.replace(/\\&/, originSelector);\n          } else {\n            up.fail(\"Found origin reference (%s) in selector %s, but no origin was given\", '&', selector);\n          }\n        }\n      } else {\n        selector = toSelector(selectorOrElement);\n      }\n      return selector;\n    };\n\n    /***\n    Returns whether the given element is currently visible.\n    \n    An element is considered visible if it consumes space in the document.\n    Elements with `{ visibility: hidden }` or `{ opacity: 0 }` are considered visible, since they still consume space in the layout.\n    \n    Elements not attached to the DOM are considered hidden.\n    \n    @function up.element.isVisible\n    @param {Element} element\n      The element to check.\n    @experimental\n     */\n    isVisible = function(element) {\n      return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n    };\n    return {\n      first: first,\n      all: all,\n      subtree: subtree,\n      closest: closest,\n      matches: matches,\n      ancestor: ancestor,\n      get: getOne,\n      list: getList,\n      remove: remove,\n      toggle: toggle,\n      toggleClass: toggleClass,\n      hide: hide,\n      show: show,\n      metaContent: metaContent,\n      replace: replace,\n      insertBefore: insertBefore,\n      createFromSelector: createFromSelector,\n      setAttrs: setAttrs,\n      affix: affix,\n      toSelector: toSelector,\n      isSingleton: isSingleton,\n      attributeSelector: attributeSelector,\n      createDocumentFromHtml: createDocumentFromHtml,\n      createFromHtml: createFromHtml,\n      root: getRoot,\n      paint: paint,\n      concludeCssTransition: concludeCssTransition,\n      hasCssTransition: hasCssTransition,\n      fixedToAbsolute: fixedToAbsolute,\n      setMissingAttrs: setMissingAttrs,\n      unwrap: unwrap,\n      booleanAttr: booleanAttr,\n      numberAttr: numberAttr,\n      jsonAttr: jsonAttr,\n      booleanOrStringAttr: booleanOrStringAttr,\n      setTemporaryStyle: setTemporaryStyle,\n      style: computedStyle,\n      styleNumber: computedStyleNumber,\n      inlineStyle: inlineStyle,\n      setStyle: setInlineStyle,\n      resolveSelector: resolveSelector,\n      none: function() {\n        return NONE;\n      },\n      isVisible: isVisible\n    };\n  })();\n\n}).call(this);\n(function() {\n  var e;\n\n  e = up.element;\n\n  up.BodyShifter = (function() {\n    function BodyShifter() {\n      this.unshiftFns = [];\n    }\n\n    BodyShifter.prototype.shift = function() {\n      var anchor, body, bodyRightPadding, bodyRightShift, elementRight, elementRightShift, i, len, overflowElement, ref, results, rootHadVerticalScrollbar, scrollbarWidth;\n      rootHadVerticalScrollbar = up.viewport.rootHasVerticalScrollbar();\n      overflowElement = up.viewport.rootOverflowElement();\n      this.unshiftFns.push(e.setTemporaryStyle(overflowElement, {\n        overflowY: 'hidden'\n      }));\n      if (rootHadVerticalScrollbar) {\n        body = document.body;\n        scrollbarWidth = up.viewport.scrollbarWidth();\n        bodyRightPadding = e.styleNumber(body, 'paddingRight');\n        bodyRightShift = scrollbarWidth + bodyRightPadding;\n        this.unshiftFns.push(e.setTemporaryStyle(body, {\n          paddingRight: bodyRightShift\n        }));\n        ref = up.viewport.anchoredRight();\n        results = [];\n        for (i = 0, len = ref.length; i < len; i++) {\n          anchor = ref[i];\n          elementRight = e.styleNumber(anchor, 'right');\n          elementRightShift = scrollbarWidth + elementRight;\n          results.push(this.unshiftFns.push(e.setTemporaryStyle(anchor, {\n            right: elementRightShift\n          })));\n        }\n        return results;\n      }\n    };\n\n    BodyShifter.prototype.unshift = function() {\n      var results, unshiftFn;\n      results = [];\n      while (unshiftFn = this.unshiftFns.pop()) {\n        results.push(unshiftFn());\n      }\n      return results;\n    };\n\n    return BodyShifter;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    slice = [].slice;\n\n  u = up.util;\n\n\n  /***\n  @class up.Cache\n  @internal\n   */\n\n  up.Cache = (function() {\n\n    /***\n    @constructor\n    @param {number|Function(): number} [config.size]\n      Maximum number of cache entries.\n      Set to `undefined` to not limit the cache size.\n    @param {number|Function(): number} [config.expiry]\n      The number of milliseconds after which a cache entry\n      will be discarded.\n    @param {string} [config.logPrefix]\n      A prefix for log entries printed by this cache object.\n    @param {Function(entry): string} [config.key]\n      A function that takes an argument and returns a string key\n      for storage. If omitted, `toString()` is called on the argument.\n    @param {Function(entry): boolean} [config.cachable]\n      A function that takes a potential cache entry and returns whether\n      this entry  can be stored in the hash. If omitted, all entries are considered\n      cachable.\n     */\n    function Cache(config) {\n      this.config = config != null ? config : {};\n      this.get = bind(this.get, this);\n      this.isFresh = bind(this.isFresh, this);\n      this.remove = bind(this.remove, this);\n      this.set = bind(this.set, this);\n      this.timestamp = bind(this.timestamp, this);\n      this.alias = bind(this.alias, this);\n      this.makeRoomForAnotherKey = bind(this.makeRoomForAnotherKey, this);\n      this.keys = bind(this.keys, this);\n      this.log = bind(this.log, this);\n      this.clear = bind(this.clear, this);\n      this.isCachable = bind(this.isCachable, this);\n      this.isEnabled = bind(this.isEnabled, this);\n      this.normalizeStoreKey = bind(this.normalizeStoreKey, this);\n      this.expiryMillis = bind(this.expiryMillis, this);\n      this.maxKeys = bind(this.maxKeys, this);\n      this.store = this.config.store || new up.store.Memory();\n    }\n\n    Cache.prototype.maxKeys = function() {\n      return u.evalOption(this.config.size);\n    };\n\n    Cache.prototype.expiryMillis = function() {\n      return u.evalOption(this.config.expiry);\n    };\n\n    Cache.prototype.normalizeStoreKey = function(key) {\n      if (this.config.key) {\n        return this.config.key(key);\n      } else {\n        return key.toString();\n      }\n    };\n\n    Cache.prototype.isEnabled = function() {\n      return this.maxKeys() !== 0 && this.expiryMillis() !== 0;\n    };\n\n    Cache.prototype.isCachable = function(key) {\n      if (this.config.cachable) {\n        return this.config.cachable(key);\n      } else {\n        return true;\n      }\n    };\n\n    Cache.prototype.clear = function() {\n      return this.store.clear();\n    };\n\n    Cache.prototype.log = function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      if (this.config.logPrefix) {\n        args[0] = \"[\" + this.config.logPrefix + \"] \" + args[0];\n        return up.puts.apply(up, args);\n      }\n    };\n\n    Cache.prototype.keys = function() {\n      return this.store.keys();\n    };\n\n    Cache.prototype.makeRoomForAnotherKey = function() {\n      var max, oldestKey, oldestTimestamp, storeKeys;\n      storeKeys = u.copy(this.keys());\n      max = this.maxKeys();\n      if (max && storeKeys.length >= max) {\n        oldestKey = void 0;\n        oldestTimestamp = void 0;\n        u.each(storeKeys, (function(_this) {\n          return function(key) {\n            var entry, timestamp;\n            entry = _this.store.get(key);\n            timestamp = entry.timestamp;\n            if (!oldestTimestamp || oldestTimestamp > timestamp) {\n              oldestKey = key;\n              return oldestTimestamp = timestamp;\n            }\n          };\n        })(this));\n        if (oldestKey) {\n          return this.store.remove(oldestKey);\n        }\n      }\n    };\n\n    Cache.prototype.alias = function(oldKey, newKey) {\n      var value;\n      value = this.get(oldKey, {\n        silent: true\n      });\n      if (u.isDefined(value)) {\n        return this.set(newKey, value);\n      }\n    };\n\n    Cache.prototype.timestamp = function() {\n      return (new Date()).valueOf();\n    };\n\n    Cache.prototype.set = function(key, value) {\n      var storeKey, timestampedValue;\n      if (this.isEnabled() && this.isCachable(key)) {\n        this.makeRoomForAnotherKey();\n        storeKey = this.normalizeStoreKey(key);\n        this.log(\"Setting entry %o to %o\", storeKey, value);\n        timestampedValue = {\n          timestamp: this.timestamp(),\n          value: value\n        };\n        return this.store.set(storeKey, timestampedValue);\n      }\n    };\n\n    Cache.prototype.remove = function(key) {\n      var storeKey;\n      if (this.isCachable(key)) {\n        storeKey = this.normalizeStoreKey(key);\n        return this.store.remove(storeKey);\n      }\n    };\n\n    Cache.prototype.isFresh = function(entry) {\n      var millis, timeSinceTouch;\n      millis = this.expiryMillis();\n      if (millis) {\n        timeSinceTouch = this.timestamp() - entry.timestamp;\n        return timeSinceTouch < millis;\n      } else {\n        return true;\n      }\n    };\n\n    Cache.prototype.get = function(key, options) {\n      var entry;\n      if (options == null) {\n        options = {};\n      }\n      if (this.isCachable(key) && (entry = this.store.get(this.normalizeStoreKey(key)))) {\n        if (this.isFresh(entry)) {\n          if (!options.silent) {\n            this.log(\"Cache hit for '%s'\", key);\n          }\n          return entry.value;\n        } else {\n          if (!options.silent) {\n            this.log(\"Discarding stale cache entry for '%s'\", key);\n          }\n          this.remove(key);\n          return void 0;\n        }\n      } else {\n        if (!options.silent) {\n          this.log(\"Cache miss for '%s'\", key);\n        }\n        return void 0;\n      }\n    };\n\n    return Cache;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    slice = [].slice;\n\n  u = up.util;\n\n  up.Record = (function() {\n    Record.prototype.fields = function() {\n      throw 'Return an array of property names';\n    };\n\n    function Record(options) {\n      u.assign(this, this.attributes(options));\n    }\n\n    Record.prototype.attributes = function(source) {\n      if (source == null) {\n        source = this;\n      }\n      return u.only.apply(u, [source].concat(slice.call(this.fields())));\n    };\n\n    Record.prototype[\"\" + u.copy.key] = function() {\n      return this.variant();\n    };\n\n    Record.prototype.variant = function(changes) {\n      var attributesWithChanges;\n      if (changes == null) {\n        changes = {};\n      }\n      attributesWithChanges = u.merge(this.attributes(), changes);\n      return new this.constructor(attributesWithChanges);\n    };\n\n    Record.prototype[\"\" + u.isEqual.key] = function(other) {\n      return other && (this.constructor === other.constructor) && u.isEqual(this.attributes(), other.attributes());\n    };\n\n    return Record;\n\n  })();\n\n}).call(this);\n(function() {\n  var e, u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  e = up.element;\n\n  up.CompilePass = (function() {\n    function CompilePass(root, compilers, options) {\n      this.root = root;\n      this.compilers = compilers;\n      if (options == null) {\n        options = {};\n      }\n      this.isInSkippedSubtree = bind(this.isInSkippedSubtree, this);\n      this.skipSubtrees = options.skip;\n      if (!(this.skipSubtrees.length && this.root.querySelector('[up-keep]'))) {\n        this.skipSubtrees = void 0;\n      }\n    }\n\n    CompilePass.prototype.compile = function() {\n      return up.log.group(\"Compiling fragment %o\", this.root, (function(_this) {\n        return function() {\n          var compiler, i, len, ref, results;\n          ref = _this.compilers;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            compiler = ref[i];\n            results.push(_this.runCompiler(compiler));\n          }\n          return results;\n        };\n      })(this));\n    };\n\n    CompilePass.prototype.runCompiler = function(compiler) {\n      var matches;\n      matches = this.select(compiler.selector);\n      if (!matches.length) {\n        return;\n      }\n      return up.log.group((!compiler.isDefault ? \"Compiling '%s' on %d element(s)\" : void 0), compiler.selector, matches.length, (function(_this) {\n        return function() {\n          var i, j, keepValue, len, len1, match, results, value;\n          if (compiler.batch) {\n            _this.compileBatch(compiler, matches);\n          } else {\n            for (i = 0, len = matches.length; i < len; i++) {\n              match = matches[i];\n              _this.compileOneElement(compiler, match);\n            }\n          }\n          if (keepValue = compiler.keep) {\n            value = u.isString(keepValue) ? keepValue : '';\n            results = [];\n            for (j = 0, len1 = matches.length; j < len1; j++) {\n              match = matches[j];\n              results.push(match.setAttribute('up-keep', value));\n            }\n            return results;\n          }\n        };\n      })(this));\n    };\n\n    CompilePass.prototype.compileOneElement = function(compiler, element) {\n      var compileArgs, data, destructorOrDestructors, elementArg, result;\n      elementArg = compiler.jQuery ? up.browser.jQuery(element) : element;\n      compileArgs = [elementArg];\n      if (compiler.length !== 1) {\n        data = up.syntax.data(element);\n        compileArgs.push(data);\n      }\n      result = compiler.apply(element, compileArgs);\n      if (destructorOrDestructors = this.destructorPresence(result)) {\n        return up.destructor(element, destructorOrDestructors);\n      }\n    };\n\n    CompilePass.prototype.compileBatch = function(compiler, elements) {\n      var compileArgs, dataList, elementsArgs, result;\n      elementsArgs = compiler.jQuery ? up.browser.jQuery(elements) : elements;\n      compileArgs = [elementsArgs];\n      if (compiler.length !== 1) {\n        dataList = u.map(elements, up.syntax.data);\n        compileArgs.push(dataList);\n      }\n      result = compiler.apply(elements, compileArgs);\n      if (this.destructorPresence(result)) {\n        return up.fail('Compilers with { batch: true } cannot return destructors');\n      }\n    };\n\n    CompilePass.prototype.destructorPresence = function(result) {\n      if (u.isFunction(result) || u.isArray(result) && (u.every(result, u.isFunction))) {\n        return result;\n      }\n    };\n\n    CompilePass.prototype.select = function(selector) {\n      var matches;\n      if (u.isFunction(selector)) {\n        selector = selector();\n      }\n      matches = e.subtree(this.root, selector);\n      if (this.skipSubtrees) {\n        matches = u.reject(matches, this.isInSkippedSubtree);\n      }\n      return matches;\n    };\n\n    CompilePass.prototype.isInSkippedSubtree = function(element) {\n      var parent;\n      if (u.contains(this.skipSubtrees, element)) {\n        return true;\n      } else if (parent = element.parentElement) {\n        return this.isInSkippedSubtree(parent);\n      } else {\n        return false;\n      }\n    };\n\n    return CompilePass;\n\n  })();\n\n}).call(this);\n(function() {\n  var u;\n\n  u = up.util;\n\n  up.Config = (function() {\n    function Config(blueprint) {\n      this.blueprint = blueprint;\n      this.reset();\n    }\n\n    Config.prototype.reset = function() {\n      return u.assign(this, u.deepCopy(this.blueprint));\n    };\n\n    return Config;\n\n  })();\n\n}).call(this);\n(function() {\n  var e, u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  e = up.element;\n\n  up.CssTransition = (function() {\n    function CssTransition(element, lastFrameKebab, options) {\n      this.element = element;\n      this.lastFrameKebab = lastFrameKebab;\n      this.startMotion = bind(this.startMotion, this);\n      this.resumeOldTransition = bind(this.resumeOldTransition, this);\n      this.pauseOldTransition = bind(this.pauseOldTransition, this);\n      this.finish = bind(this.finish, this);\n      this.onTransitionEnd = bind(this.onTransitionEnd, this);\n      this.listenToTransitionEnd = bind(this.listenToTransitionEnd, this);\n      this.stopFallbackTimer = bind(this.stopFallbackTimer, this);\n      this.startFallbackTimer = bind(this.startFallbackTimer, this);\n      this.onFinishEvent = bind(this.onFinishEvent, this);\n      this.listenToFinishEvent = bind(this.listenToFinishEvent, this);\n      this.start = bind(this.start, this);\n      this.lastFrameKeysKebab = Object.keys(this.lastFrameKebab);\n      if (u.some(this.lastFrameKeysKebab, function(key) {\n        return key.match(/A-Z/);\n      })) {\n        up.fail('Animation keys must be kebab-case');\n      }\n      this.finishEvent = options.finishEvent;\n      this.duration = options.duration;\n      this.delay = options.delay;\n      this.totalDuration = this.delay + this.duration;\n      this.easing = options.easing;\n      this.finished = false;\n    }\n\n    CssTransition.prototype.start = function() {\n      if (this.lastFrameKeysKebab.length === 0) {\n        this.finished = true;\n        return Promise.resolve();\n      }\n      this.deferred = u.newDeferred();\n      this.pauseOldTransition();\n      this.startTime = new Date();\n      this.startFallbackTimer();\n      this.listenToFinishEvent();\n      this.listenToTransitionEnd();\n      this.startMotion();\n      return this.deferred.promise();\n    };\n\n    CssTransition.prototype.listenToFinishEvent = function() {\n      if (this.finishEvent) {\n        return this.stopListenToFinishEvent = this.element.addEventListener(this.finishEvent, this.onFinishEvent);\n      }\n    };\n\n    CssTransition.prototype.onFinishEvent = function(event) {\n      event.stopPropagation();\n      return this.finish();\n    };\n\n    CssTransition.prototype.startFallbackTimer = function() {\n      var timingTolerance;\n      timingTolerance = 100;\n      return this.fallbackTimer = u.timer(this.totalDuration + timingTolerance, (function(_this) {\n        return function() {\n          return _this.finish();\n        };\n      })(this));\n    };\n\n    CssTransition.prototype.stopFallbackTimer = function() {\n      return clearTimeout(this.fallbackTimer);\n    };\n\n    CssTransition.prototype.listenToTransitionEnd = function() {\n      return this.stopListenToTransitionEnd = up.on(this.element, 'transitionend', this.onTransitionEnd);\n    };\n\n    CssTransition.prototype.onTransitionEnd = function(event) {\n      var completedPropertyKebab, elapsed;\n      if (event.target !== this.element) {\n        return;\n      }\n      elapsed = new Date() - this.startTime;\n      if (!(elapsed > 0.25 * this.totalDuration)) {\n        return;\n      }\n      completedPropertyKebab = event.propertyName;\n      if (!u.contains(this.lastFrameKeysKebab, completedPropertyKebab)) {\n        return;\n      }\n      return this.finish();\n    };\n\n    CssTransition.prototype.finish = function() {\n      if (this.finished) {\n        return;\n      }\n      this.finished = true;\n      this.stopFallbackTimer();\n      if (typeof this.stopListenToFinishEvent === \"function\") {\n        this.stopListenToFinishEvent();\n      }\n      if (typeof this.stopListenToTransitionEnd === \"function\") {\n        this.stopListenToTransitionEnd();\n      }\n      e.concludeCssTransition(this.element);\n      this.resumeOldTransition();\n      return this.deferred.resolve();\n    };\n\n    CssTransition.prototype.pauseOldTransition = function() {\n      var oldTransition, oldTransitionFrameKebab, oldTransitionProperties;\n      oldTransition = e.style(this.element, ['transitionProperty', 'transitionDuration', 'transitionDelay', 'transitionTimingFunction']);\n      if (e.hasCssTransition(oldTransition)) {\n        if (oldTransition.transitionProperty !== 'all') {\n          oldTransitionProperties = oldTransition.transitionProperty.split(/\\s*,\\s*/);\n          oldTransitionFrameKebab = e.style(this.element, oldTransitionProperties);\n          this.setOldTransitionTargetFrame = e.setTemporaryStyle(this.element, oldTransitionFrameKebab);\n        }\n        return this.setOldTransition = e.concludeCssTransition(this.element);\n      }\n    };\n\n    CssTransition.prototype.resumeOldTransition = function() {\n      if (typeof this.setOldTransitionTargetFrame === \"function\") {\n        this.setOldTransitionTargetFrame();\n      }\n      return typeof this.setOldTransition === \"function\" ? this.setOldTransition() : void 0;\n    };\n\n    CssTransition.prototype.startMotion = function() {\n      e.setStyle(this.element, {\n        transitionProperty: Object.keys(this.lastFrameKebab).join(', '),\n        transitionDuration: this.duration + \"ms\",\n        transitionDelay: this.delay + \"ms\",\n        transitionTimingFunction: this.easing\n      });\n      return e.setStyle(this.element, this.lastFrameKebab);\n    };\n\n    return CssTransition;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    slice = [].slice;\n\n  u = up.util;\n\n\n  /***\n  A linear task queue whose (2..n)th tasks can be changed at any time.\n  \n  @function up.DivertibleChain\n  @internal\n   */\n\n  up.DivertibleChain = (function() {\n    function DivertibleChain() {\n      this.asap = bind(this.asap, this);\n      this.poke = bind(this.poke, this);\n      this.allTasks = bind(this.allTasks, this);\n      this.promise = bind(this.promise, this);\n      this.reset = bind(this.reset, this);\n      this.reset();\n    }\n\n    DivertibleChain.prototype.reset = function() {\n      this.queue = [];\n      return this.currentTask = void 0;\n    };\n\n    DivertibleChain.prototype.promise = function() {\n      var lastTask;\n      lastTask = u.last(this.allTasks());\n      return (lastTask != null ? lastTask.promise : void 0) || Promise.resolve();\n    };\n\n    DivertibleChain.prototype.allTasks = function() {\n      var tasks;\n      tasks = [];\n      if (this.currentTask) {\n        tasks.push(this.currentTask);\n      }\n      tasks = tasks.concat(this.queue);\n      return tasks;\n    };\n\n    DivertibleChain.prototype.poke = function() {\n      var promise;\n      if (!this.currentTask) {\n        if (this.currentTask = this.queue.shift()) {\n          promise = this.currentTask();\n          return u.always(promise, (function(_this) {\n            return function() {\n              _this.currentTask = void 0;\n              return _this.poke();\n            };\n          })(this));\n        }\n      }\n    };\n\n    DivertibleChain.prototype.asap = function() {\n      var newTasks;\n      newTasks = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      this.queue = u.map(newTasks, u.previewable);\n      this.poke();\n      return this.promise();\n    };\n\n    return DivertibleChain;\n\n  })();\n\n}).call(this);\n(function() {\n  var e, u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  e = up.element;\n\n  up.EventListener = (function() {\n    function EventListener(element1, eventName1, selector1, callback1, options) {\n      this.element = element1;\n      this.eventName = eventName1;\n      this.selector = selector1;\n      this.callback = callback1;\n      if (options == null) {\n        options = {};\n      }\n      this.nativeCallback = bind(this.nativeCallback, this);\n      this.unbind = bind(this.unbind, this);\n      this.jQuery = options.jQuery;\n      this.key = this.constructor.key(this.eventName, this.selector, this.callback);\n      this.isDefault = up.framework.isBooting();\n    }\n\n    EventListener.prototype.bind = function() {\n      var base, map;\n      map = ((base = this.element).upEventListeners || (base.upEventListeners = {}));\n      if (map[this.key]) {\n        up.fail('up.on(): The %o callback %o cannot be registered more than once', this.eventName, this.callback);\n      }\n      map[this.key] = this;\n      return this.element.addEventListener(this.eventName, this.nativeCallback);\n    };\n\n    EventListener.prototype.unbind = function() {\n      var map;\n      if (map = this.element.upEventListeners) {\n        delete map[this.key];\n      }\n      return this.element.removeEventListener(this.eventName, this.nativeCallback);\n    };\n\n    EventListener.prototype.nativeCallback = function(event) {\n      var args, data, element, elementArg, expectedArgCount;\n      element = event.target;\n      if (this.selector) {\n        element = e.closest(element, this.selector);\n      }\n      if (element) {\n        elementArg = this.jQuery ? up.browser.jQuery(element) : element;\n        args = [event, elementArg];\n        expectedArgCount = this.callback.length;\n        if (!(expectedArgCount === 1 || expectedArgCount === 2)) {\n          data = up.syntax.data(element);\n          args.push(data);\n        }\n        return this.callback.apply(element, args);\n      }\n    };\n\n\n    /*\n    Parses the following arg variants into an object:\n    \n    - [elements, eventNames, selector, callback]\n    - [elements, eventNames,           callback]\n    - [          eventNames, selector, callback]\n    - [          eventNames,           callback]\n    \n    @function up.EventListener#parseArgs\n    @internal\n     */\n\n    EventListener.parseArgs = function(args) {\n      var callback, elements, eventNames, selector;\n      args = u.copy(args);\n      callback = args.pop();\n      callback.upUid || (callback.upUid = u.uid());\n      if (args[0].addEventListener) {\n        elements = [args.shift()];\n      } else if (u.isJQuery(args[0]) || (u.isList(args[0]) && args[0][0].addEventListener)) {\n        elements = args.shift();\n      } else {\n        elements = [document];\n      }\n      eventNames = u.splitValues(args.shift());\n      selector = args[0];\n      return {\n        elements: elements,\n        eventNames: eventNames,\n        selector: selector,\n        callback: callback\n      };\n    };\n\n    EventListener.bind = function(args, options) {\n      var element, eventName, i, j, len, len1, listener, parsed, ref, ref1, unbindFns;\n      parsed = this.parseArgs(args);\n      unbindFns = [];\n      ref = parsed.elements;\n      for (i = 0, len = ref.length; i < len; i++) {\n        element = ref[i];\n        ref1 = parsed.eventNames;\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          eventName = ref1[j];\n          listener = new this(element, eventName, parsed.selector, parsed.callback, options);\n          listener.bind();\n          unbindFns.push(listener.unbind);\n        }\n      }\n      return u.sequence(unbindFns);\n    };\n\n    EventListener.key = function(eventName, selector, callback) {\n      return [eventName, selector, callback.upUid].join('|');\n    };\n\n    EventListener.unbind = function(args) {\n      var element, eventName, i, key, len, listener, map, parsed, ref, results;\n      parsed = this.parseArgs(args);\n      ref = parsed.elements;\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        element = ref[i];\n        map = element.upEventListeners;\n        results.push((function() {\n          var j, len1, ref1, results1;\n          ref1 = parsed.eventNames;\n          results1 = [];\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            eventName = ref1[j];\n            key = this.key(eventName, parsed.selector, parsed.callback);\n            if (map && (listener = map[key])) {\n              results1.push(listener.unbind());\n            } else {\n              results1.push(void 0);\n            }\n          }\n          return results1;\n        }).call(this));\n      }\n      return results;\n    };\n\n    EventListener.unbindNonDefault = function(element) {\n      var i, len, listener, listeners, map, results;\n      if (map = element.upEventListeners) {\n        listeners = u.values(map);\n        results = [];\n        for (i = 0, len = listeners.length; i < len; i++) {\n          listener = listeners[i];\n          if (!listener.isDefault) {\n            results.push(listener.unbind());\n          } else {\n            results.push(void 0);\n          }\n        }\n        return results;\n      }\n    };\n\n    return EventListener;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  up.ExtractCascade = (function() {\n    function ExtractCascade(selectorOrElement, options) {\n      this.oldPlanNotFound = bind(this.oldPlanNotFound, this);\n      this.matchingPlanNotFound = bind(this.matchingPlanNotFound, this);\n      this.bestMatchingSteps = bind(this.bestMatchingSteps, this);\n      this.bestPreflightSelector = bind(this.bestPreflightSelector, this);\n      this.detectPlan = bind(this.detectPlan, this);\n      this.matchingPlan = bind(this.matchingPlan, this);\n      this.newPlan = bind(this.newPlan, this);\n      this.oldPlan = bind(this.oldPlan, this);\n      var base, base1;\n      this.options = u.options(options, {\n        humanizedTarget: 'selector',\n        layer: 'auto'\n      });\n      if ((base = this.options).transition == null) {\n        base.transition = this.options.animation;\n      }\n      if ((base1 = this.options).hungry == null) {\n        base1.hungry = true;\n      }\n      this.candidates = this.buildCandidates(selectorOrElement);\n      this.plans = u.map(this.candidates, (function(_this) {\n        return function(candidate, i) {\n          var planOptions, ref;\n          planOptions = u.copy(_this.options);\n          if (i > 0) {\n            planOptions.transition = (ref = up.fragment.config.fallbackTransition) != null ? ref : _this.options.transition;\n          }\n          return new up.ExtractPlan(candidate, planOptions);\n        };\n      })(this));\n    }\n\n    ExtractCascade.prototype.buildCandidates = function(selector) {\n      var candidates;\n      candidates = [selector, this.options.fallback, up.fragment.config.fallbacks];\n      candidates = u.flatten(candidates);\n      candidates = u.filter(candidates, u.isTruthy);\n      candidates = u.uniq(candidates);\n      if (this.options.fallback === false || this.options.provideTarget) {\n        candidates = [candidates[0]];\n      }\n      return candidates;\n    };\n\n    ExtractCascade.prototype.oldPlan = function() {\n      return this.detectPlan('oldExists');\n    };\n\n    ExtractCascade.prototype.newPlan = function() {\n      return this.detectPlan('newExists');\n    };\n\n    ExtractCascade.prototype.matchingPlan = function() {\n      return this.detectPlan('matchExists');\n    };\n\n    ExtractCascade.prototype.detectPlan = function(checker) {\n      return u.find(this.plans, function(plan) {\n        return plan[checker]();\n      });\n    };\n\n    ExtractCascade.prototype.bestPreflightSelector = function() {\n      var plan;\n      if (this.options.provideTarget) {\n        plan = this.plans[0];\n      } else {\n        plan = this.oldPlan();\n      }\n      if (plan) {\n        plan.resolveNesting();\n        return plan.selector();\n      } else {\n        return this.oldPlanNotFound();\n      }\n    };\n\n    ExtractCascade.prototype.bestMatchingSteps = function() {\n      var plan;\n      if (plan = this.matchingPlan()) {\n        plan.addHungrySteps();\n        plan.resolveNesting();\n        return plan.steps;\n      } else {\n        return this.matchingPlanNotFound();\n      }\n    };\n\n    ExtractCascade.prototype.matchingPlanNotFound = function() {\n      var inspectAction, message;\n      if (this.newPlan()) {\n        return this.oldPlanNotFound();\n      } else {\n        if (this.oldPlan()) {\n          message = \"Could not find \" + this.options.humanizedTarget + \" in response\";\n        } else {\n          message = \"Could not match \" + this.options.humanizedTarget + \" in current page and response\";\n        }\n        if (this.options.inspectResponse) {\n          inspectAction = {\n            label: 'Open response',\n            callback: this.options.inspectResponse\n          };\n        }\n        return up.fail([message + \" (tried %o)\", this.candidates], {\n          action: inspectAction\n        });\n      }\n    };\n\n    ExtractCascade.prototype.oldPlanNotFound = function() {\n      var layerProse;\n      layerProse = this.options.layer;\n      if (layerProse === 'auto') {\n        layerProse = 'page, modal or popup';\n      }\n      return up.fail(\"Could not find \" + this.options.humanizedTarget + \" in current \" + layerProse + \" (tried %o)\", this.candidates);\n    };\n\n    return ExtractCascade;\n\n  })();\n\n}).call(this);\n(function() {\n  var e, u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  e = up.element;\n\n  up.ExtractPlan = (function() {\n    function ExtractPlan(selector, options) {\n      this.addHungrySteps = bind(this.addHungrySteps, this);\n      this.parseSteps = bind(this.parseSteps, this);\n      this.selector = bind(this.selector, this);\n      this.resolveNesting = bind(this.resolveNesting, this);\n      this.addSteps = bind(this.addSteps, this);\n      this.matchExists = bind(this.matchExists, this);\n      this.newExists = bind(this.newExists, this);\n      this.oldExists = bind(this.oldExists, this);\n      this.findNew = bind(this.findNew, this);\n      this.findOld = bind(this.findOld, this);\n      var originalSelector;\n      this.reveal = options.reveal;\n      this.origin = options.origin;\n      this.hungry = options.hungry;\n      this.transition = options.transition;\n      this.response = options.response;\n      this.oldLayer = options.layer;\n      originalSelector = e.resolveSelector(selector, this.origin);\n      this.parseSteps(originalSelector);\n    }\n\n    ExtractPlan.prototype.findOld = function() {\n      return u.each(this.steps, (function(_this) {\n        return function(step) {\n          return step.oldElement = up.fragment.first(step.selector, {\n            layer: _this.oldLayer\n          });\n        };\n      })(this));\n    };\n\n    ExtractPlan.prototype.findNew = function() {\n      return u.each(this.steps, (function(_this) {\n        return function(step) {\n          return step.newElement = _this.response.first(step.selector);\n        };\n      })(this));\n    };\n\n    ExtractPlan.prototype.oldExists = function() {\n      this.findOld();\n      return u.every(this.steps, function(step) {\n        return step.oldElement;\n      });\n    };\n\n    ExtractPlan.prototype.newExists = function() {\n      this.findNew();\n      return u.every(this.steps, function(step) {\n        return step.newElement;\n      });\n    };\n\n    ExtractPlan.prototype.matchExists = function() {\n      return this.oldExists() && this.newExists();\n    };\n\n    ExtractPlan.prototype.addSteps = function(steps) {\n      return this.steps = this.steps.concat(steps);\n    };\n\n    ExtractPlan.prototype.resolveNesting = function() {\n      var compressed;\n      if (this.steps.length < 2) {\n        return;\n      }\n      compressed = u.copy(this.steps);\n      compressed = u.uniqBy(compressed, function(step) {\n        return step.oldElement;\n      });\n      compressed = u.filter(compressed, (function(_this) {\n        return function(candidateStep, candidateIndex) {\n          return u.every(compressed, function(rivalStep, rivalIndex) {\n            var candidateElement, rivalElement;\n            if (rivalIndex === candidateIndex) {\n              return true;\n            } else {\n              candidateElement = candidateStep.oldElement;\n              rivalElement = rivalStep.oldElement;\n              return rivalStep.pseudoClass || !rivalElement.contains(candidateElement);\n            }\n          });\n        };\n      })(this));\n      compressed[0].reveal = this.steps[0].reveal;\n      return this.steps = compressed;\n    };\n\n    ExtractPlan.prototype.selector = function() {\n      return u.map(this.steps, 'expression').join(', ');\n    };\n\n    ExtractPlan.prototype.parseSteps = function(originalSelector) {\n      var comma, disjunction;\n      comma = /\\ *,\\ */;\n      this.steps = [];\n      disjunction = originalSelector.split(comma);\n      return u.each(disjunction, (function(_this) {\n        return function(expression, i) {\n          var doReveal, expressionParts, pseudoClass, selector;\n          expressionParts = expression.match(/^(.+?)(?:\\:(before|after))?$/);\n          expressionParts || up.fail('Could not parse selector literal \"%s\"', expression);\n          selector = expressionParts[1];\n          if (selector === 'html') {\n            selector = 'body';\n          }\n          pseudoClass = expressionParts[2];\n          doReveal = i === 0 ? _this.reveal : false;\n          return _this.steps.push({\n            expression: expression,\n            selector: selector,\n            pseudoClass: pseudoClass,\n            transition: _this.transition,\n            origin: _this.origin,\n            reveal: doReveal\n          });\n        };\n      })(this));\n    };\n\n    ExtractPlan.prototype.addHungrySteps = function() {\n      var hungries, hungry, hungrySteps, j, len, newHungry, ref, selector, transition;\n      hungrySteps = [];\n      if (this.hungry) {\n        hungries = e.all(up.radio.hungrySelector());\n        transition = (ref = up.radio.config.hungryTransition) != null ? ref : this.transition;\n        for (j = 0, len = hungries.length; j < len; j++) {\n          hungry = hungries[j];\n          selector = e.toSelector(hungry);\n          if (newHungry = this.response.first(selector)) {\n            hungrySteps.push({\n              selector: selector,\n              oldElement: hungry,\n              newElement: newHungry,\n              transition: transition,\n              reveal: false,\n              origin: null\n            });\n          }\n        }\n      }\n      return this.addSteps(hungrySteps);\n    };\n\n    return ExtractPlan;\n\n  })();\n\n}).call(this);\n(function() {\n  var e, u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  e = up.element;\n\n  up.FieldObserver = (function() {\n    function FieldObserver(fieldOrFields, options, callback) {\n      this.callback = callback;\n      this.check = bind(this.check, this);\n      this.readFieldValues = bind(this.readFieldValues, this);\n      this.requestCallback = bind(this.requestCallback, this);\n      this.isNewValues = bind(this.isNewValues, this);\n      this.scheduleValues = bind(this.scheduleValues, this);\n      this.scheduleTimer = bind(this.scheduleTimer, this);\n      this.cancelTimer = bind(this.cancelTimer, this);\n      this.stop = bind(this.stop, this);\n      this.start = bind(this.start, this);\n      this.fields = e.list(fieldOrFields);\n      this.delay = options.delay;\n      this.batch = options.batch;\n    }\n\n    FieldObserver.prototype.start = function() {\n      this.scheduledValues = null;\n      this.processedValues = this.readFieldValues();\n      this.currentTimer = void 0;\n      this.callbackRunning = false;\n      return this.unbind = up.on(this.fields, 'input change', this.check);\n    };\n\n    FieldObserver.prototype.stop = function() {\n      this.unbind();\n      return this.cancelTimer();\n    };\n\n    FieldObserver.prototype.cancelTimer = function() {\n      clearTimeout(this.currentTimer);\n      return this.currentTimer = void 0;\n    };\n\n    FieldObserver.prototype.scheduleTimer = function() {\n      this.cancelTimer();\n      return this.currentTimer = u.timer(this.delay, (function(_this) {\n        return function() {\n          _this.currentTimer = void 0;\n          return _this.requestCallback();\n        };\n      })(this));\n    };\n\n    FieldObserver.prototype.scheduleValues = function(values) {\n      this.scheduledValues = values;\n      return this.scheduleTimer();\n    };\n\n    FieldObserver.prototype.isNewValues = function(values) {\n      return !u.isEqual(values, this.processedValues) && !u.isEqual(this.scheduledValues, values);\n    };\n\n    FieldObserver.prototype.requestCallback = function() {\n      var callbackReturnValues, callbacksDone, diff, name, value;\n      if (this.scheduledValues !== null && !this.currentTimer && !this.callbackRunning) {\n        diff = this.changedValues(this.processedValues, this.scheduledValues);\n        this.processedValues = this.scheduledValues;\n        this.scheduledValues = null;\n        this.callbackRunning = true;\n        callbackReturnValues = [];\n        if (this.batch) {\n          callbackReturnValues.push(this.callback(diff));\n        } else {\n          for (name in diff) {\n            value = diff[name];\n            callbackReturnValues.push(this.callback(value, name));\n          }\n        }\n        callbacksDone = Promise.all(callbackReturnValues);\n        return u.always(callbacksDone, (function(_this) {\n          return function() {\n            _this.callbackRunning = false;\n            return _this.requestCallback();\n          };\n        })(this));\n      }\n    };\n\n    FieldObserver.prototype.changedValues = function(previous, next) {\n      var changes, i, key, keys, len, nextValue, previousValue;\n      changes = {};\n      keys = Object.keys(previous);\n      keys = keys.concat(Object.keys(next));\n      keys = u.uniq(keys);\n      for (i = 0, len = keys.length; i < len; i++) {\n        key = keys[i];\n        previousValue = previous[key];\n        nextValue = next[key];\n        if (!u.isEqual(previousValue, nextValue)) {\n          changes[key] = nextValue;\n        }\n      }\n      return changes;\n    };\n\n    FieldObserver.prototype.readFieldValues = function() {\n      return up.Params.fromFields(this.fields).toObject();\n    };\n\n    FieldObserver.prototype.check = function() {\n      var values;\n      values = this.readFieldValues();\n      if (this.isNewValues(values)) {\n        return this.scheduleValues(values);\n      }\n    };\n\n    return FieldObserver;\n\n  })();\n\n}).call(this);\n(function() {\n\n\n}).call(this);\n(function() {\n  var e, u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    slice = [].slice;\n\n  u = up.util;\n\n  e = up.element;\n\n  up.FollowVariant = (function() {\n    function FollowVariant(selector, options) {\n      this.matchesLink = bind(this.matchesLink, this);\n      this.followLink = bind(this.followLink, this);\n      this.fullSelector = bind(this.fullSelector, this);\n      this.onMousedown = bind(this.onMousedown, this);\n      this.onClick = bind(this.onClick, this);\n      this.followNow = options.follow;\n      this.preloadLink = options.preload;\n      this.selectors = u.splitValues(selector, ',');\n    }\n\n    FollowVariant.prototype.onClick = function(event, link) {\n      if (up.link.shouldProcessEvent(event, link)) {\n        if (e.matches(link, '[up-instant]') && link.upInstantSupported) {\n          up.event.halt(event);\n          link.upInstantSupported = false;\n        } else {\n          up.event.consumeAction(event);\n          return this.followLink(link);\n        }\n      } else {\n        return up.link.allowDefault(event);\n      }\n    };\n\n    FollowVariant.prototype.onMousedown = function(event, link) {\n      if (up.link.shouldProcessEvent(event, link)) {\n        link.upInstantSupported = true;\n        up.event.consumeAction(event);\n        return this.followLink(link);\n      }\n    };\n\n    FollowVariant.prototype.fullSelector = function(additionalClause) {\n      var parts;\n      if (additionalClause == null) {\n        additionalClause = '';\n      }\n      parts = [];\n      this.selectors.forEach(function(variantSelector) {\n        var i, len, ref, results, tagSelector;\n        ref = ['a', '[up-href]'];\n        results = [];\n        for (i = 0, len = ref.length; i < len; i++) {\n          tagSelector = ref[i];\n          results.push(parts.push(\"\" + tagSelector + variantSelector + additionalClause));\n        }\n        return results;\n      });\n      return parts.join(', ');\n    };\n\n    FollowVariant.prototype.registerEvents = function() {\n      up.on('click', this.fullSelector(), (function(_this) {\n        return function() {\n          var args;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return u.muteRejection(_this.onClick.apply(_this, args));\n        };\n      })(this));\n      return up.on('mousedown', this.fullSelector('[up-instant]'), (function(_this) {\n        return function() {\n          var args;\n          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n          return u.muteRejection(_this.onMousedown.apply(_this, args));\n        };\n      })(this));\n    };\n\n    FollowVariant.prototype.followLink = function(link, options) {\n      var promise;\n      if (options == null) {\n        options = {};\n      }\n      promise = up.event.whenEmitted('up:link:follow', {\n        log: 'Following link',\n        target: link\n      });\n      promise = promise.then((function(_this) {\n        return function() {\n          if (!options.preload) {\n            up.feedback.start(link);\n          }\n          return _this.followNow(link, options);\n        };\n      })(this));\n      if (!options.preload) {\n        u.always(promise, function() {\n          return up.feedback.stop(link);\n        });\n      }\n      return promise;\n    };\n\n    FollowVariant.prototype.matchesLink = function(link) {\n      return e.matches(link, this.fullSelector());\n    };\n\n    return FollowVariant;\n\n  })();\n\n}).call(this);\n(function() {\n  var e, u;\n\n  u = up.util;\n\n  e = up.element;\n\n  up.HtmlParser = (function() {\n    function HtmlParser(html) {\n      this.html = html;\n      this.wrapNoscriptInHtml();\n      this.parsedDoc = e.createDocumentFromHtml(this.html);\n    }\n\n    HtmlParser.prototype.title = function() {\n      var ref;\n      return (ref = this.parsedDoc.querySelector(\"head title\")) != null ? ref.textContent : void 0;\n    };\n\n    HtmlParser.prototype.first = function(selector) {\n      return e.first(this.parsedDoc, selector);\n    };\n\n    HtmlParser.prototype.prepareForInsertion = function(element) {\n      return this.unwrapNoscriptInElement(element);\n    };\n\n    HtmlParser.prototype.wrapNoscriptInHtml = function() {\n      var noscriptPattern;\n      noscriptPattern = /<noscript[^>]*>((.|\\s)*?)<\\/noscript>/ig;\n      return this.html = this.html.replace(noscriptPattern, (function(_this) {\n        return function(match, content) {\n          _this.didWrapNoscript = true;\n          return '<div class=\"up-noscript\" data-html=\"' + u.escapeHtml(content) + '\"></div>';\n        };\n      })(this));\n    };\n\n    HtmlParser.prototype.unwrapNoscriptInElement = function(element) {\n      var i, len, noscript, results, wrappedContent, wrappedNoscript, wrappedNoscripts;\n      if (!this.didWrapNoscript) {\n        return;\n      }\n      wrappedNoscripts = element.querySelectorAll('.up-noscript');\n      results = [];\n      for (i = 0, len = wrappedNoscripts.length; i < len; i++) {\n        wrappedNoscript = wrappedNoscripts[i];\n        wrappedContent = wrappedNoscript.getAttribute('data-html');\n        noscript = document.createElement('noscript');\n        noscript.textContent = wrappedContent;\n        results.push(wrappedNoscript.parentNode.replaceChild(noscript, wrappedNoscript));\n      }\n      return results;\n    };\n\n    return HtmlParser;\n\n  })();\n\n}).call(this);\n(function() {\n  var e, u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  e = up.element;\n\n  up.MotionController = (function() {\n    function MotionController(name) {\n      this.reset = bind(this.reset, this);\n      this.whileForwardingFinishEvent = bind(this.whileForwardingFinishEvent, this);\n      this.unmarkCluster = bind(this.unmarkCluster, this);\n      this.markCluster = bind(this.markCluster, this);\n      this.whenElementFinished = bind(this.whenElementFinished, this);\n      this.emitFinishEvent = bind(this.emitFinishEvent, this);\n      this.finishOneElement = bind(this.finishOneElement, this);\n      this.isActive = bind(this.isActive, this);\n      this.expandFinishRequest = bind(this.expandFinishRequest, this);\n      this.finish = bind(this.finish, this);\n      this.startFunction = bind(this.startFunction, this);\n      this.activeClass = \"up-\" + name;\n      this.dataKey = \"up-\" + name + \"-finished\";\n      this.selector = \".\" + this.activeClass;\n      this.finishEvent = \"up:\" + name + \":finish\";\n      this.finishCount = 0;\n      this.clusterCount = 0;\n    }\n\n\n    /***\n    Finishes all animations in the given elements' ancestors and\n    descendants, then calls the given function.\n    \n    The function is expected to return a promise that is fulfilled when\n    the animation ends. The function is also expected to listen to\n    `this.finishEvent` and instantly skip to the last frame\n    when the event is observed.\n    \n    The animation is tracked so it can be\n    [`finished`](/up.MotionController.finish) later.\n    \n    @method startFunction\n    @param {Element|List<Element>} cluster\n      A list of elements that will be affected by the motion.\n    @param {Function(): Promise} startMotion\n    @param {Object} [memory.trackMotion=true]\n    @return {Promise}\n      A promise that is fulfilled when the animation ends.\n     */\n\n    MotionController.prototype.startFunction = function(cluster, startMotion, memory) {\n      var mutedAnimator, ref;\n      if (memory == null) {\n        memory = {};\n      }\n      cluster = e.list(cluster);\n      mutedAnimator = function() {\n        return u.muteRejection(startMotion());\n      };\n      memory.trackMotion = (ref = memory.trackMotion) != null ? ref : up.motion.isEnabled();\n      if (memory.trackMotion === false) {\n        return u.microtask(mutedAnimator);\n      } else {\n        memory.trackMotion = false;\n        return this.finish(cluster).then((function(_this) {\n          return function() {\n            var promise;\n            promise = _this.whileForwardingFinishEvent(cluster, mutedAnimator);\n            promise = promise.then(function() {\n              return _this.unmarkCluster(cluster);\n            });\n            _this.markCluster(cluster, promise);\n            return promise;\n          };\n        })(this));\n      }\n    };\n\n\n    /**\n    Finishes all animations in the given elements' ancestors and\n    descendants, then calls `motion.start()`.\n    \n    Also listens to `this.finishEvent` on the given elements.\n    When this event is observed, calls `motion.finish()`.\n    \n    @method startMotion\n    @param {Element|List<Element>} cluster\n    @param {up.Motion} motion\n    @param {Object} [memory.trackMotion=true]\n     */\n\n    MotionController.prototype.startMotion = function(cluster, motion, memory) {\n      var finish, promise, start, unbindFinish;\n      if (memory == null) {\n        memory = {};\n      }\n      start = function() {\n        return motion.start();\n      };\n      finish = function() {\n        return motion.finish();\n      };\n      unbindFinish = up.on(cluster, this.finishEvent, finish);\n      promise = this.startFunction(cluster, start, memory);\n      promise = promise.then(unbindFinish);\n      return promise;\n    };\n\n\n    /***\n    @method finish\n    @param {List<Element>} [elements]\n      If no element is given, finishes all animations in the documnet.\n      If an element is given, only finishes animations in its subtree and ancestors.\n    @return {Promise} A promise that is fulfilled when animations have finished.\n     */\n\n    MotionController.prototype.finish = function(elements) {\n      var allFinished;\n      this.finishCount++;\n      if (this.clusterCount === 0 || !up.motion.isEnabled()) {\n        return Promise.resolve();\n      }\n      elements = this.expandFinishRequest(elements);\n      allFinished = u.map(elements, this.finishOneElement);\n      return Promise.all(allFinished);\n    };\n\n    MotionController.prototype.expandFinishRequest = function(elements) {\n      if (elements) {\n        return u.flatMap(elements, (function(_this) {\n          return function(el) {\n            return e.list(e.closest(el, _this.selector), e.all(el, _this.selector));\n          };\n        })(this));\n      } else {\n        return e.all(this.selector);\n      }\n    };\n\n    MotionController.prototype.isActive = function(element) {\n      return element.classList.contains(this.activeClass);\n    };\n\n    MotionController.prototype.finishOneElement = function(element) {\n      this.emitFinishEvent(element);\n      return this.whenElementFinished(element);\n    };\n\n    MotionController.prototype.emitFinishEvent = function(element, eventAttrs) {\n      if (eventAttrs == null) {\n        eventAttrs = {};\n      }\n      eventAttrs = u.merge({\n        target: element,\n        log: false\n      }, eventAttrs);\n      return up.emit(this.finishEvent, eventAttrs);\n    };\n\n    MotionController.prototype.whenElementFinished = function(element) {\n      return element[this.dataKey] || Promise.resolve();\n    };\n\n    MotionController.prototype.markCluster = function(cluster, promise) {\n      var element, i, len, results;\n      this.clusterCount++;\n      results = [];\n      for (i = 0, len = cluster.length; i < len; i++) {\n        element = cluster[i];\n        element.classList.add(this.activeClass);\n        results.push(element[this.dataKey] = promise);\n      }\n      return results;\n    };\n\n    MotionController.prototype.unmarkCluster = function(cluster) {\n      var element, i, len, results;\n      this.clusterCount--;\n      results = [];\n      for (i = 0, len = cluster.length; i < len; i++) {\n        element = cluster[i];\n        element.classList.remove(this.activeClass);\n        results.push(delete element[this.dataKey]);\n      }\n      return results;\n    };\n\n    MotionController.prototype.whileForwardingFinishEvent = function(cluster, fn) {\n      var doForward, unbindFinish;\n      if (cluster.length < 2) {\n        return fn();\n      }\n      doForward = (function(_this) {\n        return function(event) {\n          if (!event.forwarded) {\n            return u.each(cluster, function(element) {\n              if (element !== event.target && _this.isActive(element)) {\n                return _this.emitFinishEvent(element, {\n                  forwarded: true\n                });\n              }\n            });\n          }\n        };\n      })(this);\n      unbindFinish = up.on(cluster, this.finishEvent, doForward);\n      return fn().then(unbindFinish);\n    };\n\n    MotionController.prototype.reset = function() {\n      return this.finish().then((function(_this) {\n        return function() {\n          _this.finishCount = 0;\n          return _this.clusterCount = 0;\n        };\n      })(this));\n    };\n\n    return MotionController;\n\n  })();\n\n}).call(this);\n(function() {\n  var e, u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  e = up.element;\n\n\n  /***\n  The `up.Params` class offers a consistent API to read and manipulate request parameters\n  independent of their type.\n  \n  Request parameters are used in [form submissions](/up.Params#fromForm) and\n  [URLs](/up.Params#fromURL). Methods like `up.submit()` or `up.replace()` accept\n  request parameters as a `{ params }` option.\n  \n  \\#\\#\\# Supported parameter types\n  \n  The following types of parameter representation are supported:\n  \n  1. An object like `{ email: 'foo@bar.com' }`\n  2. A query string like `'email=foo%40bar.com'`\n  3. An array of `{ name, value }` objects like `[{ name: 'email', value: 'foo@bar.com' }]`\n  4. A [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object.\n     On IE 11 and Edge, `FormData` payloads require a [polyfill for `FormData#entries()`](https://github.com/jimmywarting/FormData).\n  \n  @class up.Params\n   */\n\n  up.Params = (function() {\n\n    /***\n    Constructs a new `up.Params` instance.\n    \n    @constructor up.Params\n    @param {Object|Array|string|up.Params} [params]\n      An existing list of params with which to initialize the new `up.Params` object.\n    \n      The given params value may be of any [supported type](/up.Params).\n    @return {up.Params}\n    @experimental\n     */\n    function Params(raw) {\n      this.arrayEntryToQuery = bind(this.arrayEntryToQuery, this);\n      this.clear();\n      this.addAll(raw);\n    }\n\n\n    /***\n    Removes all params from this object.\n    \n    @method up.Params#clear\n    @experimental\n     */\n\n    Params.prototype.clear = function() {\n      return this.entries = [];\n    };\n\n    Params.prototype[\"\" + u.copy.key] = function() {\n      return new up.Params(this);\n    };\n\n\n    /***\n    Returns an object representation of this `up.Params` instance.\n    \n    The returned value is a simple JavaScript object with properties\n    that correspond to the key/values in the given `params`.\n    \n    \\#\\#\\# Example\n    \n        var params = new up.Params('foo=bar&baz=bam')\n        var object = params.toObject()\n    \n        // object is now: {\n        //   foo: 'bar',\n        //   baz: 'bam'\n        // ]\n    \n    @function up.Params#toObject\n    @return {Object}\n    @experimental\n     */\n\n    Params.prototype.toObject = function() {\n      var entry, i, len, name, obj, ref, value;\n      obj = {};\n      ref = this.entries;\n      for (i = 0, len = ref.length; i < len; i++) {\n        entry = ref[i];\n        name = entry.name, value = entry.value;\n        if (!u.isBasicObjectProperty(name)) {\n          if (this.isArrayKey(name)) {\n            obj[name] || (obj[name] = []);\n            obj[name].push(value);\n          } else {\n            obj[name] = value;\n          }\n        }\n      }\n      return obj;\n    };\n\n\n    /***\n    Returns an array representation of this `up.Params` instance.\n    \n    The returned value is a JavaScript array with elements that are objects with\n    `{ key }` and `{ value }` properties.\n    \n    \\#\\#\\# Example\n    \n        var params = new up.Params('foo=bar&baz=bam')\n        var array = params.toArray()\n    \n        // array is now: [\n        //   { name: 'foo', value: 'bar' },\n        //   { name: 'baz', value: 'bam' }\n        // ]\n    \n    @function up.Params#toArray\n    @return {Array}\n    @experimental\n     */\n\n    Params.prototype.toArray = function() {\n      return this.entries;\n    };\n\n\n    /***\n    Returns a [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) representation\n    of this `up.Params` instance.\n    \n    \\#\\#\\# Example\n    \n        var params = new up.Params('foo=bar&baz=bam')\n        var formData = params.toFormData()\n    \n        formData.get('foo') // 'bar'\n        formData.get('baz') // 'bam'\n    \n    @function up.Params#toFormData\n    @return {FormData}\n    @experimental\n     */\n\n    Params.prototype.toFormData = function() {\n      var entry, formData, i, len, ref;\n      formData = new FormData();\n      ref = this.entries;\n      for (i = 0, len = ref.length; i < len; i++) {\n        entry = ref[i];\n        formData.append(entry.name, entry.value);\n      }\n      return formData;\n    };\n\n\n    /***\n    Returns an [query string](https://en.wikipedia.org/wiki/Query_string) for this `up.Params` instance.\n    \n    The keys and values in the returned query string will be [percent-encoded](https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding).\n    Non-primitive values (like [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) will be omitted from\n    the retuned query string.\n    \n    \\#\\#\\# Example\n    \n        var params = new up.Params({ foo: 'bar', baz: 'bam' })\n        var query = params.toQuery()\n    \n        // query is now: 'foo=bar&baz=bam'\n    \n    @function up.Params#toQuery\n    @param {Object|FormData|string|Array|undefined} params\n      the params to convert\n    @return {string}\n      a query string built from the given params\n    @experimental\n     */\n\n    Params.prototype.toQuery = function() {\n      var parts;\n      parts = u.map(this.entries, this.arrayEntryToQuery);\n      parts = u.compact(parts);\n      return parts.join('&');\n    };\n\n    Params.prototype.arrayEntryToQuery = function(entry) {\n      var query, value;\n      value = entry.value;\n      if (!this.isPrimitiveValue(value)) {\n        return void 0;\n      }\n      query = encodeURIComponent(entry.name);\n      if (u.isGiven(value)) {\n        query += \"=\";\n        query += encodeURIComponent(value);\n      }\n      return query;\n    };\n\n\n    /***\n    Returns whether the given value can be encoded into a query string.\n    \n    We will have `File` values in our params when we serialize a form with a file input.\n    These entries will be filtered out when converting to a query string.\n    \n    @function up.Params#isPrimitiveValue\n    @internal\n     */\n\n    Params.prototype.isPrimitiveValue = function(value) {\n      return u.isMissing(value) || u.isString(value) || u.isNumber(value) || u.isBoolean(value);\n    };\n\n\n    /***\n    Builds an URL string from the given base URL and\n    this `up.Params` instance as a [query string](/up.Params.toString).\n    \n    The base URL may or may not already contain a query string. The\n    additional query string will be joined with an `&` or `?` character accordingly.\n    \n    @function up.Params#toURL\n    @param {string} base\n      The base URL that will be prepended to this `up.Params` object as a [query string](/up.Params.toString).\n    @return {string}\n      The built URL.\n    @experimental\n     */\n\n    Params.prototype.toURL = function(base) {\n      var parts, separator;\n      parts = [base, this.toQuery()];\n      parts = u.filter(parts, u.isPresent);\n      separator = u.contains(base, '?') ? '&' : '?';\n      return parts.join(separator);\n    };\n\n\n    /***\n    Adds a new entry with the given `name` and `value`.\n    \n    An `up.Params` instance can hold multiple entries with the same name.\n    To overwrite all existing entries with the given `name`, use `up.Params#set()` instead.\n    \n    \\#\\#\\# Example\n    \n        var params = new up.Params()\n        params.add('foo', 'fooValue')\n    \n        var foo = params.get('foo')\n        // foo is now 'fooValue'\n    \n    @function up.Params#add\n    @param {string} name\n      The name of the new entry.\n    @param {any} value\n      The value of the new entry.\n    @experimental\n     */\n\n    Params.prototype.add = function(name, value) {\n      return this.entries.push({\n        name: name,\n        value: value\n      });\n    };\n\n\n    /***\n    Adds all entries from the given list of params.\n    \n    The given params value may be of any [supported type](/up.Params).\n    \n    @function up.Params#addAll\n    @param {Object|Array|string|up.Params|undefined} params\n    @experimental\n     */\n\n    Params.prototype.addAll = function(raw) {\n      var ref, ref1;\n      if (u.isMissing(raw)) {\n\n      } else if (raw instanceof this.constructor) {\n        (ref = this.entries).push.apply(ref, raw.entries);\n      } else if (u.isArray(raw)) {\n        (ref1 = this.entries).push.apply(ref1, raw);\n      } else if (u.isString(raw)) {\n        this.addAllFromQuery(raw);\n      } else if (u.isFormData(raw)) {\n        this.addAllFromFormData(raw);\n      } else if (u.isObject(raw)) {\n        this.addAllFromObject(raw);\n      } else {\n        up.fail(\"Unsupport params type: %o\", raw);\n      }\n      return this;\n    };\n\n    Params.prototype.addAllFromObject = function(object) {\n      var key, results, value, valueElement, valueElements;\n      results = [];\n      for (key in object) {\n        value = object[key];\n        valueElements = u.isArray(value) ? value : [value];\n        results.push((function() {\n          var i, len, results1;\n          results1 = [];\n          for (i = 0, len = valueElements.length; i < len; i++) {\n            valueElement = valueElements[i];\n            results1.push(this.add(key, valueElement));\n          }\n          return results1;\n        }).call(this));\n      }\n      return results;\n    };\n\n    Params.prototype.addAllFromQuery = function(query) {\n      var i, len, name, part, ref, ref1, results, value;\n      ref = query.split('&');\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        part = ref[i];\n        if (part) {\n          ref1 = part.split('='), name = ref1[0], value = ref1[1];\n          name = decodeURIComponent(name);\n          if (u.isGiven(value)) {\n            value = decodeURIComponent(value);\n          } else {\n            value = null;\n          }\n          results.push(this.add(name, value));\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n    Params.prototype.addAllFromFormData = function(formData) {\n      return u.eachIterator(formData.entries(), (function(_this) {\n        return function(value) {\n          return _this.add.apply(_this, value);\n        };\n      })(this));\n    };\n\n\n    /***\n    Sets the `value` for the entry with given `name`.\n    \n    An `up.Params` instance can hold multiple entries with the same name.\n    All existing entries with the given `name` are [deleted](/up.Params#delete) before the\n    new entry is set. To add a new entry even if the `name` is taken, use `up.Params#add()`.\n    \n    @function up.Params#set\n    @param {string} name\n      The name of the entry to set.\n    @param {any} value\n      The new value of the entry.\n    @experimental\n     */\n\n    Params.prototype.set = function(name, value) {\n      this[\"delete\"](name);\n      return this.add(name, value);\n    };\n\n\n    /***\n    Deletes all entries with the given `name`.\n    \n    @function up.Params#delete\n    @param {string} name\n    @experimental\n     */\n\n    Params.prototype[\"delete\"] = function(name) {\n      return this.entries = u.reject(this.entries, this.matchEntryFn(name));\n    };\n\n    Params.prototype.matchEntryFn = function(name) {\n      return function(entry) {\n        return entry.name === name;\n      };\n    };\n\n\n    /***\n    Returns the first param value with the given `name` from the given `params`.\n    \n    Returns `undefined` if no param value with that name is set.\n    \n    If the `name` denotes an array field (e.g. `foo[]`), *all* param values with the given `name`\n    are returned as an array. If no param value with that array name is set, an empty\n    array is returned.\n    \n    To always return a single value use `up.Params#getFirst()` instead.\n    To always return an array of values use `up.Params#getAll()` instead.\n    \n    \\#\\#\\# Example\n    \n        var params = new up.Params({ foo: 'fooValue', bar: 'barValue' })\n        var params = new up.Params([\n          { name: 'foo', value: 'fooValue' }\n          { name: 'bar[]', value: 'barValue1' }\n          { name: 'bar[]', value: 'barValue2' })\n        ]})\n    \n        var foo = params.get('foo')\n        // foo is now 'fooValue'\n    \n        var bar = params.get('bar')\n        // bar is now ['barValue1', 'barValue2']\n    \n    @function up.Params#get\n    @param {string} name\n    @experimental\n     */\n\n    Params.prototype.get = function(name) {\n      if (this.isArrayKey(name)) {\n        return this.getAll(name);\n      } else {\n        return this.getFirst(name);\n      }\n    };\n\n\n    /***\n    Returns the first param value with the given `name`.\n    \n    Returns `undefined` if no param value with that name is set.\n    \n    @function up.Params#getFirst\n    @param {string} name\n    @return {any}\n      The value of the param with the given name.\n     */\n\n    Params.prototype.getFirst = function(name) {\n      var entry;\n      entry = u.find(this.entries, this.matchEntryFn(name));\n      return entry != null ? entry.value : void 0;\n    };\n\n\n    /***\n    Returns an array of all param values with the given `name`.\n    \n    Returns an empty array if no param value with that name is set.\n    \n    @function up.Params#getAll\n    @param {string} name\n    @return {Array}\n      An array of all values with the given name.\n     */\n\n    Params.prototype.getAll = function(name) {\n      var entries;\n      if (this.isArrayKey(name)) {\n        return this.getAll(name);\n      } else {\n        entries = u.map(this.entries, this.matchEntryFn(name));\n        return u.map(entries, 'value');\n      }\n    };\n\n    Params.prototype.isArrayKey = function(key) {\n      return u.endsWith(key, '[]');\n    };\n\n    Params.prototype[\"\" + u.isBlank.key] = function() {\n      return this.entries.length === 0;\n    };\n\n\n    /***\n    Constructs a new `up.Params` instance from the given `<form>`.\n    \n    The returned params may be passed as `{ params }` option to\n    [`up.request()`](/up.request) or [`up.replace()`](/up.replace).\n    \n    The constructed `up.Params` will include exactly those form values that would be\n    included in a regular form submission. In particular:\n    \n    - All `<input>` types are suppported\n    - Field values are usually strings, but an `<input type=\"file\">` will produce\n      [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) values.\n    - An `<input type=\"radio\">` or `<input type=\"checkbox\">` will only be added if they are `[checked]`.\n    - An `<select>` will only be added if at least one value is `[checked]`.\n    - If passed a `<select multiple>` or `<input type=\"file\" multiple>`, all selected values are added.\n      If passed a `<select multiple>`, all selected values are added.\n    - Fields that are `[disabled]` are ignored\n    - Fields without a `[name]` attribute are ignored.\n    - The serialized params will include the form's submit button, if that\n      button as a `name` attribute.\n    \n    \\#\\#\\# Example\n    \n    Given this HTML form:\n    \n        <form>\n          <input type=\"text\" name=\"email\" value=\"foo@bar.com\">\n          <input type=\"password\" name=\"pass\" value=\"secret\">\n        </form>\n    \n    This would serialize the form into an array representation:\n    \n        var params = up.Params.fromForm('input[name=email]')\n        var email = params.get('email') // email is now 'foo@bar.com'\n        var pass = params.get('pass') // pass is now 'secret'\n    \n    @function up.Params.fromForm\n    @param {Element|jQuery|string} form\n      A `<form>` element or a selector that matches a `<form>` element.\n    @return {up.Params}\n      A new `up.Params` instance with values from the given form.\n    @experimental\n     */\n\n    Params.fromForm = function(form) {\n      var fields;\n      if (form = e.get(form)) {\n        fields = up.form.submissionFields(form);\n        return this.fromFields(fields);\n      }\n    };\n\n\n    /***\n    Constructs a new `up.Params` instance from one or more\n    [HTML form field](https://www.w3schools.com/html/html_form_elements.asp).\n    \n    The constructed `up.Params` will include exactly those form values that would be\n    included for the given fields in a regular form submission. If a given field wouldn't\n    submit a value (like an unchecked `<input type=\"checkbox\">`, nothing will be added.\n    \n    See `up.Params.fromForm()` for more details and examples.\n    \n    @function up.Params.fromFields\n    @param {Element|List<Element>|jQuery} fields\n    @return {up.Params}\n    @experimental\n     */\n\n    Params.fromFields = function(fields) {\n      var field, i, len, params, ref;\n      params = new this();\n      ref = u.wrapList(fields);\n      for (i = 0, len = ref.length; i < len; i++) {\n        field = ref[i];\n        params.addField(field);\n      }\n      return params;\n    };\n\n\n    /***\n    Adds params from the given [HTML form field](https://www.w3schools.com/html/html_form_elements.asp).\n    \n    The added params will include exactly those form values that would be\n    included for the given field in a regular form submission. If the given field wouldn't\n      submit a value (like an unchecked `<input type=\"checkbox\">`, nothing will be added.\n    \n    See `up.Params.fromForm()` for more details and examples.\n    \n    @function up.Params#addField\n    @param {Element|jQuery} field\n    @experimental\n     */\n\n    Params.prototype.addField = function(field) {\n      var file, i, j, len, len1, name, option, params, ref, ref1, results, results1, tagName, type;\n      params = new this.constructor();\n      if ((field = e.get(field)) && (name = field.name) && (!field.disabled)) {\n        tagName = field.tagName;\n        type = field.type;\n        if (tagName === 'SELECT') {\n          ref = field.querySelectorAll('option');\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            option = ref[i];\n            if (option.selected) {\n              results.push(this.add(name, option.value));\n            } else {\n              results.push(void 0);\n            }\n          }\n          return results;\n        } else if (type === 'checkbox' || type === 'radio') {\n          if (field.checked) {\n            return this.add(name, field.value);\n          }\n        } else if (type === 'file') {\n          ref1 = field.files;\n          results1 = [];\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            file = ref1[j];\n            results1.push(this.add(name, file));\n          }\n          return results1;\n        } else {\n          return this.add(name, field.value);\n        }\n      }\n    };\n\n    Params.prototype[\"\" + u.isEqual.key] = function(other) {\n      return other && (this.constructor === other.constructor) && u.isEqual(this.entries, other.entries);\n    };\n\n\n    /***\n    Constructs a new `up.Params` instance from the given URL's\n    [query string](https://en.wikipedia.org/wiki/Query_string).\n    \n    Constructs an empty `up.Params` instance if the given URL has no query string.\n    \n    \\#\\#\\# Example\n    \n        var params = up.Params.fromURL('http://foo.com?foo=fooValue&bar=barValue')\n        var foo = params.get('foo')\n        // foo is now: 'fooValue'\n    \n    @function up.Params.fromURL\n    @param {string} url\n      The URL from which to extract the query string.\n    @return {string|undefined}\n      The given URL's query string, or `undefined` if the URL has no query component.\n    @experimental\n     */\n\n    Params.fromURL = function(url) {\n      var params, query, urlParts;\n      params = new this();\n      urlParts = u.parseUrl(url);\n      if (query = urlParts.search) {\n        query = query.replace(/^\\?/, '');\n        params.addAll(query);\n      }\n      return params;\n    };\n\n\n    /***\n    Returns the given URL without its [query string](https://en.wikipedia.org/wiki/Query_string).\n    \n    \\#\\#\\# Example\n    \n        var url = up.Params.stripURL('http://foo.com?key=value')\n        // url is now: 'http://foo.com'\n    \n    @function up.Params.stripURL\n    @param {string} url\n      A URL (with or without a query string).\n    @return {string}\n      The given URL without its query string.\n    @experimental\n     */\n\n    Params.stripURL = function(url) {\n      return u.normalizeUrl(url, {\n        search: false\n      });\n    };\n\n\n    /***\n    If passed an `up.Params` instance, it is returned unchanged.\n    Otherwise constructs an `up.Params` instance from the given value.\n    \n    The given params value may be of any [supported type](/up.Params)\n    The return value is always an `up.Params` instance.\n    \n    @function up.Params.wrap\n    @param {Object|Array|string|up.Params|undefined} params\n    @return {up.Params}\n     */\n\n    Params.wrap = function(value) {\n      return u.wrapValue(value, this);\n    };\n\n    return Params;\n\n  })();\n\n}).call(this);\n(function() {\n  var u = up.util\n\n  up.Rect = function(props) {\n    u.assign(this, u.only(props, 'left', 'top', 'width', 'height'))\n  }\n\n  up.Rect.prototype = {\n    get bottom() {\n      return this.top + this.height\n    },\n    get right() {\n      return this.left + this.width\n    }\n  }\n\n  up.Rect.fromElement = function(element) {\n    return new up.Rect(element.getBoundingClientRect())\n  }\n\n})()\n;\n(function() {\n  var e, u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  u = up.util;\n\n  e = up.element;\n\n\n  /***\n  Instances of `up.Request` normalizes properties of an [`AJAX request`](/up.request)\n  such as the requested URL, form parameters and HTTP method.\n  \n  @class up.Request\n   */\n\n  up.Request = (function(superClass) {\n    extend(Request, superClass);\n\n\n    /***\n    The HTTP method for the request.\n    \n    @property up.Request#method\n    @param {string} method\n    @stable\n     */\n\n\n    /***\n    The URL for the request.\n    \n    @property up.Request#url\n    @param {string} url\n    @stable\n     */\n\n\n    /***\n    [Parameters](/up.Params) that should be sent as the request's payload.\n    \n    @property up.Request#params\n    @param {Object|FormData|string|Array} params\n    @stable\n     */\n\n\n    /***\n    The CSS selector that will be sent as an [`X-Up-Target` header](/up.protocol#optimizing-responses).\n    \n    @property up.Request#target\n    @param {string} target\n    @stable\n     */\n\n\n    /***\n    The CSS selector that will be sent as an [`X-Up-Fail-Target` header](/up.protocol#optimizing-responses).\n    \n    @property up.Request#failTarget\n    @param {string} failTarget\n    @stable\n     */\n\n\n    /***\n    An object of additional HTTP headers.\n    \n    @property up.Request#headers\n    @param {Object} headers\n    @stable\n     */\n\n\n    /***\n    A timeout in milliseconds.\n    \n    If [`up.proxy.config.maxRequests`](/up.proxy.config#config.maxRequests) is set,\n    the timeout will not include the time spent waiting in the queue.\n    \n    @property up.Request#timeout\n    @param {Object|undefined} timeout\n    @stable\n     */\n\n    Request.prototype.fields = function() {\n      return ['method', 'url', 'params', 'target', 'failTarget', 'headers', 'timeout', 'preload', 'cache'];\n    };\n\n\n    /***\n    Creates a new `up.Request` object.\n    \n    This will not actually send the request over the network. For that use `up.request()`.\n    \n    @constructor up.Request\n    @param {string} attrs.url\n    @param {string} [attrs.method='get']\n    @param {up.Params|string|Object|Array} [attrs.params]\n    @param {string} [attrs.target]\n    @param {string} [attrs.failTarget]\n    @param {Object<string, string>} [attrs.headers]\n    @param {number} [attrs.timeout]\n    @internal\n     */\n\n    function Request(options) {\n      this.cacheKey = bind(this.cacheKey, this);\n      this.isCachable = bind(this.isCachable, this);\n      this.buildResponse = bind(this.buildResponse, this);\n      this.isCrossDomain = bind(this.isCrossDomain, this);\n      this.csrfToken = bind(this.csrfToken, this);\n      this.navigate = bind(this.navigate, this);\n      this.send = bind(this.send, this);\n      this.isSafe = bind(this.isSafe, this);\n      this.transferSearchToParams = bind(this.transferSearchToParams, this);\n      this.transferParamsToUrl = bind(this.transferParamsToUrl, this);\n      this.extractHashFromUrl = bind(this.extractHashFromUrl, this);\n      this.normalize = bind(this.normalize, this);\n      up.legacy.fixKey(options, 'data', 'params');\n      Request.__super__.constructor.call(this, options);\n      this.normalize();\n    }\n\n    Request.prototype.normalize = function() {\n      this.params = new up.Params(this.params);\n      this.method = u.normalizeMethod(this.method);\n      this.headers || (this.headers = {});\n      this.extractHashFromUrl();\n      if (!u.methodAllowsPayload(this.method)) {\n        return this.transferParamsToUrl();\n      }\n    };\n\n    Request.prototype.extractHashFromUrl = function() {\n      var urlParts;\n      urlParts = u.parseUrl(this.url);\n      this.hash = u.presence(urlParts.hash);\n      return this.url = u.normalizeUrl(urlParts, {\n        hash: false\n      });\n    };\n\n    Request.prototype.transferParamsToUrl = function() {\n      if (!u.isBlank(this.params)) {\n        this.url = this.params.toURL(this.url);\n        return this.params.clear();\n      }\n    };\n\n    Request.prototype.transferSearchToParams = function() {\n      var paramsFromQuery;\n      paramsFromQuery = up.Params.fromURL(this.url);\n      if (!u.isBlank(paramsFromQuery)) {\n        this.params.addAll(paramsFromQuery);\n        return this.url = u.normalizeUrl(this.url, {\n          search: false\n        });\n      }\n    };\n\n    Request.prototype.isSafe = function() {\n      return up.proxy.isSafeMethod(this.method);\n    };\n\n    Request.prototype.send = function() {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          var csrfToken, header, pc, resolveWithResponse, value, xhr, xhrHeaders, xhrMethod, xhrParams, xhrPayload, xhrUrl;\n          xhr = new XMLHttpRequest();\n          xhrHeaders = u.copy(_this.headers);\n          xhrUrl = _this.url;\n          xhrParams = u.copy(_this.params);\n          xhrMethod = up.proxy.wrapMethod(_this.method, xhrParams);\n          xhrPayload = null;\n          if (!u.isBlank(xhrParams)) {\n            delete xhrHeaders['Content-Type'];\n            xhrPayload = xhrParams.toFormData();\n          }\n          pc = up.protocol.config;\n          if (_this.target) {\n            xhrHeaders[pc.targetHeader] = _this.target;\n          }\n          if (_this.failTarget) {\n            xhrHeaders[pc.failTargetHeader] = _this.failTarget;\n          }\n          if (!_this.isCrossDomain()) {\n            xhrHeaders['X-Requested-With'] || (xhrHeaders['X-Requested-With'] = 'XMLHttpRequest');\n          }\n          if (csrfToken = _this.csrfToken()) {\n            xhrHeaders[pc.csrfHeader] = csrfToken;\n          }\n          xhr.open(xhrMethod, xhrUrl);\n          for (header in xhrHeaders) {\n            value = xhrHeaders[header];\n            xhr.setRequestHeader(header, value);\n          }\n          resolveWithResponse = function() {\n            var response;\n            response = _this.buildResponse(xhr);\n            if (response.isSuccess()) {\n              return resolve(response);\n            } else {\n              return reject(response);\n            }\n          };\n          xhr.onload = resolveWithResponse;\n          xhr.onerror = resolveWithResponse;\n          xhr.ontimeout = resolveWithResponse;\n          if (_this.timeout) {\n            xhr.timeout = _this.timeout;\n          }\n          return xhr.send(xhrPayload);\n        };\n      })(this));\n    };\n\n    Request.prototype.navigate = function() {\n      var addField, csrfParam, csrfToken, form, formMethod;\n      this.transferSearchToParams();\n      form = e.affix(document.body, 'form.up-page-loader');\n      addField = function(attrs) {\n        return e.affix(form, 'input[type=hidden]', attrs);\n      };\n      if (this.method === 'GET') {\n        formMethod = 'GET';\n      } else {\n        addField({\n          name: up.protocol.config.methodParam,\n          value: this.method\n        });\n        formMethod = 'POST';\n      }\n      e.setAttrs(form, {\n        method: formMethod,\n        action: this.url\n      });\n      if ((csrfParam = up.protocol.csrfParam()) && (csrfToken = this.csrfToken())) {\n        addField({\n          name: csrfParam,\n          value: csrfToken\n        });\n      }\n      u.each(this.params.toArray(), addField);\n      e.hide(form);\n      return up.browser.submitForm(form);\n    };\n\n    Request.prototype.csrfToken = function() {\n      if (!this.isSafe() && !this.isCrossDomain()) {\n        return up.protocol.csrfToken();\n      }\n    };\n\n    Request.prototype.isCrossDomain = function() {\n      return u.isCrossDomain(this.url);\n    };\n\n    Request.prototype.buildResponse = function(xhr) {\n      var ref, responseAttrs, urlFromServer;\n      responseAttrs = {\n        method: this.method,\n        url: this.url,\n        text: xhr.responseText,\n        status: xhr.status,\n        request: this,\n        xhr: xhr\n      };\n      if (urlFromServer = up.protocol.locationFromXhr(xhr)) {\n        responseAttrs.url = urlFromServer;\n        responseAttrs.method = (ref = up.protocol.methodFromXhr(xhr)) != null ? ref : 'GET';\n      }\n      responseAttrs.title = up.protocol.titleFromXhr(xhr);\n      return new up.Response(responseAttrs);\n    };\n\n    Request.prototype.isCachable = function() {\n      return this.isSafe() && !u.isFormData(this.params);\n    };\n\n    Request.prototype.cacheKey = function() {\n      return [this.url, this.method, this.params.toQuery(), this.target].join('|');\n    };\n\n    Request.wrap = function(value) {\n      return u.wrapValue(value, this);\n    };\n\n    return Request;\n\n  })(up.Record);\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  u = up.util;\n\n\n  /***\n  Instances of `up.Response` describe the server response to an [`AJAX request`](/up.request).\n  \n  \\#\\#\\# Example\n  \n      up.request('/foo').then(function(response) {\n        console.log(response.status) // 200\n        console.log(response.text)   // \"<html><body>...\"\n      })\n  \n  @class up.Response\n   */\n\n  up.Response = (function(superClass) {\n    extend(Response, superClass);\n\n\n    /***\n    The HTTP method used for the response.\n    \n    This is usually the HTTP method used by the request.\n    However, after a redirect the server should signal a `GET` method using\n    an [`X-Up-Method: GET` header](/up.protocol#redirect-detection).\n    \n    @property up.Response#method\n    @param {string} method\n    @stable\n     */\n\n\n    /***\n    The URL used for the response.\n    \n    This is usually the requested URL.\n    However, after a redirect the server should signal a the new URL\n    using an [`X-Up-Location: /new-url` header](/up.protocol#redirect-detection).\n    \n    @property up.Response#url\n    @param {string} method\n    @stable\n     */\n\n\n    /***\n    The response body as a `string`.\n    \n    @property up.Response#text\n    @param {string} text\n    @stable\n     */\n\n\n    /***\n    The response's\n    [HTTP status code](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)\n    as a `number`.\n    \n    A successful response will usually have a `200` or `201' status code.\n    \n    @property up.Response#status\n    @param {number} status\n    @stable\n     */\n\n\n    /***\n    The [request](/up.Request) that triggered this response.\n    \n    @property up.Response#request\n    @param {up.Request} request\n    @experimental\n     */\n\n\n    /***\n    The [`XMLHttpRequest`](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)\n    object that was used to create this response.\n    \n    @property up.Response#xhr\n    @param {XMLHttpRequest} xhr\n    @experimental\n     */\n\n\n    /***\n    A [document title pushed by the server](/up.protocol#pushing-a-document-title-to-the-client).\n    \n    If the server pushed no title via HTTP header, this will be `undefined`.\n    \n    @property up.Response#title\n    @param {string} [title]\n    @stable\n     */\n\n    Response.prototype.fields = function() {\n      return ['method', 'url', 'text', 'status', 'request', 'xhr', 'title'];\n    };\n\n\n    /***\n    @constructor up.Response\n    @internal\n     */\n\n    function Response(options) {\n      this.getHeader = bind(this.getHeader, this);\n      this.isFatalError = bind(this.isFatalError, this);\n      this.isError = bind(this.isError, this);\n      this.isSuccess = bind(this.isSuccess, this);\n      Response.__super__.constructor.call(this, options);\n    }\n\n\n    /***\n    Returns whether the server responded with a 2xx HTTP status.\n    \n    @function up.Response#isSuccess\n    @return {boolean}\n    @experimental\n     */\n\n    Response.prototype.isSuccess = function() {\n      return this.status && (this.status >= 200 && this.status <= 299);\n    };\n\n\n    /***\n    Returns whether the response was not [successful](/up.Request.prototype.isSuccess).\n    \n    This also returns `true` when the request encountered a [fatal error](/up.Request.prototype.isFatalError)\n    like a timeout or loss of network connectivity.\n    \n    @function up.Response#isError\n    @return {boolean}\n    @experimental\n     */\n\n    Response.prototype.isError = function() {\n      return !this.isSuccess();\n    };\n\n\n    /***\n    Returns whether the request encountered a [fatal error](/up.Request.prototype.isFatalError)\n    like a timeout or loss of network connectivity.\n    \n    When the server produces an error message with an HTTP status like `500`,\n    this is not considered a fatal error and `false` is returned.\n    \n    @function up.Response#isFatalError\n    @return {boolean}\n    @experimental\n     */\n\n    Response.prototype.isFatalError = function() {\n      return this.isError() && u.isBlank(this.text);\n    };\n\n\n    /***\n    Returns the HTTP header value with the given name.\n    \n    The search for the header name is case-insensitive.\n    \n    Returns `undefined` if the given header name was not included in the response.\n    \n    @function up.Response#getHeader\n    @param {string} name\n    @return {string|undefined} value\n    @experimental\n     */\n\n    Response.prototype.getHeader = function(name) {\n      return this.xhr.getResponseHeader(name);\n    };\n\n    return Response;\n\n  })(up.Record);\n\n}).call(this);\n(function() {\n  var e;\n\n  e = up.element;\n\n  up.RevealMotion = (function() {\n    function RevealMotion(element, options) {\n      var layoutConfig, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, snapDefault;\n      this.element = element;\n      if (options == null) {\n        options = {};\n      }\n      layoutConfig = up.viewport.config;\n      this.viewport = (ref = options.viewport) != null ? ref : up.viewport.closest(this.element);\n      up.legacy.fixKey(layoutConfig, 'snap', 'revealSnap');\n      snapDefault = layoutConfig.revealSnap;\n      this.snap = (ref1 = (ref2 = options.snap) != null ? ref2 : options.revealSnap) != null ? ref1 : snapDefault;\n      if (this.snap === false) {\n        this.snap = 0;\n      } else if (this.snap === true) {\n        this.snap = snapDefault;\n      }\n      this.padding = (ref3 = (ref4 = options.padding) != null ? ref4 : options.revealPadding) != null ? ref3 : layoutConfig.revealPadding;\n      this.top = options.top;\n      this.fixedTop = (ref5 = options.fixedTop) != null ? ref5 : layoutConfig.fixedTop;\n      this.fixedBottom = (ref6 = options.fixedBottom) != null ? ref6 : layoutConfig.fixedBottom;\n      this.speed = (ref7 = (ref8 = options.speed) != null ? ref8 : options.scrollSpeed) != null ? ref7 : layoutConfig.scrollSpeed;\n      this.behavior = (ref9 = options.behavior) != null ? ref9 : options.scrollBehavior;\n    }\n\n    RevealMotion.prototype.start = function() {\n      var diff, elementRect, newScrollTop, originalScrollTop, viewportRect;\n      elementRect = up.Rect.fromElement(this.element);\n      viewportRect = this.getViewportRect(this.viewport);\n      this.addPadding(elementRect);\n      this.substractObstructions(viewportRect);\n      if (viewportRect.height <= 0) {\n        return Promise.reject(new Error('Viewport has no visible area'));\n      }\n      originalScrollTop = this.viewport.scrollTop;\n      newScrollTop = originalScrollTop;\n      if (this.top || elementRect.height > viewportRect.height) {\n        diff = elementRect.top - viewportRect.top;\n        newScrollTop += diff;\n      } else if (elementRect.top < viewportRect.top) {\n        newScrollTop -= viewportRect.top - elementRect.top;\n      } else if (elementRect.bottom > viewportRect.bottom) {\n        newScrollTop += elementRect.bottom - viewportRect.bottom;\n      } else {\n\n      }\n      if (newScrollTop < this.snap && elementRect.top < (0.5 * viewportRect.height)) {\n        newScrollTop = 0;\n      }\n      if (newScrollTop !== originalScrollTop) {\n        return this.scrollTo(newScrollTop);\n      } else {\n        return Promise.resolve();\n      }\n    };\n\n    RevealMotion.prototype.scrollTo = function(newScrollTop) {\n      var scrollOptions;\n      scrollOptions = {\n        speed: this.speed,\n        behavior: this.behavior\n      };\n      this.scrollMotion = new up.ScrollMotion(this.viewport, newScrollTop, scrollOptions);\n      return this.scrollMotion.start();\n    };\n\n    RevealMotion.prototype.getViewportRect = function() {\n      if (up.viewport.isRoot(this.viewport)) {\n        return new up.Rect({\n          left: 0,\n          top: 0,\n          width: up.viewport.rootWidth(),\n          height: up.viewport.rootHeight()\n        });\n      } else {\n        return up.Rect.fromElement(this.viewport);\n      }\n    };\n\n    RevealMotion.prototype.addPadding = function(elementRect) {\n      elementRect.top -= this.padding;\n      return elementRect.height += 2 * this.padding;\n    };\n\n    RevealMotion.prototype.substractObstructions = function(viewportRect) {\n      var diff, i, j, len, len1, obstruction, obstructionRect, ref, ref1, results;\n      ref = e.list.apply(e, this.fixedTop);\n      for (i = 0, len = ref.length; i < len; i++) {\n        obstruction = ref[i];\n        obstructionRect = up.Rect.fromElement(obstruction);\n        diff = obstructionRect.bottom - viewportRect.top;\n        if (diff > 0) {\n          viewportRect.top += diff;\n          viewportRect.height -= diff;\n        }\n      }\n      ref1 = e.list.apply(e, this.fixedBottom);\n      results = [];\n      for (j = 0, len1 = ref1.length; j < len1; j++) {\n        obstruction = ref1[j];\n        obstructionRect = up.Rect.fromElement(obstruction);\n        diff = viewportRect.bottom - obstructionRect.top;\n        if (diff > 0) {\n          results.push(viewportRect.height -= diff);\n        } else {\n          results.push(void 0);\n        }\n      }\n      return results;\n    };\n\n    RevealMotion.prototype.finish = function() {\n      var ref;\n      return (ref = this.scrollMotion) != null ? ref.finish() : void 0;\n    };\n\n    return RevealMotion;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  up.ScrollMotion = (function() {\n    var SPEED_CALIBRATION;\n\n    SPEED_CALIBRATION = 0.065;\n\n    function ScrollMotion(scrollable, targetTop, options) {\n      var ref, ref1, ref2, ref3;\n      this.scrollable = scrollable;\n      this.targetTop = targetTop;\n      if (options == null) {\n        options = {};\n      }\n      this.finish = bind(this.finish, this);\n      this.cancel = bind(this.cancel, this);\n      this.animationFrame = bind(this.animationFrame, this);\n      this.start = bind(this.start, this);\n      this.behavior = (ref = (ref1 = options.behavior) != null ? ref1 : options.scrollBehavior) != null ? ref : 'auto';\n      this.speed = ((ref2 = (ref3 = options.speed) != null ? ref3 : options.scrollSpeed) != null ? ref2 : up.viewport.config.scrollSpeed) * SPEED_CALIBRATION;\n    }\n\n    ScrollMotion.prototype.start = function() {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          _this.resolve = resolve;\n          _this.reject = reject;\n          if (_this.behavior === 'smooth' && up.motion.isEnabled()) {\n            return _this.startAnimation();\n          } else {\n            return _this.finish();\n          }\n        };\n      })(this));\n    };\n\n    ScrollMotion.prototype.startAnimation = function() {\n      this.startTime = Date.now();\n      this.startTop = this.scrollable.scrollTop;\n      this.topDiff = this.targetTop - this.startTop;\n      this.duration = Math.sqrt(Math.abs(this.topDiff)) / this.speed;\n      return requestAnimationFrame(this.animationFrame);\n    };\n\n    ScrollMotion.prototype.animationFrame = function() {\n      var currentTime, timeElapsed, timeFraction;\n      if (this.settled) {\n        return;\n      }\n      if (this.frameTop && Math.abs(this.frameTop - this.scrollable.scrollTop) > 1.5) {\n        this.cancel('Animation aborted due to user intervention');\n      }\n      currentTime = Date.now();\n      timeElapsed = currentTime - this.startTime;\n      timeFraction = Math.min(timeElapsed / this.duration, 1);\n      this.frameTop = this.startTop + (u.simpleEase(timeFraction) * this.topDiff);\n      if (Math.abs(this.targetTop - this.frameTop) < 0.3) {\n        return this.finish();\n      } else {\n        this.scrollable.scrollTop = this.frameTop;\n        return requestAnimationFrame(this.animationFrame);\n      }\n    };\n\n    ScrollMotion.prototype.cancel = function(reason) {\n      this.settled = true;\n      return this.reject(new Error(reason));\n    };\n\n    ScrollMotion.prototype.finish = function() {\n      this.settled = true;\n      this.scrollable.scrollTop = this.targetTop;\n      return this.resolve();\n    };\n\n    return ScrollMotion;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  up.store || (up.store = {});\n\n  u = up.util;\n\n  up.store.Memory = (function() {\n    function Memory() {\n      this.values = bind(this.values, this);\n      this.keys = bind(this.keys, this);\n      this.remove = bind(this.remove, this);\n      this.set = bind(this.set, this);\n      this.get = bind(this.get, this);\n      this.clear = bind(this.clear, this);\n      this.clear();\n    }\n\n    Memory.prototype.clear = function() {\n      return this.data = {};\n    };\n\n    Memory.prototype.get = function(key) {\n      return this.data[key];\n    };\n\n    Memory.prototype.set = function(key, value) {\n      return this.data[key] = value;\n    };\n\n    Memory.prototype.remove = function(key) {\n      return delete this.data[key];\n    };\n\n    Memory.prototype.keys = function() {\n      return Object.keys(this.data);\n    };\n\n    Memory.prototype.values = function() {\n      return u.values(this.data);\n    };\n\n    return Memory;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  u = up.util;\n\n  up.store.Session = (function(superClass) {\n    extend(Session, superClass);\n\n    function Session(rootKey) {\n      this.saveToSessionStorage = bind(this.saveToSessionStorage, this);\n      this.loadFromSessionStorage = bind(this.loadFromSessionStorage, this);\n      this.remove = bind(this.remove, this);\n      this.set = bind(this.set, this);\n      this.clear = bind(this.clear, this);\n      this.rootKey = rootKey;\n      this.loadFromSessionStorage();\n    }\n\n    Session.prototype.clear = function() {\n      Session.__super__.clear.call(this);\n      return this.saveToSessionStorage();\n    };\n\n    Session.prototype.set = function(key, value) {\n      Session.__super__.set.call(this, key, value);\n      return this.saveToSessionStorage();\n    };\n\n    Session.prototype.remove = function(key) {\n      Session.__super__.remove.call(this, key);\n      return this.saveToSessionStorage();\n    };\n\n    Session.prototype.loadFromSessionStorage = function() {\n      var raw;\n      try {\n        if (raw = typeof sessionStorage !== \"undefined\" && sessionStorage !== null ? sessionStorage.getItem(this.rootKey) : void 0) {\n          this.data = JSON.parse(raw);\n        }\n      } catch (error) {\n\n      }\n      return this.data || (this.data = {});\n    };\n\n    Session.prototype.saveToSessionStorage = function() {\n      var json;\n      json = JSON.stringify(this.data);\n      try {\n        return typeof sessionStorage !== \"undefined\" && sessionStorage !== null ? sessionStorage.setItem(this.rootKey, json) : void 0;\n      } catch (error) {\n\n      }\n    };\n\n    return Session;\n\n  })(up.store.Memory);\n\n}).call(this);\n(function() {\n  var e, u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  e = up.element;\n\n  up.Tether = (function() {\n    function Tether(options) {\n      this.sync = bind(this.sync, this);\n      this.scheduleSync = bind(this.scheduleSync, this);\n      var ref;\n      this.anchor = options.anchor;\n      ref = options.position.split('-'), this.position = ref[0], this.align = ref[1];\n      if (this.align) {\n        up.legacy.warn('The position value %o is deprecated. Use %o instead.', options.position, this.describeConstraints());\n      } else {\n        this.align = options.align;\n      }\n      this.alignAxis = this.position === 'top' || this.position === 'bottom' ? 'horizontal' : 'vertical';\n      this.viewport = up.viewport.closest(this.anchor);\n      this.parent = this.viewport === e.root() ? document.body : this.viewport;\n      this.syncOnScroll = !this.viewport.contains(this.anchor.offsetParent);\n      this.root = e.affix(this.parent, '.up-bounds');\n      this.setBoundsOffset(0, 0);\n      this.changeEventSubscription('on');\n    }\n\n    Tether.prototype.destroy = function() {\n      e.remove(this.root);\n      return this.changeEventSubscription('off');\n    };\n\n    Tether.prototype.changeEventSubscription = function(fn) {\n      up[fn](window, 'resize', this.scheduleSync);\n      if (this.syncOnScroll) {\n        return up[fn](this.viewport, 'scroll', this.scheduleSync);\n      }\n    };\n\n    Tether.prototype.scheduleSync = function() {\n      clearTimeout(this.syncTimer);\n      return this.syncTimer = u.task(this.sync);\n    };\n\n    Tether.prototype.sync = function() {\n      var anchorBox, left, rootBox, top;\n      rootBox = this.root.getBoundingClientRect();\n      anchorBox = this.anchor.getBoundingClientRect();\n      left = void 0;\n      top = void 0;\n      switch (this.alignAxis) {\n        case 'horizontal':\n          top = (function() {\n            switch (this.position) {\n              case 'top':\n                return anchorBox.top - rootBox.height;\n              case 'bottom':\n                return anchorBox.top + anchorBox.height;\n            }\n          }).call(this);\n          left = (function() {\n            switch (this.align) {\n              case 'left':\n                return anchorBox.left;\n              case 'center':\n                return anchorBox.left + 0.5 * (anchorBox.width - rootBox.width);\n              case 'right':\n                return anchorBox.left + anchorBox.width - rootBox.width;\n            }\n          }).call(this);\n          break;\n        case 'vertical':\n          top = (function() {\n            switch (this.align) {\n              case 'top':\n                return anchorBox.top;\n              case 'center':\n                return anchorBox.top + 0.5 * (anchorBox.height - rootBox.height);\n              case 'bottom':\n                return anchorBox.top + anchorBox.height - rootBox.height;\n            }\n          }).call(this);\n          left = (function() {\n            switch (this.position) {\n              case 'left':\n                return anchorBox.left - rootBox.width;\n              case 'right':\n                return anchorBox.left + anchorBox.width;\n            }\n          }).call(this);\n      }\n      if (u.isDefined(left) || u.isDefined(top)) {\n        return this.moveTo(left, top);\n      } else {\n        return up.fail('Invalid tether constraints: %o', this.describeConstraints());\n      }\n    };\n\n    Tether.prototype.describeConstraints = function() {\n      return {\n        position: this.position,\n        align: this.align\n      };\n    };\n\n    Tether.prototype.moveTo = function(targetLeft, targetTop) {\n      var rootBox;\n      rootBox = this.root.getBoundingClientRect();\n      return this.setBoundsOffset(targetLeft - rootBox.left + this.offsetLeft, targetTop - rootBox.top + this.offsetTop);\n    };\n\n    Tether.prototype.setBoundsOffset = function(left, top) {\n      this.offsetLeft = left;\n      this.offsetTop = top;\n      return e.setStyle(this.root, {\n        left: left,\n        top: top\n      });\n    };\n\n    return Tether;\n\n  })();\n\n}).call(this);\n(function() {\n  var u,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  u = up.util;\n\n  up.UrlSet = (function() {\n    function UrlSet(urls, options) {\n      this.urls = urls;\n      if (options == null) {\n        options = {};\n      }\n      this[\"\" + u.isEqual.key] = bind(this[\"\" + u.isEqual.key], this);\n      this.matchesAny = bind(this.matchesAny, this);\n      this.doesMatchPattern = bind(this.doesMatchPattern, this);\n      this.doesMatchFully = bind(this.doesMatchFully, this);\n      this.matches = bind(this.matches, this);\n      this.normalizeUrl = options.normalizeUrl || u.normalizeUrl;\n      this.urls = u.map(this.urls, this.normalizeUrl);\n      this.urls = u.compact(this.urls);\n    }\n\n    UrlSet.prototype.matches = function(testUrl) {\n      if (testUrl.indexOf('*') >= 0) {\n        return this.doesMatchPattern(testUrl);\n      } else {\n        return this.doesMatchFully(testUrl);\n      }\n    };\n\n    UrlSet.prototype.doesMatchFully = function(testUrl) {\n      return u.contains(this.urls, testUrl);\n    };\n\n    UrlSet.prototype.doesMatchPattern = function(pattern) {\n      var placeholder;\n      placeholder = \"__ASTERISK__\";\n      pattern = pattern.replace(/\\*/g, placeholder);\n      pattern = u.escapeRegexp(pattern);\n      pattern = pattern.replace(new RegExp(placeholder, 'g'), '.*?');\n      pattern = new RegExp('^' + pattern + '$');\n      return u.find(this.urls, function(url) {\n        return pattern.test(url);\n      });\n    };\n\n    UrlSet.prototype.matchesAny = function(testUrls) {\n      return u.find(testUrls, this.matches);\n    };\n\n    UrlSet.prototype[\"\" + u.isEqual.key] = function(otherSet) {\n      return u.isEqual(this.urls, otherSet != null ? otherSet.urls : void 0);\n    };\n\n    return UrlSet;\n\n  })();\n\n}).call(this);\n\n/***\n@module up.framework\n */\n\n(function() {\n  up.framework = (function() {\n    var boot, emitReset, isBooting, u;\n    u = up.util;\n    isBooting = true;\n\n    /***\n    Resets Unpoly to the state when it was booted.\n    All custom event handlers, animations, etc. that have been registered\n    will be discarded.\n    \n    Emits event [`up:framework:reset`](/up:framework:reset).\n    \n    @function up.framework.reset\n    @internal\n     */\n    emitReset = function() {\n      return up.emit('up:framework:reset', {\n        log: 'Resetting framework'\n      });\n    };\n\n    /***\n    This event is [emitted](/up.emit) when Unpoly is [reset](/up.framework.reset) during unit tests.\n    \n    @event up:framework:reset\n    @internal\n     */\n\n    /***\n    Boots the Unpoly framework.\n    \n    **This is called automatically** by including the Unpoly JavaScript files.\n    \n    Unpoly will not boot if the current browser is [not supported](/up.browser.isSupported).\n    This leaves you with a classic server-side application on legacy browsers.\n    \n    @function up.boot\n    @internal\n     */\n    boot = function() {\n      if (up.browser.isSupported()) {\n        up.emit('up:framework:booted', {\n          log: 'Framework booted'\n        });\n        isBooting = false;\n        return up.event.onReady(function() {\n          return u.task(function() {\n            up.emit('up:app:boot', {\n              log: 'Booting user application'\n            });\n            return up.emit('up:app:booted', {\n              log: 'User application booted'\n            });\n          });\n        });\n      } else {\n        return typeof console.log === \"function\" ? console.log(\"Unpoly doesn't support this browser. Framework was not booted.\") : void 0;\n      }\n    };\n    return {\n      reset: emitReset,\n      boot: boot,\n      isBooting: function() {\n        return isBooting;\n      }\n    };\n  })();\n\n}).call(this);\n\n/***\nEvents\n======\n\nMost Unpoly interactions emit DOM events that are prefixed with `up:`.\n\n    document.addEventListener('up:modal:opened', (event) => {\n      console.log('A new modal has just opened!')\n    })\n\nEvents often have both present and past forms. For example,\n`up:modal:open` is emitted before a modal starts to open.\n`up:modal:opened` is emitted when the modal has finished its\nopening animation.\n\n\\#\\#\\# Preventing events\n\nYou can prevent most present form events by calling `preventDefault()`:\n\n    document.addEventListener('up:modal:open', (event) => {\n      if (event.url == '/evil') {\n        // Prevent the modal from opening\n        event.preventDefault()\n      }\n    })\n\n\n\\#\\#\\# A better way to bind event listeners\n\nInstead of using [`Element#addEventListener()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener),\nyou may find it convenient to use [`up.on()`](/up.on) instead:\n\n    up.on('click', 'button', function(event, button, data) {\n      // button is the clicked element\n      // data is the parsed [`up-data`](/up-data) attribute\n    })\n\nThere are some advantages to using `up.on()`:\n\n  - You may pass a selector for [event delegation](https://davidwalsh.name/event-delegate).\n  - The event target is automatically passed as a second argument.\n  - You may register a listener to multiple events by passing a space-separated list of event name (e.g. `\"click mousedown\"`).\n  - You may register a listener to multiple elements in a single `up.on()` call, by passing a [list](/up.util.isList) of elements.\n  - You may use an [`[up-data]`](/up-data) attribute to [attach structured data](/up.on#attaching-structured-data)\n    to observed elements. If an `[up-data]` attribute is set, its value will automatically be\n    parsed as JSON and passed as a third argument.\n  - Event listeners on [unsupported browsers](/up.browser.isSupported) are silently discarded,\n    leaving you with an application without JavaScript. This is typically preferable to\n    a soup of randomly broken JavaScript in ancient browsers.\n\n@module up.event\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.event = (function() {\n    var $bind, bind, bindNow, buildEvent, consumeAction, e, emit, halt, logEmission, nobodyPrevents, onEscape, onReady, reset, u, unbind, whenEmitted;\n    u = up.util;\n    e = up.element;\n    reset = function() {\n      var element, i, len, ref, results;\n      ref = [window, document, document.documentElement, document.body];\n      results = [];\n      for (i = 0, len = ref.length; i < len; i++) {\n        element = ref[i];\n        results.push(up.EventListener.unbindNonDefault(element));\n      }\n      return results;\n    };\n\n    /***\n    Listens to a [DOM event](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Events)\n    on `document` or a given element.\n    \n    `up.on()` has some quality of life improvements over\n    [`Element#addEventListener()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener):\n    \n    - You may pass a selector for [event delegation](https://davidwalsh.name/event-delegate).\n    - The event target is automatically passed as a second argument.\n    - You may register a listener to multiple events by passing a space-separated list of event name (e.g. `\"click mousedown\"`)\n    - You may register a listener to multiple elements in a single `up.on()` call, by passing a [list](/up.util.isList) of elements.\n    - You use an [`[up-data]`](/up-data) attribute to [attach structured data](/up.on#attaching-structured-data)\n      to observed elements. If an `[up-data]` attribute is set, its value will automatically be\n      parsed as JSON and passed as a third argument.\n    - Event listeners on [unsupported browsers](/up.browser.isSupported) are silently discarded,\n      leaving you with an application without JavaScript. This is typically preferable to\n      a soup of randomly broken JavaScript in ancient browsers.\n    \n    \\#\\#\\# Examples\n    \n    The code below will call the listener when a `<a>` is clicked\n    anywhere in the `document`:\n    \n        up.on('click', 'a', function(event, element) {\n          console.log(\"Click on a link %o\", element)\n        })\n    \n    You may also bind the listener to a given element instead of `document`:\n    \n        var form = document.querySelector('form')\n        up.on(form, 'click', function(event, form) {\n          console.log(\"Click within %o\", form)\n        })\n    \n    You may also pass both an element and a selector\n    for [event delegation](https://davidwalsh.name/event-delegate):\n    \n        var form = document.querySelector('form')\n        up.on(form, 'click', 'a', function(event, link) {\n          console.log(\"Click on a link %o within %o\", link, form)\n        })\n    \n    \\#\\#\\# Attaching structured data\n    \n    In case you want to attach structured data to the event you're observing,\n    you can serialize the data to JSON and put it into an `[up-data]` attribute:\n    \n        <span class='person' up-data='{ \"age\": 18, \"name\": \"Bob\" }'>Bob</span>\n        <span class='person' up-data='{ \"age\": 22, \"name\": \"Jim\" }'>Jim</span>\n    \n    The JSON will be parsed and handed to your event handler as a third argument:\n    \n        up.on('click', '.person', function(event, element, data) {\n          console.log(\"This is %o who is %o years old\", data.name, data.age)\n        })\n    \n    \\#\\#\\# Unbinding an event listener\n    \n    `up.on()` returns a function that unbinds the event listeners when called:\n    \n        // Define the listener\n        var listener =  function(event) { ... }\n    \n        // Binding the listener returns an unbind function\n        var unbind = up.on('click', listener)\n    \n        // Unbind the listener\n        unbind()\n    \n    There is also a function [`up.off()`](/up.off) which you can use for the same purpose:\n    \n        // Define the listener\n        var listener =  function(event) { ... }\n    \n        // Bind the listener\n        up.on('click', listener)\n    \n        // Unbind the listener\n        up.off('click', listener)\n    \n    @function up.on\n    @param {Element|jQuery} [element=document]\n      The element on which to register the event listener.\n    \n      If no element is given, the listener is registered on the `document`.\n    @param {string} events\n      A space-separated list of event names to bind to.\n    @param {string} [selector]\n      The selector of an element on which the event must be triggered.\n      Omit the selector to listen to all events with that name, regardless\n      of the event target.\n    @param {Function(event, [element], [data])} listener\n      The listener function that should be called.\n    \n      The function takes the affected element as the first argument).\n      If the element has an [`up-data`](/up-data) attribute, its value is parsed as JSON\n      and passed as a second argument.\n    @return {Function()}\n      A function that unbinds the event listeners when called.\n    @stable\n     */\n    bind = function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return bindNow(args);\n    };\n\n    /***\n    Listens to an event on `document` or a given element.\n    The event handler is called with the event target as a\n    [jQuery collection](https://learn.jquery.com/using-jquery-core/jquery-object/).\n    \n    If you're not using jQuery, use `up.on()` instead, which calls\n    event handlers with a native element.\n    \n    \\#\\#\\# Example\n    \n    ```\n    up.$on('click', 'a', function(event, $link) {\n      console.log(\"Click on a link with destination %s\", $element.attr('href'))\n    })\n    ```\n    \n    @function up.$on\n    @param {Element|jQuery} [element=document]\n      The element on which to register the event listener.\n    \n      If no element is given, the listener is registered on the `document`.\n    @param {string} events\n      A space-separated list of event names to bind to.\n    @param {string} [selector]\n      The selector of an element on which the event must be triggered.\n      Omit the selector to listen to all events with that name, regardless\n      of the event target.\n    @param {Function(event, [element], [data])} listener\n      The listener function that should be called.\n    \n      The function takes the affected element as the first argument).\n      If the element has an [`up-data`](/up-data) attribute, its value is parsed as JSON\n      and passed as a second argument.\n    @return {Function()}\n      A function that unbinds the event listeners when called.\n    @stable\n     */\n    $bind = function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return bindNow(args, {\n        jQuery: true\n      });\n    };\n    bindNow = function(args, options) {\n      if (!up.browser.isSupported()) {\n        return (function() {});\n      }\n      return up.EventListener.bind(args, options);\n    };\n\n    /***\n    Unbinds an event listener previously bound with [`up.on()`](/up.on).\n    \n    \\#\\#\\# Example\n    \n    Let's say you are listing to clicks on `.button` elements:\n    \n        var listener = function() { ... }\n        up.on('click', '.button', listener)\n    \n    You can stop listening to these events like this:\n    \n        up.off('click', '.button', listener)\n    \n    Note that you need to pass `up.off()` a reference to the same listener function\n    that was passed to `up.on()` earlier.\n    \n    @function up.off\n    @stable\n     */\n    unbind = function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return up.EventListener.unbind(args);\n    };\n\n    /***\n    Emits a event with the given name and properties.\n    \n    The event will be triggered as an event on `document` or on the given element.\n    \n    Other code can subscribe to events with that name using\n    [`Element#addEventListener()`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)\n    or [`up.on()`](/up.on).\n    \n    \\#\\#\\# Example\n    \n        up.on('my:event', function(event) {\n          console.log(event.foo)\n        })\n    \n        up.emit('my:event', { foo: 'bar' })\n        // Prints \"bar\" to the console\n    \n    @function up.emit\n    @param {Element|jQuery} [target=document]\n      The element on which the event is triggered.\n    \n      If omitted, the event will be emitted on the `document`.\n    @param {string} eventName\n      The name of the event.\n    @param {Object} [eventProps={}]\n      A list of properties to become part of the event object\n      that will be passed to listeners. Note that the event object\n      will by default include properties like `preventDefault()`\n      or `stopPropagation()`.\n    @param {string|Array} [eventProps.log=false]\n      A message to print to the console when the event is emitted.\n    \n      Pass `true` to print a default message\n    @param {Element|jQuery} [eventProps.target=document]\n      The element on which the event is triggered.\n    @stable\n     */\n    emit = function() {\n      var args, event, eventName, eventProps, target, targetFromProps;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      if (args[0].addEventListener) {\n        target = args.shift();\n      } else if (u.isJQuery(args[0])) {\n        target = e.get(args.shift());\n      }\n      eventName = args[0];\n      eventProps = args[1] || {};\n      if (targetFromProps = u.pluckKey(eventProps, 'target')) {\n        target = targetFromProps;\n      }\n      if (target == null) {\n        target = document;\n      }\n      logEmission(eventName, eventProps);\n      event = buildEvent(eventName, eventProps);\n      target.dispatchEvent(event);\n      return event;\n    };\n    buildEvent = function(name, props) {\n      var event;\n      event = document.createEvent('Event');\n      event.initEvent(name, true, true);\n      u.assign(event, props);\n      if (up.browser.isIE11()) {\n        event.preventDefault = function() {\n          return Object.defineProperty(event, 'defaultPrevented', {\n            get: function() {\n              return true;\n            }\n          });\n        };\n      }\n      return event;\n    };\n    logEmission = function(eventName, eventProps) {\n      var message, messageArgs, ref;\n      if (!up.log.isEnabled()) {\n        return;\n      }\n      message = u.pluckKey(eventProps, 'log');\n      if (u.isArray(message)) {\n        ref = message, message = ref[0], messageArgs = 2 <= ref.length ? slice.call(ref, 1) : [];\n      } else {\n        messageArgs = [];\n      }\n      if (u.isString(message)) {\n        if (u.isPresent(eventProps)) {\n          return up.puts.apply(up, [message + \" (%s (%o))\"].concat(slice.call(messageArgs), [eventName], [eventProps]));\n        } else {\n          return up.puts.apply(up, [message + \" (%s)\"].concat(slice.call(messageArgs), [eventName]));\n        }\n      } else if (message === true) {\n        if (u.isPresent(eventProps)) {\n          return up.puts('Event %s (%o)', eventName, eventProps);\n        } else {\n          return up.puts('Event %s', eventName);\n        }\n      }\n    };\n\n    /***\n    [Emits an event](/up.emit) and returns whether no listener\n    has prevented the default action.\n    \n    @function up.event.nobodyPrevents\n    @param {string} eventName\n    @param {Object} eventProps\n    @param {string|Array} [eventProps.log]\n    @return {boolean}\n      whether no listener has prevented the default action\n    @experimental\n     */\n    nobodyPrevents = function() {\n      var args, event;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      event = emit.apply(null, args);\n      return !event.defaultPrevented;\n    };\n\n    /***\n    [Emits](/up.emit) the given event and returns a promise\n    that will be fulfilled if no listener has prevented the default action.\n    \n    If any listener prevented the default listener\n    the returned promise will never be resolved.\n    \n    @function up.event.whenEmitted\n    @param {string} eventName\n    @param {Object} eventProps\n    @param {string|Array} [eventProps.message]\n    @return {Promise}\n    @internal\n     */\n    whenEmitted = function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      return new Promise(function(resolve, reject) {\n        if (nobodyPrevents.apply(null, args)) {\n          return resolve();\n        } else {\n          return reject(new Error(\"Event \" + args[0] + \" was prevented\"));\n        }\n      });\n    };\n\n    /***\n    Registers an event listener to be called when the user\n    presses the `Escape` key.\n    \n    @function up.event.onEscape\n    @param {Function(event)} listener\n      The listener function to register.\n    @return {Function()}\n      A function that unbinds the event listeners when called.\n    @experimental\n     */\n    onEscape = function(listener) {\n      return bind('keydown', 'body', function(event) {\n        if (u.escapePressed(event)) {\n          return listener(event);\n        }\n      });\n    };\n\n    /***\n    Prevents the event from bubbling up the DOM.\n    Also prevents other event handlers bound on the same element.\n    Also prevents the event's default action.\n    \n    \\#\\#\\# Example\n    \n        up.on('click', 'link.disabled', function(event) {\n          up.event.halt(event)\n        })\n    \n    @function up.event.halt\n    @param {Event} event\n    @experimental\n     */\n    halt = function(event) {\n      event.stopImmediatePropagation();\n      return event.preventDefault();\n    };\n\n    /***\n    @function up.event.consumeAction\n    @internal\n     */\n    consumeAction = function(event) {\n      halt(event);\n      if (event.type !== 'up:action:consumed') {\n        return emit(event.target, 'up:action:consumed', {\n          log: false\n        });\n      }\n    };\n    onReady = function(callback) {\n      if (document.readyState !== 'loading') {\n        return callback();\n      } else {\n        return document.addEventListener('DOMContentLoaded', callback);\n      }\n    };\n    bind('up:framework:reset', reset);\n    return {\n      on: bind,\n      $on: $bind,\n      off: unbind,\n      emit: emit,\n      nobodyPrevents: nobodyPrevents,\n      whenEmitted: whenEmitted,\n      onEscape: onEscape,\n      halt: halt,\n      consumeAction: consumeAction,\n      onReady: onReady\n    };\n  })();\n\n  up.on = up.event.on;\n\n  up.$on = up.event.$on;\n\n  up.off = up.event.off;\n\n  up.$off = up.event.off;\n\n  up.emit = up.event.emit;\n\n  up.legacy.renamedModule('bus', 'event');\n\n}).call(this);\n(function() {\n\n\n}).call(this);\n\n/***\nServer protocol\n===============\n\nYou rarely need to change server-side code\nin order to use Unpoly. There is no need to provide a JSON API, or add\nextra routes for AJAX requests. The server simply renders a series\nof full HTML pages, just like it would without Unpoly.\n\nThat said, there is an **optional** protocol your server can use to\nexchange additional information when Unpoly is [updating fragments](/up.link).\n\nWhile the protocol can help you optimize performance and handle some\nedge cases, implementing it is **entirely optional**. For instance,\n`unpoly.com` itself is a static site that uses Unpoly on the frontend\nand doesn't even have a server component.\n\n## Existing implementations\n\nYou should be able to implement the protocol in a very short time.\nThere are existing implementations for various web frameworks:\n\n- [Ruby on Rails](/install/rails)\n- [Roda](https://github.com/adam12/roda-unpoly)\n- [Rack](https://github.com/adam12/rack-unpoly) (Sinatra, Padrino, Hanami, Cuba, ...)\n- [Phoenix](https://elixirforum.com/t/unpoly-a-framework-like-turbolinks/3614/15) (Elixir)\n\n\n## Protocol details\n\n\\#\\#\\# Redirect detection for IE11\n\nOn Internet Explorer 11, Unpoly cannot detect the final URL after a redirect.\nYou can fix this edge case by delivering an additional HTTP header\nwith the *last* response in a series of redirects:\n\n```http\nX-Up-Location: /current-url\n```\n\nThe **simplest implementation** is to set these headers for every request.\n\n\n\\#\\#\\# Optimizing responses\n\nWhen [updating a fragment](/up.link), Unpoly will send an\nadditional HTTP header containing the CSS selector that is being replaced:\n\n```http\nX-Up-Target: .user-list\n```\n\nServer-side code is free to **optimize its response** by only returning HTML\nthat matches the selector. For example, you might prefer to not render an\nexpensive sidebar if the sidebar is not targeted.\n\nUnpoly will often update a different selector in case the request fails.\nThis selector is also included as a HTTP header:\n\n```\nX-Up-Fail-Target: body\n```\n\n\n\\#\\#\\# Pushing a document title to the client\n\nWhen [updating a fragment](/up.link), Unpoly will by default\nextract the `<title>` from the server response and update the document title accordingly.\n\nThe server can also force Unpoly to set a document title by passing a HTTP header:\n\n```http\nX-Up-Title: My server-pushed title\n```\n\nThis is useful when you [optimize your response](#optimizing-responses) and not render\nthe application layout unless it is targeted. Since your optimized response\nno longer includes a `<title>`, you can instead use the HTTP header to pass the document title.\n\n\n\\#\\#\\# Signaling failed form submissions\n\nWhen [submitting a form via AJAX](/form-up-target)\nUnpoly needs to know whether the form submission has failed (to update the form with\nvalidation errors) or succeeded (to update the `up-target` selector).\n\nFor Unpoly to be able to detect a failed form submission, the response must be\nreturn a non-200 HTTP status code. We recommend to use either\n400 (bad request) or 422 (unprocessable entity).\n\nTo do so in [Ruby on Rails](http://rubyonrails.org/), pass a [`:status` option to `render`](http://guides.rubyonrails.org/layouts_and_rendering.html#the-status-option):\n\n    class UsersController < ApplicationController\n\n      def create\n        user_params = params[:user].permit(:email, :password)\n        @user = User.new(user_params)\n        if @user.save?\n          sign_in @user\n        else\n          render 'form', status: :bad_request\n        end\n      end\n\n    end\n\n\n\\#\\#\\# Detecting live form validations\n\nWhen [validating a form](/input-up-validate), Unpoly will\nsend an additional HTTP header containing a CSS selector for the form that is\nbeing updated:\n\n```http\nX-Up-Validate: .user-form\n```\n\nWhen detecting a validation request, the server is expected to **validate (but not save)**\nthe form submission and render a new copy of the form with validation errors.\n\nBelow you will an example for a writing route that is aware of Unpoly's live form\nvalidations. The code is for [Ruby on Rails](http://rubyonrails.org/),\nbut you can adapt it for other languages:\n\n    class UsersController < ApplicationController\n\n      def create\n        user_params = params[:user].permit(:email, :password)\n        @user = User.new(user_params)\n        if request.headers['X-Up-Validate']\n          @user.valid?  # run validations, but don't save to the database\n          render 'form' # render form with error messages\n        elsif @user.save?\n          sign_in @user\n        else\n          render 'form', status: :bad_request\n        end\n      end\n\n    end\n\n\n\\#\\#\\# Signaling the initial request method\n\nIf the initial page was loaded  with a non-`GET` HTTP method, Unpoly prefers to make a full\npage load when you try to update a fragment. Once the next page was loaded with a `GET` method,\nUnpoly will restore its standard behavior.\n\nThis fixes two edge cases you might or might not care about:\n\n1. Unpoly replaces the initial page state so it can later restore it when the user\n   goes back to that initial URL. However, if the initial request was a POST,\n   Unpoly will wrongly assume that it can restore the state by reloading with GET.\n2. Some browsers have a bug where the initial request method is used for all\n   subsequently pushed states. That means if the user reloads the page on a later\n   GET state, the browser will wrongly attempt a POST request.\n   This issue affects Safari 9-12 (last tested in 2019-03).\n   Modern Firefoxes, Chromes and IE10+ don't have this behavior.\n\nIn order to allow Unpoly to detect the HTTP method of the initial page load,\nthe server must set a cookie:\n\n```http\nSet-Cookie: _up_method=POST\n```\n\nWhen Unpoly boots, it will look for this cookie and configure its behavior accordingly.\nThe cookie is then deleted in order to not affect following requests.\n\nThe **simplest implementation** is to set this cookie for every request that is neither\n`GET` nor contains an [`X-Up-Target` header](/#optimizing-responses). For all other requests\nan existing cookie should be deleted.\n\n\n@module up.protocol\n */\n\n(function() {\n  up.protocol = (function() {\n    var config, csrfParam, csrfToken, e, initialRequestMethod, locationFromXhr, methodFromXhr, reset, titleFromXhr, u;\n    u = up.util;\n    e = up.element;\n\n    /***\n    @function up.protocol.locationFromXhr\n    @internal\n     */\n    locationFromXhr = function(xhr) {\n      return xhr.getResponseHeader(config.locationHeader) || xhr.responseURL;\n    };\n\n    /***\n    @function up.protocol.titleFromXhr\n    @internal\n     */\n    titleFromXhr = function(xhr) {\n      return xhr.getResponseHeader(config.titleHeader);\n    };\n\n    /***\n    @function up.protocol.methodFromXhr\n    @internal\n     */\n    methodFromXhr = function(xhr) {\n      var method;\n      if (method = xhr.getResponseHeader(config.methodHeader)) {\n        return u.normalizeMethod(method);\n      }\n    };\n\n    /***\n    Server-side companion libraries like unpoly-rails set this cookie so we\n    have a way to detect the request method of the initial page load.\n    There is no JavaScript API for this.\n    \n    @function up.protocol.initialRequestMethod\n    @internal\n     */\n    initialRequestMethod = u.memoize(function() {\n      var methodFromServer;\n      methodFromServer = up.browser.popCookie(config.methodCookie);\n      return (methodFromServer || 'get').toLowerCase();\n    });\n    up.on('up:framework:booted', initialRequestMethod);\n\n    /***\n    Configures strings used in the optional [server protocol](/up.protocol).\n    \n    @property up.protocol.config\n    @param {String} [config.targetHeader='X-Up-Target']\n    @param {String} [config.failTargetHeader='X-Up-Fail-Target']\n    @param {String} [config.locationHeader='X-Up-Location']\n    @param {String} [config.titleHeader='X-Up-Title']\n    @param {String} [config.validateHeader='X-Up-Validate']\n    @param {String} [config.methodHeader='X-Up-Method']\n    @param {String} [config.methodCookie='_up_method']\n      The name of the optional cookie the server can send to\n      [signal the initial request method](/up.protocol#signaling-the-initial-request-method).\n    @param {String} [config.methodParam='_method']\n      The name of the POST parameter when [wrapping HTTP methods](/up.proxy.config#config.wrapMethods)\n      in a `POST` request.\n    @param {String} [config.csrfHeader='X-CSRF-Token']\n      The name of the HTTP header that will include the\n      [CSRF token](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Synchronizer_token_pattern)\n      for AJAX requests.\n    @param {string|Function(): string} [config.csrfParam]\n      The `name` of the hidden `<input>` used for sending a\n      [CSRF token](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Synchronizer_token_pattern) when\n      submitting a default, non-AJAX form. For AJAX request the token is sent as an HTTP header instead.\n    \n      The parameter name can be configured as a string or as function that returns the parameter name.\n      If no name is set, no token will be sent.\n    \n      Defaults to the `content` attribute of a `<meta>` tag named `csrf-param`:\n    \n          <meta name=\"csrf-param\" content=\"authenticity_token\" />\n    \n    @param {string|Function(): string} [config.csrfToken]\n      The [CSRF token](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Synchronizer_token_pattern)\n      to send for unsafe requests. The token will be sent as either a HTTP header (for AJAX requests)\n      or hidden form `<input>` (for default, non-AJAX form submissions).\n    \n      The token can either be configured as a string or as function that returns the token.\n      If no token is set, no token will be sent.\n    \n      Defaults to the `content` attribute of a `<meta>` tag named `csrf-token`:\n    \n          <meta name='csrf-token' content='secret12345'>\n    \n    @experimental\n     */\n    config = new up.Config({\n      targetHeader: 'X-Up-Target',\n      failTargetHeader: 'X-Up-Fail-Target',\n      locationHeader: 'X-Up-Location',\n      validateHeader: 'X-Up-Validate',\n      titleHeader: 'X-Up-Title',\n      methodHeader: 'X-Up-Method',\n      methodCookie: '_up_method',\n      methodParam: '_method',\n      csrfParam: function() {\n        return e.metaContent('csrf-param');\n      },\n      csrfToken: function() {\n        return e.metaContent('csrf-token');\n      },\n      csrfHeader: 'X-CSRF-Token'\n    });\n    csrfParam = function() {\n      return u.evalOption(config.csrfParam);\n    };\n    csrfToken = function() {\n      return u.evalOption(config.csrfToken);\n    };\n    reset = function() {\n      return config.reset();\n    };\n    up.on('up:framework:reset', reset);\n    return {\n      config: config,\n      reset: reset,\n      locationFromXhr: locationFromXhr,\n      titleFromXhr: titleFromXhr,\n      methodFromXhr: methodFromXhr,\n      csrfParam: csrfParam,\n      csrfToken: csrfToken,\n      initialRequestMethod: initialRequestMethod\n    };\n  })();\n\n}).call(this);\n\n/***\nLogging\n=======\n\nUnpoly can print debugging information to the developer console, e.g.:\n\n- Which [events](/up.event) are called\n- When we're [making requests to the network](/up.proxy)\n- Which [compilers](/up.syntax) are applied to which elements\n\nYou can activate logging by calling [`up.log.enable()`](/up.log.enable).\nThe output can be configured using the [`up.log.config`](/up.log.config) property.\n\n@module up.log\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.log = (function() {\n    var CONSOLE_PLACEHOLDERS, b, callConsole, config, debug, disable, enable, error, group, prefix, printBanner, puts, reset, sessionStore, setEnabled, sprintf, sprintfWithFormattedArgs, stringifyArg, u, warn;\n    u = up.util;\n    b = up.browser;\n    sessionStore = new up.store.Session('up.log');\n\n    /***\n    Configures the logging output on the developer console.\n    \n    @property up.log.config\n    @param {boolean} [options.enabled=false]\n      Whether Unpoly will print debugging information to the developer console.\n    \n      Debugging information includes which elements are being [compiled](/up.syntax)\n      and which [events](/up.event) are being emitted.\n      Note that errors will always be printed, regardless of this setting.\n    @param {boolean} [options.collapse=false]\n      Whether debugging information is printed as a collapsed tree.\n    \n      Set this to `true` if you are overwhelmed by the debugging information Unpoly\n      prints to the developer console.\n    @param {string} [options.prefix='[UP] ']\n      A string to prepend to Unpoly's logging messages so you can distinguish it from your own messages.\n    @stable\n     */\n    config = new up.Config({\n      prefix: '[UP] ',\n      enabled: sessionStore.get('enabled'),\n      collapse: false\n    });\n    reset = function() {\n      return config.reset();\n    };\n    prefix = function(message) {\n      return \"\" + config.prefix + message;\n    };\n\n    /***\n    A cross-browser way to interact with `console.log`, `console.error`, etc.\n    \n    This function falls back to `console.log` if the output stream is not implemented.\n    It also prints substitution strings (e.g. `console.log(\"From %o to %o\", \"a\", \"b\")`)\n    as a single string if the browser console does not support substitution strings.\n    \n    \\#\\#\\# Example\n    \n        up.browser.puts('log', 'Hi world')\n        up.browser.puts('error', 'There was an error in %o', obj)\n    \n    @function up.browser.puts\n    @internal\n     */\n    callConsole = function() {\n      var args, stream;\n      stream = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      return console[stream].apply(console, args);\n    };\n    CONSOLE_PLACEHOLDERS = /\\%[odisf]/g;\n    stringifyArg = function(arg) {\n      var attr, closer, j, len, maxLength, ref, string, value;\n      maxLength = 200;\n      closer = '';\n      if (u.isString(arg)) {\n        string = arg.replace(/[\\n\\r\\t ]+/g, ' ');\n        string = string.replace(/^[\\n\\r\\t ]+/, '');\n        string = string.replace(/[\\n\\r\\t ]$/, '');\n        string = \"\\\"\" + string + \"\\\"\";\n        closer = '\"';\n      } else if (u.isUndefined(arg)) {\n        string = 'undefined';\n      } else if (u.isNumber(arg) || u.isFunction(arg)) {\n        string = arg.toString();\n      } else if (u.isArray(arg)) {\n        string = \"[\" + (u.map(arg, stringifyArg).join(', ')) + \"]\";\n        closer = ']';\n      } else if (u.isJQuery(arg)) {\n        string = \"$(\" + (u.map(arg, stringifyArg).join(', ')) + \")\";\n        closer = ')';\n      } else if (u.isElement(arg)) {\n        string = \"<\" + (arg.tagName.toLowerCase());\n        ref = ['id', 'name', 'class'];\n        for (j = 0, len = ref.length; j < len; j++) {\n          attr = ref[j];\n          if (value = arg.getAttribute(attr)) {\n            string += \" \" + attr + \"=\\\"\" + value + \"\\\"\";\n          }\n        }\n        string += \">\";\n        closer = '>';\n      } else {\n        string = JSON.stringify(arg);\n      }\n      if (string.length > maxLength) {\n        string = (string.substr(0, maxLength)) + \" \";\n        string += closer;\n      }\n      return string;\n    };\n\n    /***\n    See https://developer.mozilla.org/en-US/docs/Web/API/Console#Using_string_substitutions\n    \n    @function up.browser.sprintf\n    @internal\n     */\n    sprintf = function() {\n      var args, message;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      return sprintfWithFormattedArgs.apply(null, [u.identity, message].concat(slice.call(args)));\n    };\n\n    /***\n    @function up.browser.sprintfWithFormattedArgs\n    @internal\n     */\n    sprintfWithFormattedArgs = function() {\n      var args, formatter, i, message;\n      formatter = arguments[0], message = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];\n      if (u.isBlank(message)) {\n        return '';\n      }\n      i = 0;\n      return message.replace(CONSOLE_PLACEHOLDERS, function() {\n        var arg;\n        arg = args[i];\n        arg = formatter(stringifyArg(arg));\n        i += 1;\n        return arg;\n      });\n    };\n\n    /***\n    Prints a debugging message to the browser console.\n    \n    @function up.log.debug\n    @param {string} message\n    @param {Array} ...args\n    @internal\n     */\n    debug = function() {\n      var args, message;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (config.enabled && message) {\n        return console.debug.apply(console, [prefix(message)].concat(slice.call(args)));\n      }\n    };\n\n    /***\n    Prints a logging message to the browser console.\n    \n    @function up.puts\n    @param {string} message\n    @param {Array} ...args\n    @internal\n     */\n    puts = function() {\n      var args, message;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (config.enabled && message) {\n        return console.log.apply(console, [prefix(message)].concat(slice.call(args)));\n      }\n    };\n\n    /***\n    @function up.warn\n    @internal\n     */\n    warn = function() {\n      var args, message;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (message) {\n        return console.warn.apply(console, [prefix(message)].concat(slice.call(args)));\n      }\n    };\n\n    /***\n    - Makes sure the group always closes\n    - Does not make a group if the message is nil\n    \n    @function up.log.group\n    @internal\n     */\n    group = function() {\n      var args, block, fn, message;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      block = args.pop();\n      if (config.enabled && message) {\n        fn = config.collapse ? 'groupCollapsed' : 'group';\n        console[fn].apply(console, [prefix(message)].concat(slice.call(args)));\n        try {\n          return block();\n        } finally {\n          if (message) {\n            console.groupEnd();\n          }\n        }\n      } else {\n        return block();\n      }\n    };\n\n    /***\n    @function up.log.error\n    @internal\n     */\n    error = function() {\n      var args, message;\n      message = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      if (message) {\n        return console.error.apply(console, [prefix(message)].concat(slice.call(args)));\n      }\n    };\n    printBanner = function() {\n      var banner;\n      banner = \" __ _____  ___  ___  / /_ __\\n\" + (\"/ // / _ \\\\/ _ \\\\/ _ \\\\/ / // /  \" + up.version + \"\\n\") + \"\\\\___/_//_/ .__/\\\\___/_/\\\\_. / \\n\" + \"        / /            / /\\n\" + \"\\n\";\n      if (config.enabled) {\n        banner += \"Call `up.log.disable()` to disable logging for this session.\";\n      } else {\n        banner += \"Call `up.log.enable()` to enable logging for this session.\";\n      }\n      return console.log(banner);\n    };\n    up.on('up:framework:booted', printBanner);\n    up.on('up:framework:reset', reset);\n    setEnabled = function(value) {\n      sessionStore.set('enabled', value);\n      return config.enabled = value;\n    };\n\n    /***\n    Makes future Unpoly events print vast amounts of debugging information to the developer console.\n    \n    Debugging information includes which elements are being [compiled](/up.syntax)\n    and which [events](/up.event) are being emitted.\n    \n    @function up.log.enable\n    @stable\n     */\n    enable = function() {\n      return setEnabled(true);\n    };\n\n    /***\n    Prevents future Unpoly events from printing vast amounts of debugging information to the developer console.\n    \n    Errors will still be printed, even with logging disabled.\n    \n    @function up.log.disable\n    @stable\n     */\n    disable = function() {\n      return setEnabled(false);\n    };\n    return {\n      puts: puts,\n      sprintf: sprintf,\n      sprintfWithFormattedArgs: sprintfWithFormattedArgs,\n      puts: puts,\n      debug: debug,\n      error: error,\n      warn: warn,\n      group: group,\n      config: config,\n      enable: enable,\n      disable: disable,\n      isEnabled: function() {\n        return config.enabled;\n      }\n    };\n  })();\n\n  up.puts = up.log.puts;\n\n  up.warn = up.log.warn;\n\n}).call(this);\n\n/***\nToast alerts\n============\n\n@module up.toast\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.toast = (function() {\n    var VARIABLE_FORMATTER, addAction, close, e, isOpen, messageToHtml, open, reset, state, u;\n    u = up.util;\n    e = up.element;\n    VARIABLE_FORMATTER = function(arg) {\n      return \"<span class='up-toast-variable'>\" + (u.escapeHtml(arg)) + \"</span>\";\n    };\n    state = new up.Config({\n      element: null\n    });\n    reset = function() {\n      close();\n      return state.reset();\n    };\n    messageToHtml = function(message) {\n      var ref;\n      if (u.isArray(message)) {\n        message[0] = u.escapeHtml(message[0]);\n        message = (ref = up.log).sprintfWithFormattedArgs.apply(ref, [VARIABLE_FORMATTER].concat(slice.call(message)));\n      } else {\n        message = u.escapeHtml(message);\n      }\n      return message;\n    };\n    isOpen = function() {\n      return !!state.element;\n    };\n    addAction = function(label, callback) {\n      var action, actions;\n      actions = state.element.querySelector('.up-toast-actions');\n      action = e.affix(actions, '.up-toast-action');\n      action.innerText = label;\n      return action.addEventListener('click', callback);\n    };\n    open = function(message, options) {\n      var action;\n      if (options == null) {\n        options = {};\n      }\n      close();\n      message = messageToHtml(message);\n      state.element = e.createFromHtml(\"<div class=\\\"up-toast\\\">\\n  <div class=\\\"up-toast-message\\\">\" + message + \"</div>\\n  <div class=\\\"up-toast-actions\\\"></div>\\n</div>\");\n      if (action = options.action || options.inspect) {\n        addAction(action.label, action.callback);\n      }\n      addAction('Close', close);\n      return document.body.appendChild(state.element);\n    };\n    close = function() {\n      if (isOpen()) {\n        e.remove(state.element);\n        return state.element = null;\n      }\n    };\n    up.on('up:framework:reset', reset);\n    return {\n      open: open,\n      close: close,\n      reset: reset,\n      isOpen: isOpen\n    };\n  })();\n\n}).call(this);\n\n/***\nCustom JavaScript\n=================\n\nEvery app needs a way to pair JavaScript snippets with certain HTML elements,\nin order to integrate libraries or implement custom behavior.\n\nUnpoly lets you organize your JavaScript snippets using [compilers](/up.compiler).\n\nFor instance, to activate the [Masonry](http://masonry.desandro.com/) library for every element\nwith a `grid` class, use this compiler:\n\n    up.compiler('.grid', function(element) {\n      new Masonry(element, { itemSelector: '.grid--item' })\n    })\n\nThe compiler function will be called on matching elements when the page loads\nor when a matching fragment is [inserted via AJAX](/up.link) later.\n\n@module up.syntax\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.syntax = (function() {\n    var SYSTEM_MACRO_PRIORITIES, buildCompiler, clean, compile, compilers, detectSystemMacroPriority, e, insertCompiler, macros, parseCompilerArgs, readData, registerCompiler, registerDestructor, registerJQueryCompiler, registerJQueryMacro, registerMacro, reset, u;\n    u = up.util;\n    e = up.element;\n    SYSTEM_MACRO_PRIORITIES = {\n      '[up-back]': -100,\n      '[up-drawer]': -200,\n      '[up-dash]': -200,\n      '[up-expand]': -300,\n      '[data-method]': -400,\n      '[data-confirm]': -400\n    };\n    compilers = [];\n    macros = [];\n\n    /***\n    Registers a function to be called when an element with\n    the given selector is inserted into the DOM.\n    \n    Use compilers to activate your custom Javascript behavior on matching\n    elements.\n    \n    You should migrate your [`DOMContentLoaded`](https://api.jquery.com/ready/)\n    callbacks to compilers. This will make sure they run both at page load and\n    when [a new fragment is inserted later](/a-up-target).\n    It will also organize your JavaScript snippets by selector of affected elements.\n    \n    \n    \\#\\#\\# Example\n    \n    This jQuery compiler will insert the current time into a\n    `<div class='current-time'></div>`:\n    \n        up.compiler('.current-time', function(element) {\n          var now = new Date()\n          element.textContent = now.toString()\n        })\n    \n    The compiler function will be called once for each matching element when\n    the page loads, or when a matching fragment is [inserted](/up.replace) later.\n    \n    \n    \\#\\#\\# Integrating JavaScript libraries\n    \n    `up.compiler()` is a great way to integrate JavaScript libraries.\n    Let's say your JavaScript plugin wants you to call `lightboxify()`\n    on links that should open a lightbox. You decide to\n    do this for all links with an `lightbox` class:\n    \n        <a href=\"river.png\" class=\"lightbox\">River</a>\n        <a href=\"ocean.png\" class=\"lightbox\">Ocean</a>\n    \n    This JavaScript will do exactly that:\n    \n        up.compiler('a.lightbox', function(element) {\n          lightboxify(element)\n        })\n    \n    \\#\\#\\# Cleaning up after yourself\n    \n    If your compiler returns a function, Unpoly will use this as a *destructor* to\n    clean up if the element leaves the DOM. Note that in Unpoly the same DOM and JavaScript environment\n    will persist through many page loads, so it's important to not create\n    [memory leaks](https://makandracards.com/makandra/31325-how-to-create-memory-leaks-in-jquery).\n    \n    You should clean up after yourself whenever your compilers have global\n    side effects, like a [`setInterval`](https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval)\n    or [event handlers bound to the document root](/up.on).\n    \n    Here is a version of `.current-time` that updates\n    the time every second, and cleans up once it's done. Note how it returns\n    a function that calls `clearInterval`:\n    \n        up.compiler('.current-time', function(element) {\n    \n          function update() {\n            var now = new Date()\n            element.textContent = now.toString()\n          }\n    \n          setInterval(update, 1000)\n    \n          return function() {\n            clearInterval(update)\n          };\n    \n        })\n    \n    If we didn't clean up after ourselves, we would have many ticking intervals\n    operating on detached DOM elements after we have created and removed a couple\n    of `<clock>` elements.\n    \n    \n    \\#\\#\\# Attaching structured data\n    \n    In case you want to attach structured data to the event you're observing,\n    you can serialize the data to JSON and put it into an `[up-data]` attribute.\n    For instance, a container for a [Google Map](https://developers.google.com/maps/documentation/javascript/tutorial)\n    might attach the location and names of its marker pins:\n    \n        <div class='google-map' up-data='[\n          { \"lat\": 48.36, \"lng\": 10.99, \"title\": \"Friedberg\" },\n          { \"lat\": 48.75, \"lng\": 11.45, \"title\": \"Ingolstadt\" }\n        ]'></div>\n    \n    The JSON will be parsed and handed to your compiler as a second argument:\n    \n        up.compiler('.google-map', function(element, pins) {\n          var map = new google.maps.Map(element)\n    \n          pins.forEach(function(pin) {\n            var position = new google.maps.LatLng(pin.lat, pin.lng)\n            new google.maps.Marker({\n              position: position,\n              map: map,\n              title: pin.title\n            })\n          })\n        })\n    \n    \n    @function up.compiler\n    @param {string} selector\n      The selector to match.\n    @param {number} [options.priority=0]\n      The priority of this compiler.\n      Compilers with a higher priority are run first.\n      Two compilers with the same priority are run in the order they were registered.\n    @param {boolean} [options.batch=false]\n      If set to `true` and a fragment insertion contains multiple\n      elements matching the selector, `compiler` is only called once\n      with a jQuery collection containing all matching elements. \n    @param {boolean} [options.keep=false]\n      If set to `true` compiled fragment will be [persisted](/up-keep) during\n      [page updates](/a-up-target).\n    \n      This has the same effect as setting an `up-keep` attribute on the element.\n    @param {Function(element, data)} compiler\n      The function to call when a matching element is inserted.\n    \n      The function takes the new element as the first argument.\n      If the element has an [`up-data`](/up-data) attribute, its value is parsed as JSON\n      and passed as a second argument.\n    \n      The function may return a destructor function that cleans the compiled\n      object before it is removed from the DOM. The destructor is supposed to\n      [clear global state](/up.compiler#cleaning-up-after-yourself)\n      such as timeouts and event handlers bound to the document.\n      The destructor is *not* expected to remove the element from the DOM, which\n      is already handled by [`up.destroy()`](/up.destroy).\n    @stable\n     */\n    registerCompiler = function() {\n      var args, compiler;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      compiler = buildCompiler(args);\n      return insertCompiler(compilers, compiler);\n    };\n\n    /***\n    Registers a function to be called when an element with\n    the given selector is inserted into the DOM. The function is called\n    with each matching element as a\n    [jQuery object](https://learn.jquery.com/using-jquery-core/jquery-object/).\n    \n    If you're not using jQuery, use `up.compiler()` instead, which calls\n    the compiler function with a native element.\n    \n    \\#\\#\\# Example\n    \n    This jQuery compiler will insert the current time into a\n    `<div class='current-time'></div>`:\n    \n        up.$compiler('.current-time', function($element) {\n          var now = new Date()\n          $element.text(now.toString())\n        })\n    \n    @function up.$compiler\n    @param {string} selector\n      The selector to match.\n    @param {Object} [options]\n      See [`options` argument for `up.compiler()`](/up.compiler#parameters).\n    @param {Function($element, data)} compiler\n      The function to call when a matching element is inserted.\n    \n      See [`compiler` argument for `up.compiler()`](/up.compiler#parameters).\n      @stable\n     */\n    registerJQueryCompiler = function() {\n      var args, compiler;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      compiler = registerCompiler.apply(null, args);\n      compiler.jQuery = true;\n      return compiler;\n    };\n\n    /***\n    Registers a [compiler](/up.compiler) that is run before all other compilers.\n    \n    Use `up.macro()` to register a compiler that sets multiple Unpoly attributes.\n    \n    \\#\\#\\# Example\n    \n    You will sometimes find yourself setting the same combination of UJS attributes again and again:\n    \n        <a href=\"/page1\" up-target=\".content\" up-transition=\"cross-fade\" up-duration=\"300\">Page 1</a>\n        <a href=\"/page2\" up-target=\".content\" up-transition=\"cross-fade\" up-duration=\"300\">Page 2</a>\n        <a href=\"/page3\" up-target=\".content\" up-transition=\"cross-fade\" up-duration=\"300\">Page 3</a>\n    \n    We would much rather define a new `[content-link]` attribute that let's us\n    write the same links like this:\n    \n        <a href=\"/page1\" content-link>Page 1</a>\n        <a href=\"/page2\" content-link>Page 2</a>\n        <a href=\"/page3\" content-link>Page 3</a>\n    \n    We can define the `[content-link]` attribute by registering a macro that\n    sets the `[up-target]`, `[up-transition]` and `[up-duration]` attributes for us:\n    \n        up.macro('[content-link]', function(link) {\n          link.setAttribute('up-target', '.content')\n          link.setAttribute('up-transition', 'cross-fade')\n          link.setAttribute('up-duration', '300')\n        })\n    \n    Examples for built-in macros are [`a[up-dash]`](/a-up-dash) and [`[up-expand]`](/up-expand).\n    \n    @function up.macro\n    @param {string} selector\n      The selector to match.\n    @param {Object} options\n      See options for [`up.compiler()`](/up.compiler).\n    @param {Function(element, data)} macro\n      The function to call when a matching element is inserted.\n    \n      See [`up.compiler()`](/up.compiler#parameters) for details.\n    @stable\n     */\n    registerMacro = function() {\n      var args, macro;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      macro = buildCompiler(args);\n      if (up.framework.isBooting()) {\n        macro.priority = detectSystemMacroPriority(macro.selector) || up.fail('Unregistered priority for system macro %o', macro.selector);\n      }\n      return insertCompiler(macros, macro);\n    };\n\n    /***\n    Registers a [compiler](/up.compiler) that is run before all other compilers.\n    The compiler function is called with each matching element as a\n    [jQuery object](https://learn.jquery.com/using-jquery-core/jquery-object/).\n    \n    If you're not using jQuery, use `up.macro()` instead, which calls\n    the macro function with a native element.\n    \n    \\#\\#\\# Example\n    \n        up.$macro('[content-link]', function($link) {\n          $link.attr(\n            'up-target': '.content',\n            'up-transition': 'cross-fade',\n            'up-duration':'300'\n          )\n        })\n    \n    @function up.$macro\n    @param {string} selector\n      The selector to match.\n    @param {Object} options\n      See [`options` argument for `up.compiler()`](/up.compiler#parameters).\n    @param {Function(element, data)} macro\n      The function to call when a matching element is inserted.\n    \n      See [`compiler` argument for `up.compiler()`](/up.compiler#parameters).\n    @stable\n     */\n    registerJQueryMacro = function() {\n      var args, macro;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      macro = registerMacro.apply(null, args);\n      macro.jQuery = true;\n      return macro;\n    };\n    detectSystemMacroPriority = function(macroSelector) {\n      var priority, substr;\n      for (substr in SYSTEM_MACRO_PRIORITIES) {\n        priority = SYSTEM_MACRO_PRIORITIES[substr];\n        if (macroSelector.indexOf(substr) >= 0) {\n          return priority;\n        }\n      }\n    };\n    parseCompilerArgs = function(args) {\n      var callback, options, selector;\n      selector = args.shift();\n      callback = args.pop();\n      options = u.extractOptions(args);\n      return [selector, options, callback];\n    };\n    buildCompiler = function(args) {\n      var callback, options, ref, selector;\n      ref = parseCompilerArgs(args), selector = ref[0], options = ref[1], callback = ref[2];\n      options = u.options(options, {\n        selector: selector,\n        isDefault: up.framework.isBooting(),\n        priority: 0,\n        batch: false,\n        keep: false,\n        jQuery: false\n      });\n      return u.assign(callback, options);\n    };\n    insertCompiler = function(queue, newCompiler) {\n      var existingCompiler, index;\n      index = 0;\n      while ((existingCompiler = queue[index]) && (existingCompiler.priority >= newCompiler.priority)) {\n        index += 1;\n      }\n      queue.splice(index, 0, newCompiler);\n      return newCompiler;\n    };\n\n    /***\n    Applies all compilers on the given element and its descendants.\n    Unlike [`up.hello()`](/up.hello), this doesn't emit any events.\n    \n    @function up.syntax.compile\n    @param {Array<Element>} [options.skip]\n      A list of elements whose subtrees should not be compiled.\n    @internal\n     */\n    compile = function(fragment, options) {\n      var compileRun, orderedCompilers;\n      orderedCompilers = macros.concat(compilers);\n      compileRun = new up.CompilePass(fragment, orderedCompilers, options);\n      return compileRun.compile();\n    };\n\n    /***\n    Registers a function to be called when the given element\n    is [destroyed](/up.destroy).\n    \n    The preferred way to register a destructor function is to `return`\n    it from a [compiler function](/up.compiler).\n    \n    @function up.destructor\n    @param {Element} element\n    @param {Function|Array<Function>} destructor\n      One or more destructor functions\n    @internal\n     */\n    registerDestructor = function(element, destructor) {\n      var destructors;\n      if (!(destructors = element.upDestructors)) {\n        destructors = [];\n        element.upDestructors = destructors;\n        element.classList.add('up-can-clean');\n      }\n      if (u.isArray(destructor)) {\n        return destructors.push.apply(destructors, destructor);\n      } else {\n        return destructors.push(destructor);\n      }\n    };\n\n    /***\n    Runs any destructor on the given fragment and its descendants.\n    Unlike [`up.destroy()`](/up.destroy), this doesn't emit any events\n    and does not remove the element from the DOM.\n    \n    @function up.syntax.clean\n    @internal\n     */\n    clean = function(fragment) {\n      var cleanables;\n      cleanables = e.subtree(fragment, '.up-can-clean');\n      return u.each(cleanables, function(cleanable) {\n        var destructor, destructors, i, len;\n        if (destructors = u.pluckKey(cleanable, 'upDestructors')) {\n          for (i = 0, len = destructors.length; i < len; i++) {\n            destructor = destructors[i];\n            destructor();\n          }\n        }\n        return cleanable.classList.remove('up-can-clean');\n      });\n    };\n\n    /***\n    Checks if the given element has an [`up-data`](/up-data) attribute.\n    If yes, parses the attribute value as JSON and returns the parsed object.\n    \n    Returns `undefined` if the element has no `up-data` attribute.\n    \n    \\#\\#\\# Example\n    \n    You have an element with JSON data serialized into an `up-data` attribute:\n    \n        <span class='person' up-data='{ \"age\": 18, \"name\": \"Bob\" }'>Bob</span>\n    \n    Calling `up.syntax.data()` will deserialize the JSON string into a JavaScript object:\n    \n        up.syntax.data('.person') // returns { age: 18, name: 'Bob' }\n    \n    @function up.syntax.data\n    @param {string|Element|jQuery} elementOrSelector\n    @return\n      The JSON-decoded value of the `up-data` attribute.\n    \n      Returns `undefined` if the element has no (or an empty) `up-data` attribute.\n    @experimental\n     */\n\n    /***\n    If an element with an `up-data` attribute enters the DOM,\n    Unpoly will parse the JSON and pass the resulting object to any matching\n    [`up.compiler()`](/up.compiler) handlers.\n    \n    For instance, a container for a [Google Map](https://developers.google.com/maps/documentation/javascript/tutorial)\n    might attach the location and names of its marker pins:\n    \n        <div class='google-map' up-data='[\n          { \"lat\": 48.36, \"lng\": 10.99, \"title\": \"Friedberg\" },\n          { \"lat\": 48.75, \"lng\": 11.45, \"title\": \"Ingolstadt\" }\n        ]'></div>\n    \n    The JSON will be parsed and handed to your compiler as a second argument:\n    \n        up.compiler('.google-map', function(element, pins) {\n          var map = new google.maps.Map(element)\n          pins.forEach(function(pin) {\n            var position = new google.maps.LatLng(pin.lat, pin.lng)\n            new google.maps.Marker({\n              position: position,\n              map: map,\n              title: pin.title\n            })\n          })\n        })\n    \n    Similarly, when an event is triggered on an element annotated with\n    [`up-data`], the parsed object will be passed to any matching\n    [`up.on()`](/up.on) handlers.\n    \n        up.on('click', '.google-map', function(event, element, pins) {\n          console.log(\"There are %d pins on the clicked map\", pins.length)\n        })\n    \n    @selector [up-data]\n    @param {JSON} up-data\n      A serialized JSON string\n    @stable\n     */\n    readData = function(elementOrSelector) {\n      var element;\n      element = e.get(elementOrSelector);\n      return e.jsonAttr(element, 'up-data') || {};\n    };\n\n    /***\n    Resets the list of registered compiler directives to the\n    moment when the framework was booted.\n    \n    @internal\n     */\n    reset = function() {\n      compilers = u.filter(compilers, 'isDefault');\n      return macros = u.filter(macros, 'isDefault');\n    };\n    up.on('up:framework:reset', reset);\n    return {\n      compiler: registerCompiler,\n      macro: registerMacro,\n      $compiler: registerJQueryCompiler,\n      $macro: registerJQueryMacro,\n      destructor: registerDestructor,\n      compile: compile,\n      clean: clean,\n      data: readData\n    };\n  })();\n\n  up.compiler = up.syntax.compiler;\n\n  up.$compiler = up.syntax.$compiler;\n\n  up.destructor = up.syntax.destructor;\n\n  up.macro = up.syntax.macro;\n\n  up.$macro = up.syntax.$macro;\n\n}).call(this);\n\n/***\nHistory\n========\n\nIn an Unpoly app, every page has an URL.\n\n[Fragment updates](/up.link) automatically update the URL.\n\n@module up.history\n */\n\n(function() {\n  up.history = (function() {\n    var buildState, config, currentUrl, e, isCurrentUrl, manipulate, nextPreviousUrl, normalizeUrl, observeNewUrl, pop, previousUrl, push, replace, reset, restoreStateOnPop, u;\n    u = up.util;\n    e = up.element;\n\n    /***\n    Configures behavior when the user goes back or forward in browser history.\n    \n    @property up.history.config\n    @param {Array} [config.popTargets=['body']]\n      An array of CSS selectors to replace when the user goes\n      back in history.\n    @param {boolean} [config.restoreScroll=true]\n      Whether to restore the known scroll positions\n      when the user goes back or forward in history.\n    @stable\n     */\n    config = new up.Config({\n      enabled: true,\n      popTargets: ['body'],\n      restoreScroll: true\n    });\n\n    /***\n    Returns the previous URL in the browser history.\n    \n    Note that this will only work reliably for history changes that\n    were applied by [`up.history.push()`](/up.history.replace) or\n    [`up.history.replace()`](/up.history.replace).\n    \n    @function up.history.previousUrl\n    @internal\n     */\n    previousUrl = void 0;\n    nextPreviousUrl = void 0;\n    reset = function() {\n      config.reset();\n      previousUrl = void 0;\n      return nextPreviousUrl = void 0;\n    };\n    normalizeUrl = function(url, normalizeOptions) {\n      normalizeOptions || (normalizeOptions = {});\n      normalizeOptions.hash = true;\n      return u.normalizeUrl(url, normalizeOptions);\n    };\n\n    /***\n    Returns a normalized URL for the current history entry.\n    \n    @function up.history.url\n    @experimental\n     */\n    currentUrl = function(normalizeOptions) {\n      return normalizeUrl(up.browser.url(), normalizeOptions);\n    };\n    isCurrentUrl = function(url) {\n      var normalizeOptions;\n      normalizeOptions = {\n        stripTrailingSlash: true\n      };\n      return normalizeUrl(url, normalizeOptions) === currentUrl(normalizeOptions);\n    };\n\n    /***\n    Remembers the given URL so we can offer `up.history.previousUrl()`.\n    \n    @function observeNewUrl\n    @internal\n     */\n    observeNewUrl = function(url) {\n      if (nextPreviousUrl) {\n        previousUrl = nextPreviousUrl;\n        nextPreviousUrl = void 0;\n      }\n      return nextPreviousUrl = url;\n    };\n\n    /***\n    Replaces the current history entry and updates the\n    browser's location bar with the given URL.\n    \n    When the user navigates to the replaced history entry at a later time,\n    Unpoly will [`replace`](/up.replace) the document body with\n    the body from that URL.\n    \n    Note that functions like [`up.replace()`](/up.replace) or\n    [`up.submit()`](/up.submit) will automatically update the\n    browser's location bar for you.\n    \n    @function up.history.replace\n    @param {string} url\n    @internal\n     */\n    replace = function(url) {\n      if (manipulate('replaceState', url)) {\n        return up.emit('up:history:replaced', {\n          url: url\n        });\n      }\n    };\n\n    /***\n    Adds a new history entry and updates the browser's\n    address bar with the given URL.\n    \n    When the user navigates to the added  history entry at a later time,\n    Unpoly will [`replace`](/up.replace) the document body with\n    the body from that URL.\n    \n    Note that functions like [`up.replace()`](/up.replace) or\n    [`up.submit()`](/up.submit) will automatically update the\n    browser's location bar for you.\n    \n    Emits events [`up:history:push`](/up:history:push) and [`up:history:pushed`](/up:history:pushed).\n    \n    @function up.history.push\n    @param {string} url\n      The URL for the history entry to be added.\n    @experimental\n     */\n    push = function(url, options) {\n      options = u.options(options, {\n        force: false\n      });\n      url = normalizeUrl(url);\n      if ((options.force || !isCurrentUrl(url)) && up.event.nobodyPrevents('up:history:push', {\n        url: url,\n        log: \"Adding history entry for \" + url\n      })) {\n        if (manipulate('pushState', url)) {\n          return up.emit('up:history:pushed', {\n            url: url,\n            log: \"Advanced to location \" + url\n          });\n        } else {\n          return up.emit('up:history:muted', {\n            url: url,\n            log: \"Did not advance to \" + url + \" (history is unavailable)\"\n          });\n        }\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) before a new history entry is added.\n    \n    @event up:history:push\n    @param {string} event.url\n      The URL for the history entry that is going to be added.\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the history entry from being added.\n    @experimental\n     */\n\n    /***\n    This event is [emitted](/up.emit) after a new history entry has been added.\n    \n    @event up:history:pushed\n    @param {string} event.url\n      The URL for the history entry that has been added.\n    @experimental\n     */\n    manipulate = function(method, url) {\n      var state;\n      if (up.browser.canPushState() && config.enabled) {\n        state = buildState();\n        window.history[method](state, '', url);\n        observeNewUrl(currentUrl());\n        return true;\n      } else {\n        return false;\n      }\n    };\n    buildState = function() {\n      return {\n        fromUp: true\n      };\n    };\n    restoreStateOnPop = function(state) {\n      var popSelector, replaced, url;\n      if (state != null ? state.fromUp : void 0) {\n        url = currentUrl();\n        up.emit('up:history:restore', {\n          url: url,\n          log: \"Restoring location \" + url\n        });\n        popSelector = config.popTargets.join(', ');\n        replaced = up.replace(popSelector, url, {\n          history: false,\n          title: true,\n          reveal: false,\n          saveScroll: false,\n          restoreScroll: config.restoreScroll,\n          layer: 'page'\n        });\n        return replaced.then(function() {\n          url = currentUrl();\n          return up.emit('up:history:restored', {\n            url: url,\n            log: \"Restored location \" + url\n          });\n        });\n      } else {\n        return up.puts('Ignoring a state not pushed by Unpoly (%o)', state);\n      }\n    };\n    pop = function(event) {\n      var state;\n      observeNewUrl(currentUrl());\n      up.viewport.saveScroll({\n        url: previousUrl\n      });\n      state = event.state;\n      return restoreStateOnPop(state);\n    };\n\n    /***\n    This event is [emitted](/up.emit) before a history entry will be restored.\n    \n    History entries are restored when the user uses the *Back* or *Forward* button.\n    \n    @event up:history:restore\n    @param {string} event.url\n      The URL for the history entry that has been restored.\n    @internal\n     */\n\n    /***\n    This event is [emitted](/up.emit) after a history entry has been restored.\n    \n    History entries are restored when the user uses the *Back* or *Forward* button.\n    \n    @event up:history:restored\n    @param {string} event.url\n      The URL for the history entry that has been restored.\n    @experimental\n     */\n    up.on('up:app:boot', function() {\n      var register;\n      if (up.browser.canPushState()) {\n        register = function() {\n          if (up.browser.canControlScrollRestoration()) {\n            window.history.scrollRestoration = 'manual';\n          }\n          window.addEventListener('popstate', pop);\n          return replace(currentUrl(), {\n            force: true\n          });\n        };\n        if (typeof jasmine !== \"undefined\" && jasmine !== null) {\n          return register();\n        } else {\n          return setTimeout(register, 100);\n        }\n      }\n    });\n\n    /***\n    Changes the link's destination so it points to the previous URL.\n    \n    Note that this will *not* call `location.back()`, but will set\n    the link's `up-href` attribute to the actual, previous URL.\n    \n    If no previous URL is known, the link will not be changed.\n    \n    \\#\\#\\# Example\n    \n    This link ...\n    \n        <a href=\"/default\" up-back>\n          Go back\n        </a>\n    \n    ... will be transformed to:\n    \n        <a href=\"/default\" up-href=\"/previous-page\" up-restore-scroll up-follow>\n          Go back\n        </a>\n    \n    @selector a[up-back]\n    @stable\n     */\n    up.macro('a[up-back], [up-href][up-back]', function(link) {\n      if (u.isPresent(previousUrl)) {\n        e.setMissingAttrs(link, {\n          'up-href': previousUrl,\n          'up-restore-scroll': ''\n        });\n        link.removeAttribute('up-back');\n        return up.link.makeFollowable(link);\n      }\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      config: config,\n      push: push,\n      replace: replace,\n      url: currentUrl,\n      isUrl: isCurrentUrl,\n      previousUrl: function() {\n        return previousUrl;\n      },\n      normalizeUrl: normalizeUrl\n    };\n  })();\n\n}).call(this);\n\n/***\nScrolling viewports\n===================\n\nThe `up.viewport` module controls the scroll position of scrollable containers (\"viewports\").\n\nThe default viewport for any web application is the main document. An application may\ndefine additional viewports by giving the CSS property `{ overflow-y: scroll }` to any `<div>`.\n\n\n\\#\\#\\# Revealing new content\n\nWhen following a [link to a fragment](/a-up-target) Unpoly will automatically\nscroll the document's viewport to [reveal](/up.viewport) the updated content.\n\nYou should [make Unpoly aware](/up.viewport.config#config.fixedTop) of fixed elements in your\nlayout, such as navigation bars or headers. Unpoly will respect these sticky\nelements when [revealing updated fragments](/up.reveal).\n\nYou should also [tell Unpoly](/up.viewport.config#config.viewports) when your application has more than one viewport,\nso Unpoly can pick the right viewport to scroll for each fragment update.\n\n\n\\#\\#\\# Bootstrap integration\n\nWhen using Bootstrap integration (`unpoly-bootstrap3.js` and `unpoly-bootstrap3.css`)\nUnpoly will automatically be aware of sticky Bootstrap components such as\n[fixed navbar](https://getbootstrap.com/examples/navbar-fixed-top/).\n\n@module up.viewport\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.viewport = (function() {\n    var absolutize, allSelector, anchoredRight, closest, config, e, finishScrolling, firstHashTarget, fixedElements, getAll, getAround, getRoot, getSubtree, isRoot, lastScrollTops, measureObstruction, pureHash, reset, restoreScroll, reveal, revealHash, rootHasVerticalScrollbar, rootHeight, rootOverflowElement, rootSelector, rootWidth, saveScroll, scroll, scrollAfterInsertFragment, scrollTopKey, scrollTops, scrollbarWidth, scrollingController, u, wasChosenAsOverflowingElement;\n    u = up.util;\n    e = up.element;\n\n    /***\n    Configures the application layout.\n    \n    @property up.viewport.config\n    @param {Array} [config.viewports]\n      An array of CSS selectors that find viewports\n      (containers that scroll their contents).\n    @param {Array} [config.fixedTop]\n      An array of CSS selectors that find elements fixed to the\n      top edge of the screen (using `position: fixed`).\n      See [`[up-fixed=\"top\"]`](/up-fixed-top) for details.\n    @param {Array} [config.fixedBottom]\n      An array of CSS selectors that find elements fixed to the\n      bottom edge of the screen (using `position: fixed`).\n      See [`[up-fixed=\"bottom\"]`](/up-fixed-bottom) for details.\n    @param {Array} [config.anchoredRight]\n      An array of CSS selectors that find elements anchored to the\n      right edge of the screen (using `right:0` with `position: fixed` or `position: absolute`).\n      See [`[up-anchored=\"right\"]`](/up-anchored-right) for details.\n    @param {number} [config.revealSnap=50]\n      When [revealing](/up.reveal) elements, Unpoly will scroll an viewport\n      to the top when the revealed element is closer to the top than `config.revealSnap`.\n    @param {number} [config.revealPadding=0]\n      The desired padding between a [revealed](/up.reveal) element and the\n      closest [viewport](/up.viewport) edge (in pixels).\n    @param {number} [config.scrollSpeed=1]\n      The speed of the scrolling motion when [scrolling](/up.scroll) with `{ behavior: 'smooth' }`.\n    \n      The default value (`1`) roughly corresponds to the speed of Chrome's\n      [native smooth scrolling](https://developer.mozilla.org/en-US/docs/Web/API/ScrollToOptions/behavior).\n    @stable\n     */\n    config = new up.Config({\n      duration: 0,\n      viewports: ['.up-modal-viewport', '[up-viewport]', '[up-fixed]'],\n      fixedTop: ['[up-fixed~=top]'],\n      fixedBottom: ['[up-fixed~=bottom]'],\n      anchoredRight: ['[up-anchored~=right]', '[up-fixed~=top]', '[up-fixed~=bottom]', '[up-fixed~=right]'],\n      revealSnap: 50,\n      revealPadding: 0,\n      scrollSpeed: 1\n    });\n    lastScrollTops = new up.Cache({\n      size: 30,\n      key: up.history.normalizeUrl\n    });\n    scrollingController = new up.MotionController('scrolling');\n    reset = function() {\n      config.reset();\n      lastScrollTops.clear();\n      return scrollingController.reset();\n    };\n\n    /***\n    Scrolls the given viewport to the given Y-position.\n    \n    A \"viewport\" is an element that has scrollbars, e.g. `<body>` or\n    a container with `overflow-x: scroll`.\n    \n    \\#\\#\\# Example\n    \n    This will scroll a `<div class=\"main\">...</div>` to a Y-position of 100 pixels:\n    \n        up.scroll('.main', 100)\n    \n    \\#\\#\\# Animating the scrolling motion\n    \n    The scrolling can (optionally) be animated.\n    \n        up.scroll('.main', 100, { behavior: 'smooth' })\n    \n    If the given viewport is already in a scroll animation when `up.scroll()`\n    is called a second time, the previous animation will instantly jump to the\n    last frame before the next animation is started.\n    \n    @function up.scroll\n    @param {string|Element|jQuery} viewport\n      The container element to scroll.\n    @param {number} scrollPos\n      The absolute number of pixels to set the scroll position to.\n    @param {string}[options.behavior='auto']\n      When set to `'auto'`, this will immediately scroll to the new position.\n    \n      When set to `'smooth'`, this will scroll smoothly to the new position.\n    @param {number}[options.speed]\n      The speed of the scrolling motion when scrolling with `{ behavior: 'smooth' }`.\n    \n      Defaults to `up.viewport.config.scrollSpeed`.\n    @return {Promise}\n      A promise that will be fulfilled when the scrolling ends.\n    @experimental\n     */\n    scroll = function(viewport, scrollTop, options) {\n      var motion;\n      motion = new up.ScrollMotion(viewport, scrollTop, options);\n      return scrollingController.startMotion(viewport, motion, options);\n    };\n\n    /***\n    Finishes scrolling animations in the given element, its ancestors or its descendants.\n    \n    @function up.viewport.finishScrolling\n    @param {string|Element|jQuery}\n    @return {Promise}\n    @internal\n     */\n    finishScrolling = function(element) {\n      var scrollable;\n      if (!up.motion.isEnabled()) {\n        return Promise.resolve();\n      }\n      scrollable = closest(element);\n      return scrollingController.finish(scrollable);\n    };\n\n    /***\n    @function up.viewport.anchoredRight\n    @internal\n     */\n    anchoredRight = function() {\n      var selector;\n      selector = config.anchoredRight.join(',');\n      return e.all(selector);\n    };\n\n    /***\n    @function measureObstruction\n    @return {Object}\n    @internal\n     */\n    measureObstruction = function(viewportHeight) {\n      var bottomObstructions, bottomObstructors, composeHeight, measureBottomObstructor, measureTopObstructor, topObstructions, topObstructors;\n      composeHeight = function(obstructor, distanceFromEdgeProps) {\n        var distanceFromEdge;\n        distanceFromEdge = u.sum(distanceFromEdgeProps, function(prop) {\n          return e.styleNumber(obstructor, prop);\n        }) || 0;\n        return distanceFromEdge + obstructor.offsetHeight;\n      };\n      measureTopObstructor = function(obstructor) {\n        return composeHeight(obstructor, ['top', 'margin-top']);\n      };\n      measureBottomObstructor = function(obstructor) {\n        return composeHeight(obstructor, ['bottom', 'margin-bottom']);\n      };\n      topObstructors = e.all(config.fixedTop.join(', '));\n      bottomObstructors = e.all(config.fixedBottom.join(', '));\n      topObstructions = u.map(topObstructors, measureTopObstructor);\n      bottomObstructions = u.map(bottomObstructors, measureBottomObstructor);\n      return {\n        top: Math.max.apply(Math, [0].concat(slice.call(topObstructions))),\n        bottom: Math.max.apply(Math, [0].concat(slice.call(bottomObstructions)))\n      };\n    };\n\n    /***\n    Scroll's the given element's viewport so the first rows of the\n    element are visible for the user.\n    \n    By default Unpoly will always reveal an element before\n    updating it with JavaScript functions like [`up.replace()`](/up.replace)\n    or UJS behavior like [`[up-target]`](/a-up-target).\n    \n    \\#\\#\\# How Unpoly finds the viewport\n    \n    The viewport (the container that is going to be scrolled)\n    is the closest parent of the element that is either:\n    \n    - the currently open [modal](/up.modal)\n    - an element with the attribute `[up-viewport]`\n    - the `<body>` element\n    - an element matching the selector you have configured using `up.viewport.config.viewports.push('my-custom-selector')`\n    \n    \\#\\#\\# Fixed elements obstruction the viewport\n    \n    Many applications have a navigation bar fixed to the top or bottom,\n    obstructing the view on an element.\n    \n    You can make `up.reveal()` aware of these fixed elements\n    so it can scroll the viewport far enough so the revealed element is fully visible.\n    To make `up.reveal()` aware fixed elements you can either:\n    \n    - give the element an attribute [`up-fixed=\"top\"`](/up-fixed-top) or [`up-fixed=\"bottom\"`](up-fixed-bottom)\n    - [configure default options](/up.viewport.config) for `fixedTop` or `fixedBottom`\n    \n    @function up.reveal\n    @param {string|Element|jQuery} element\n    @param {number} [options.speed]\n    @param {string} [options.snap]\n    @param {string|Element|jQuery} [options.viewport]\n    @param {boolean} [options.top=false]\n      Whether to scroll the viewport so that the first element row aligns\n      with the top edge of the viewport.\n    @param {string}[options.behavior='auto']\n      When set to `'auto'`, this will immediately scroll to the new position.\n    \n      When set to `'smooth'`, this will scroll smoothly to the new position.\n    @param {number}[options.speed]\n      The speed of the scrolling motion when scrolling with `{ behavior: 'smooth' }`.\n    \n      Defaults to `up.viewport.config.scrollSpeed`.\n    @param {number} [config.padding=0]\n      The desired padding between the revealed element and the\n      closest [viewport](/up.viewport) edge (in pixels).\n    @param {number|boolean} [config.snap]\n      Whether to snap to the top of the viewport if the new scroll position\n      after revealing the element is close to the top edge.\n    \n      You may pass a maximum number of pixels under which to snap to the top.\n    \n      Passing `false` will disable snapping.\n    \n      Passing `true` will use the snap pixel value from `up.viewport.config.revealSnap`.\n    @return {Promise}\n      A promise that fulfills when the element is revealed.\n    @stable\n     */\n    reveal = function(elementOrSelector, options) {\n      var element, motion;\n      element = e.get(elementOrSelector);\n      motion = new up.RevealMotion(element, options);\n      return scrollingController.startMotion(element, motion, options);\n    };\n\n    /***\n    @function up.viewport.scrollAfterInsertFragment\n    @param {boolean|object} [options.restoreScroll]\n    @param {boolean|string|jQuery|Element} [options.reveal]\n    @param {boolean|string} [options.reveal]\n    @return {Promise}\n      A promise that is fulfilled when the scrolling has finished.\n    @internal\n     */\n    scrollAfterInsertFragment = function(element, options) {\n      var givenTops, hashOpt, restoreScrollOpt, revealOpt, scrollOptions, selector;\n      if (options == null) {\n        options = {};\n      }\n      hashOpt = options.hash;\n      revealOpt = options.reveal;\n      restoreScrollOpt = options.restoreScroll;\n      scrollOptions = u.only(options, 'scrollBehavior', 'scrollSpeed');\n      if (restoreScrollOpt) {\n        givenTops = u.presence(restoreScrollOpt, u.isObject);\n        return restoreScroll({\n          around: element,\n          scrollTops: givenTops\n        });\n      } else if (hashOpt && revealOpt === true) {\n        return revealHash(hashOpt, scrollOptions);\n      } else if (revealOpt) {\n        if (u.isElement(revealOpt) || u.isJQuery(revealOpt)) {\n          element = e.get(revealOpt);\n        } else if (u.isString(revealOpt)) {\n          selector = e.resolveSelector(revealOpt, options.origin);\n          element = up.fragment.first(selector);\n        } else {\n\n        }\n        if (element) {\n          return reveal(element, scrollOptions);\n        }\n      } else {\n        return Promise.resolve();\n      }\n    };\n\n    /***\n    [Reveals](/up.reveal) an element matching the given `#hash` anchor.\n    \n    Other than the default behavior found in browsers, `up.revealHash` works with\n    [multiple viewports](/up-viewport) and honors [fixed elements](/up-fixed-top) obstructing the user's\n    view of the viewport.\n    \n    When the page loads initially, this function is automatically called with the hash from\n    the current URL.\n    \n    If no element matches the given `#hash` anchor, a resolved promise is returned.\n    \n    \\#\\#\\# Example\n    \n        up.revealHash('#chapter2')\n    \n    @function up.viewport.revealHash\n    @param {string} hash\n    \n    @return {Promise}\n      A promise that is fulfilled when scroll position has changed to match the location hash.\n    @experimental\n     */\n    revealHash = function(hash) {\n      var match;\n      if (hash && (match = firstHashTarget(hash))) {\n        return reveal(match, {\n          top: true\n        });\n      } else {\n        return Promise.resolve();\n      }\n    };\n    allSelector = function() {\n      return [rootSelector()].concat(slice.call(config.viewports)).join(',');\n    };\n\n    /***\n    Returns the scrolling container for the given element.\n    \n    Returns the [document's scrolling element](/up.viewport.root)\n    if no closer viewport exists.\n    \n    @function up.viewport.closest\n    @param {string|Element|jQuery} selectorOrElement\n    @return {Element}\n    @experimental\n     */\n    closest = function(selectorOrElement) {\n      var element;\n      element = e.get(selectorOrElement);\n      return e.closest(element, allSelector());\n    };\n\n    /***\n    Returns a jQuery collection of all the viewports contained within the\n    given selector or element.\n    \n    @function up.viewport.subtree\n    @param {string|Element|jQuery} selectorOrElement\n    @return List<Element>\n    @internal\n     */\n    getSubtree = function(selectorOrElement) {\n      var element;\n      element = e.get(selectorOrElement);\n      return e.subtree(element, allSelector());\n    };\n    getAround = function(selectorOrElement) {\n      var element;\n      element = e.get(selectorOrElement);\n      return e.list(closest(element), getSubtree(element));\n    };\n\n    /***\n    Returns a list of all the viewports on the screen.\n    \n    @function up.viewport.all\n    @internal\n     */\n    getAll = function() {\n      return e.all(allSelector());\n    };\n    rootSelector = function() {\n      var element;\n      if (element = document.scrollingElement) {\n        return element.tagName;\n      } else {\n        return 'html';\n      }\n    };\n\n    /***\n    Return the [scrolling element](https://developer.mozilla.org/en-US/docs/Web/API/document/scrollingElement)\n    for the browser's main content area.\n    \n    @function up.viewport.root\n    @return {Element}\n    @experimental\n     */\n    getRoot = function() {\n      return document.querySelector(rootSelector());\n    };\n    rootWidth = function() {\n      return e.root().clientWidth;\n    };\n    rootHeight = function() {\n      return e.root().clientHeight;\n    };\n    isRoot = function(element) {\n      return e.matches(element, rootSelector());\n    };\n\n    /***\n    Returns whether the given element is currently showing a vertical scrollbar.\n    \n    @function up.viewport.rootHasVerticalScrollbar\n    @internal\n     */\n    rootHasVerticalScrollbar = function() {\n      return window.innerWidth > document.documentElement.offsetWidth;\n    };\n\n    /***\n    Returns the element that controls the `overflow-y` behavior for the\n    [document viewport](/up.viewport.root()).\n    \n    @function up.viewport.rootOverflowElement\n    @internal\n     */\n    rootOverflowElement = function() {\n      var body, element, html;\n      body = document.body;\n      html = document.documentElement;\n      element = u.find([html, body], wasChosenAsOverflowingElement);\n      return element || getRoot();\n    };\n\n    /***\n    Returns whether the given element was chosen as the overflowing\n    element by the developer.\n    \n    We have no control whether developers set the property on <body> or\n    <html>. The developer also won't know what is going to be the\n    [scrolling element](/up.viewport.root()) on the user's brower.\n    \n    @function wasChosenAsOverflowingElement\n    @internal\n     */\n    wasChosenAsOverflowingElement = function(element) {\n      var overflowY;\n      overflowY = e.style(element, 'overflow-y');\n      return overflowY === 'auto' || overflowY === 'scroll';\n    };\n\n    /***\n    Returns the width of a scrollbar.\n    \n    This only runs once per page load.\n    \n    @function up.viewport.scrollbarWidth\n    @internal\n     */\n    scrollbarWidth = u.memoize(function() {\n      var outer, outerStyle, width;\n      outerStyle = {\n        position: 'absolute',\n        top: '0',\n        left: '0',\n        width: '100px',\n        height: '100px',\n        overflowY: 'scroll'\n      };\n      outer = up.element.affix(document.body, '[up-viewport]', {\n        style: outerStyle\n      });\n      width = outer.offsetWidth - outer.clientWidth;\n      up.element.remove(outer);\n      return width;\n    });\n    scrollTopKey = function(viewport) {\n      return e.toSelector(viewport);\n    };\n\n    /***\n    Returns a hash with scroll positions.\n    \n    Each key in the hash is a viewport selector. The corresponding\n    value is the viewport's top scroll position:\n    \n        up.viewport.scrollTops()\n        => { '.main': 0, '.sidebar': 73 }\n    \n    @function up.viewport.scrollTops\n    @return Object<string, number>\n    @internal\n     */\n    scrollTops = function() {\n      return u.mapObject(getAll(), function(viewport) {\n        return [scrollTopKey(viewport), viewport.scrollTop];\n      });\n    };\n\n    /***\n    @function up.viewport.fixedElements\n    @internal\n     */\n    fixedElements = function(root) {\n      var queryParts;\n      if (root == null) {\n        root = document;\n      }\n      queryParts = ['[up-fixed]'].concat(config.fixedTop).concat(config.fixedBottom);\n      return root.querySelectorAll(queryParts.join(','));\n    };\n\n    /***\n    Saves the top scroll positions of all the\n    viewports configured in [`up.viewport.config.viewports`](/up.viewport.config).\n    \n    The scroll positions will be associated with the current URL.\n    They can later be restored by calling [`up.viewport.restoreScroll()`](/up.viewport.restoreScroll)\n    at the same URL, or by following a link with an [`[up-restore-scroll]`](/a-up-follow#up-restore-scroll)\n    attribute.\n    \n    Unpoly automatically saves scroll positions before a [fragment update](/up.replace)\n    you will rarely need to call this function yourself.\n    \n    \\#\\#\\# Examples\n    \n    Should you need to save the current scroll positions outside of a [fragment update](/up.replace),\n    you may call:\n    \n        up.viewport.saveScroll()\n    \n    Instead of saving the current scroll positions for the current URL, you may also pass another\n    url or vertical scroll positionsfor each viewport:\n    \n        up.viewport.saveScroll({\n          url: '/inbox',\n          tops: {\n            'body': 0,\n            '.sidebar', 100,\n            '.main', 320\n          }\n        })\n    \n    @function up.viewport.saveScroll\n    @param {string} [options.url]\n      The URL for which to save scroll positions.\n      If omitted, the current browser location is used.\n    @param {Object<string, number>} [options.tops]\n      An object mapping viewport selectors to vertical scroll positions in pixels.\n    @experimental\n     */\n    saveScroll = function(options) {\n      var ref, ref1, tops, url;\n      if (options == null) {\n        options = {};\n      }\n      url = (ref = options.url) != null ? ref : up.history.url();\n      tops = (ref1 = options.tops) != null ? ref1 : scrollTops();\n      return lastScrollTops.set(url, tops);\n    };\n\n    /***\n    Restores [previously saved](/up.viewport.saveScroll) scroll positions of viewports\n    viewports configured in [`up.viewport.config.viewports`](/up.viewport.config).\n    \n    Unpoly automatically restores scroll positions when the user presses the back button.\n    You can disable this behavior by setting [`up.history.config.restoreScroll = false`](/up.history.config).\n    \n    @function up.viewport.restoreScroll\n    @param {Element} [options.around]\n      If set, only restores viewports that are either an ancestor\n      or descendant of the given element.\n    @return {Promise}\n      A promise that will be fulfilled once scroll positions have been restored.\n    @experimental\n     */\n    restoreScroll = function(options) {\n      var scrollTopsForUrl, url, viewports;\n      if (options == null) {\n        options = {};\n      }\n      url = up.history.url();\n      viewports = options.around ? getAround(options.around) : getAll();\n      scrollTopsForUrl = options.scrollTops || lastScrollTops.get(url) || {};\n      return up.log.group('Restoring scroll positions for URL %s to %o', url, scrollTopsForUrl, function() {\n        var allScrollPromises;\n        allScrollPromises = u.map(viewports, function(viewport) {\n          var key, scrollTop;\n          key = scrollTopKey(viewport);\n          scrollTop = scrollTopsForUrl[key] || 0;\n          return scroll(viewport, scrollTop, {\n            duration: 0\n          });\n        });\n        return Promise.all(allScrollPromises);\n      });\n    };\n\n    /***\n    @internal\n     */\n    absolutize = function(elementOrSelector, options) {\n      var bounds, boundsRect, element, moveBounds, newElementRect, originalRect, viewport, viewportRect;\n      if (options == null) {\n        options = {};\n      }\n      element = e.get(elementOrSelector);\n      viewport = up.viewport.closest(element);\n      viewportRect = viewport.getBoundingClientRect();\n      originalRect = element.getBoundingClientRect();\n      boundsRect = new up.Rect({\n        left: originalRect.left - viewportRect.left,\n        top: originalRect.top - viewportRect.top,\n        width: originalRect.width,\n        height: originalRect.height\n      });\n      if (typeof options.afterMeasure === \"function\") {\n        options.afterMeasure();\n      }\n      e.setStyle(element, {\n        position: element.style.position === 'static' ? 'static' : 'relative',\n        top: 'auto',\n        right: 'auto',\n        bottom: 'auto',\n        left: 'auto',\n        width: '100%',\n        height: '100%'\n      });\n      bounds = e.createFromSelector('.up-bounds');\n      e.insertBefore(element, bounds);\n      bounds.appendChild(element);\n      moveBounds = function(diffX, diffY) {\n        boundsRect.left += diffX;\n        boundsRect.top += diffY;\n        return e.setStyle(bounds, boundsRect);\n      };\n      moveBounds(0, 0);\n      newElementRect = element.getBoundingClientRect();\n      moveBounds(originalRect.left - newElementRect.left, originalRect.top - newElementRect.top);\n      u.each(fixedElements(element), e.fixedToAbsolute);\n      return {\n        bounds: bounds,\n        moveBounds: moveBounds\n      };\n    };\n\n    /***\n    Marks this element as a scrolling container (\"viewport\").\n    \n    Apply this attribute if your app uses a custom panel layout with fixed positioning\n    instead of scrolling `<body>`. As an alternative you can also push a selector\n    matching your custom viewport to the [`up.viewport.config.viewports`](/up.viewport.config) array.\n    \n    [`up.reveal()`](/up.reveal) will always try to scroll the viewport closest\n    to the element that is being revealed. By default this is the `<body>` element.\n    \n    \\#\\#\\# Example\n    \n    Here is an example for a layout for an e-mail client, showing a list of e-mails\n    on the left side and the e-mail text on the right side:\n    \n        .side {\n          position: fixed;\n          top: 0;\n          bottom: 0;\n          left: 0;\n          width: 100px;\n          overflow-y: scroll;\n        }\n    \n        .main {\n          position: fixed;\n          top: 0;\n          bottom: 0;\n          left: 100px;\n          right: 0;\n          overflow-y: scroll;\n        }\n    \n    This would be the HTML (notice the `up-viewport` attribute):\n    \n        <div class=\".side\" up-viewport>\n          <a href=\"/emails/5001\" up-target=\".main\">Re: Your invoice</a>\n          <a href=\"/emails/2023\" up-target=\".main\">Quote for services</a>\n          <a href=\"/emails/9002\" up-target=\".main\">Fwd: Room reservation</a>\n        </div>\n    \n        <div class=\"main\" up-viewport>\n          <h1>Re: Your Invoice</h1>\n          <p>\n            Lorem ipsum dolor sit amet, consetetur sadipscing elitr.\n            Stet clita kasd gubergren, no sea takimata sanctus est.\n          </p>\n        </div>\n    \n    @selector [up-viewport]\n    @stable\n     */\n\n    /***\n    Marks this element as being fixed to the top edge of the screen\n    using `position: fixed`.\n    \n    When [following a fragment link](/a-up-target), the viewport is scrolled\n    so the targeted element becomes visible. By using this attribute you can make\n    Unpoly aware of fixed elements that are obstructing the viewport contents.\n    Unpoly will then scroll the viewport far enough that the revealed element is fully visible.\n    \n    Instead of using this attribute,\n    you can also configure a selector in [`up.viewport.config.fixedTop`](/up.viewport.config#config.fixedTop).\n    \n    \\#\\#\\# Example\n    \n        <div class=\"top-nav\" up-fixed=\"top\">...</div>\n    \n    @selector [up-fixed=top]\n    @stable\n     */\n\n    /***\n    Marks this element as being fixed to the bottom edge of the screen\n    using `position: fixed`.\n    \n    When [following a fragment link](/a-up-target), the viewport is scrolled\n    so the targeted element becomes visible. By using this attribute you can make\n    Unpoly aware of fixed elements that are obstructing the viewport contents.\n    Unpoly will then scroll the viewport far enough that the revealed element is fully visible.\n    \n    Instead of using this attribute,\n    you can also configure a selector in [`up.viewport.config.fixedBottom`](/up.viewport.config#config.fixedBottom).\n    \n    \\#\\#\\# Example\n    \n        <div class=\"bottom-nav\" up-fixed=\"bottom\">...</div>\n    \n    @selector [up-fixed=bottom]\n    @stable\n     */\n\n    /***\n    Marks this element as being anchored to the right edge of the screen,\n    typically fixed navigation bars.\n    \n    Since [modal dialogs](/up.modal) hide the document scroll bar,\n    elements anchored to the right appear to jump when the dialog opens or\n    closes. Applying this attribute to anchored elements will make Unpoly\n    aware of the issue and adjust the `right` property accordingly.\n    \n    You should give this attribute to layout elements\n    with a CSS of `right: 0` with `position: fixed` or `position:absolute`.\n    \n    Instead of giving this attribute to any affected element,\n    you can also configure a selector in [`up.viewport.config.anchoredRight`](/up.viewport.config#config.anchoredRight).\n    \n    \\#\\#\\# Example\n    \n    Here is the CSS for a navigation bar that is anchored to the top edge of the screen:\n    \n        .top-nav {\n           position: fixed;\n           top: 0;\n           left: 0;\n           right: 0;\n         }\n    \n    By adding an `up-anchored=\"right\"` attribute to the element, we can prevent the\n    `right` edge from jumping when a [modal dialog](/up.modal) opens or closes:\n    \n        <div class=\"top-nav\" up-anchored=\"right\">...</div>\n    \n    @selector [up-anchored=right]\n    @stable\n     */\n\n    /***\n    @function up.viewport.firstHashTarget\n    @internal\n     */\n    firstHashTarget = function(hash) {\n      var selector;\n      if (hash = pureHash(hash)) {\n        selector = [e.attributeSelector('up-id', hash), e.attributeSelector('id', hash), 'a' + e.attributeSelector('name', hash)].join(',');\n        return up.fragment.first(selector);\n      }\n    };\n\n    /***\n    Returns `'foo'` if the hash is `'#foo'`.\n    \n    Returns undefined if the hash is `'#'`, `''` or `undefined`.\n    \n    @function pureHash\n    @internal\n     */\n    pureHash = function(value) {\n      if (value && value[0] === '#') {\n        value = value.substr(1);\n      }\n      return u.presence(value);\n    };\n    up.on('up:app:booted', function() {\n      return revealHash(location.hash);\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      reveal: reveal,\n      revealHash: revealHash,\n      firstHashTarget: firstHashTarget,\n      scroll: scroll,\n      config: config,\n      closest: closest,\n      subtree: getSubtree,\n      around: getAround,\n      all: getAll,\n      rootSelector: rootSelector,\n      root: getRoot,\n      rootWidth: rootWidth,\n      rootHeight: rootHeight,\n      rootHasVerticalScrollbar: rootHasVerticalScrollbar,\n      rootOverflowElement: rootOverflowElement,\n      isRoot: isRoot,\n      scrollbarWidth: scrollbarWidth,\n      scrollTops: scrollTops,\n      saveScroll: saveScroll,\n      restoreScroll: restoreScroll,\n      scrollAfterInsertFragment: scrollAfterInsertFragment,\n      anchoredRight: anchoredRight,\n      fixedElements: fixedElements,\n      absolutize: absolutize\n    };\n  })();\n\n  up.scroll = up.viewport.scroll;\n\n  up.reveal = up.viewport.reveal;\n\n  up.revealHash = up.viewport.revealHash;\n\n  up.legacy.renamedModule('layout', 'viewport');\n\n}).call(this);\n\n/***\nFragment update API\n===================\n  \nThe `up.fragment` module exposes a high-level Javascript API to [update](/up.replace) or\n[destroy](/up.destroy) page fragments.\n\nFragments are [compiled](/up.compiler) elements that can be updated from a server URL.\nThey also exist on a layer (page, modal, popup).\n\nMost of Unpoly's functionality (like [fragment links](/up.link) or [modals](/up.modal))\nis built from `up.fragment` functions. You may use them to extend Unpoly from your\n[custom Javascript](/up.syntax).\n\n@module up.fragment\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.fragment = (function() {\n    var bestMatchingSteps, bestPreflightSelector, config, createPlaceholder, destroy, e, emitFragmentDestroyed, emitFragmentInserted, emitFragmentKept, extract, findKeepPlan, first, firstInLayer, firstInPriority, hello, isRealElement, layerOf, markElementAsDestroying, matchesLayer, processResponse, reload, replace, reset, setSource, shouldExtractTitle, shouldLogDestruction, source, swapElements, transferKeepableElements, u, updateHistoryAndTitle;\n    u = up.util;\n    e = up.element;\n\n    /***\n    Configures defaults for fragment insertion.\n    \n    @property up.fragment.config\n    @param {string} [options.fallbacks=['body']]\n      When a fragment updates cannot find the requested element, Unpoly will try this list of alternative selectors.\n    \n      The first selector that matches an element in the current page (or response) will be used.\n      If the response contains none of the selectors, an error message will be shown.\n    \n      It is recommend to always keep `'body'` as the last selector in the last in the case\n      your server or load balancer renders an error message that does not contain your\n      application layout.\n    @param {string} [options.fallbackTransition=null]\n      The transition to use when using a [fallback target](/#options.fallbacks).\n    \n      By default this is not set and the original replacement's transition is used.\n    @stable\n     */\n    config = new up.Config({\n      fallbacks: ['body'],\n      fallbackTransition: null\n    });\n    reset = function() {\n      return config.reset();\n    };\n    setSource = function(element, sourceUrl) {\n      if (sourceUrl !== false) {\n        if (u.isPresent(sourceUrl)) {\n          sourceUrl = u.normalizeUrl(sourceUrl);\n        }\n        return element.setAttribute(\"up-source\", sourceUrl);\n      }\n    };\n\n    /***\n    Returns the URL the given element was retrieved from.\n    \n    @method up.fragment.source\n    @param {string|Element|jQuery} selectorOrElement\n    @experimental\n     */\n    source = function(selectorOrElement) {\n      var element;\n      element = e.get(selectorOrElement);\n      if (element = e.closest(element, '[up-source]')) {\n        return element.getAttribute(\"up-source\");\n      } else {\n        return up.browser.url();\n      }\n    };\n\n    /***\n    Replaces elements on the current page with corresponding elements\n    from a new page fetched from the server.\n    \n    The current and new elements must both match the given CSS selector.\n    \n    The unobtrusive variant of this is the [`a[up-target]`](/a-up-target) selector.\n    \n    \\#\\#\\# Example\n    \n    Let's say your current HTML looks like this:\n    \n        <div class=\"one\">old one</div>\n        <div class=\"two\">old two</div>\n    \n    We now replace the second `<div>`:\n    \n        up.replace('.two', '/new')\n    \n    The server renders a response for `/new`:\n    \n        <div class=\"one\">new one</div>\n        <div class=\"two\">new two</div>\n    \n    Unpoly looks for the selector `.two` in the response and [implants](/up.extract) it into\n    the current page. The current page now looks like this:\n    \n        <div class=\"one\">old one</div>\n        <div class=\"two\">new two</div>\n    \n    Note how only `.two` has changed. The update for `.one` was\n    discarded, since it didn't match the selector.\n    \n    \\#\\#\\# Appending or prepending instead of replacing\n    \n    By default Unpoly will replace the given selector with the same\n    selector from a freshly fetched page. Instead of replacing you\n    can *append* the loaded content to the existing content by using the\n    `:after` pseudo selector. In the same fashion, you can use `:before`\n    to indicate that you would like the *prepend* the loaded content.\n    \n    A practical example would be a paginated list of items:\n    \n        <ul class=\"tasks\">\n          <li>Wash car</li>\n          <li>Purchase supplies</li>\n          <li>Fix tent</li>\n        </ul>\n    \n    In order to append more items from a URL, replace into\n    the `.tasks:after` selector:\n    \n        up.replace('.tasks:after', '/page/2')\n    \n    \\#\\#\\# Setting the window title from the server\n    \n    If the `replace` call changes history, the document title will be set\n    to the contents of a `<title>` tag in the response.\n    \n    The server can also change the document title by setting\n    an `X-Up-Title` header in the response.\n    \n    \\#\\#\\# Optimizing response rendering\n    \n    The server is free to optimize Unpoly requests by only rendering the HTML fragment\n    that is being updated. The request's `X-Up-Target` header will contain\n    the CSS selector for the updating fragment.\n    \n    If you are using the `unpoly-rails` gem you can also access the selector via\n    `up.target` in all controllers, views and helpers.\n    \n    \\#\\#\\# Events\n    \n    Unpoly will emit [`up:fragment:destroyed`](/up:fragment:destroyed) on the element\n    that was replaced and [`up:fragment:inserted`](/up:fragment:inserted) on the new\n    element that replaces it.\n    \n    @function up.replace\n    @param {string|Element|jQuery} selectorOrElement\n      The CSS selector to update. You can also pass a DOM element or jQuery element\n      here, in which case a selector will be inferred from the element's class and ID.\n    @param {string} url\n      The URL to fetch from the server.\n    @param {string} [options.failTarget]\n      The CSS selector to update if the server sends a non-200 status code.\n    @param {string} [options.fallback]\n      The selector to update when the original target was not found in the page.\n    @param {string} [options.title]\n      The document title after the replacement.\n    \n      If the call pushes an history entry and this option is missing, the title is extracted from the response's `<title>` tag.\n      You can also pass `false` to explicitly prevent the title from being updated.\n    @param {string} [options.method='get']\n      The HTTP method to use for the request.\n    @param {Object|FormData|string|Array} [options.params]\n      [Parameters](/up.Params) that should be sent as the request's payload.\n    @param {string} [options.transition='none']\n    @param {string|boolean} [options.history=true]\n      If a string is given, it is used as the URL the browser's location bar and history.\n      If omitted or true, the `url` argument will be used.\n      If set to `false`, the history will remain unchanged.\n    @param {boolean|string} [options.source=true]\n    @param {boolean|string} [options.reveal=false]\n      Whether to [reveal](/up.reveal) the new fragment.\n    \n      You can also pass a CSS selector for the element to reveal.\n    @param {boolean|string} [options.failReveal=false]\n      Whether to [reveal](/up.reveal) the new fragment when the server responds with an error.\n    \n      You can also pass a CSS selector for the element to reveal.\n    @param {number} [options.revealPadding]\n    \n    @param {boolean} [options.restoreScroll=false]\n      If set to true, Unpoly will try to restore the scroll position\n      of all the viewports around or below the updated element. The position\n      will be reset to the last known top position before a previous\n      history change for the current URL.\n    @param {boolean} [options.cache]\n      Whether to use a [cached response](/up.proxy) if available.\n    @param {string} [options.historyMethod='push']\n    @param {Object} [options.headers={}]\n      An object of additional header key/value pairs to send along\n      with the request.\n    @param {Element|jQuery} [options.origin]\n      The element that triggered the replacement.\n    \n      The element's selector will be substituted for the `&` shorthand in the target selector ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [options.layer='auto']\n      The name of the layer that ought to be updated. Valid values are\n      `'auto'`, `'page'`, `'modal'` and `'popup'`.\n    \n      If set to `'auto'` (default), Unpoly will try to find a match in the\n      same layer as the element that triggered the replacement (see `options.origin`).\n      If that element is not known, or no match was found in that layer,\n      Unpoly will search in other layers, starting from the topmost layer.\n    @param {string} [options.failLayer='auto']\n      The name of the layer that ought to be updated if the server sends a non-200 status code.\n    @param {boolean} [options.keep=true]\n      Whether this replacement will preserve [`[up-keep]`](/up-keep) elements.\n    @param {boolean} [options.hungry=true]\n      Whether this replacement will update [`[up-hungry]`](/up-hungry) elements.\n    \n    @return {Promise}\n      A promise that will be fulfilled when the page has been updated.\n    @stable\n     */\n    replace = function(selectorOrElement, url, options) {\n      var error, failureOptions, fullLoad, improvedFailTarget, improvedTarget, onFailure, onSuccess, promise, request, requestAttrs, successOptions;\n      options = u.options(options);\n      options.inspectResponse = fullLoad = function() {\n        return up.browser.navigate(url, u.only(options, 'method', 'params'));\n      };\n      if (!up.browser.canPushState() && options.history !== false) {\n        if (!options.preload) {\n          fullLoad();\n        }\n        return u.unresolvablePromise();\n      }\n      successOptions = u.merge(options, {\n        humanizedTarget: 'target'\n      });\n      failureOptions = u.merge(options, {\n        humanizedTarget: 'failure target',\n        provideTarget: void 0,\n        restoreScroll: false\n      });\n      u.renameKey(failureOptions, 'failTransition', 'transition');\n      u.renameKey(failureOptions, 'failLayer', 'layer');\n      u.renameKey(failureOptions, 'failReveal', 'reveal');\n      try {\n        improvedTarget = bestPreflightSelector(selectorOrElement, successOptions);\n        improvedFailTarget = bestPreflightSelector(options.failTarget, failureOptions);\n      } catch (error1) {\n        error = error1;\n        return Promise.reject(error);\n      }\n      requestAttrs = u.only(options, 'method', 'data', 'params', 'cache', 'preload', 'headers', 'timeout');\n      u.assign(requestAttrs, {\n        url: url,\n        target: improvedTarget,\n        failTarget: improvedFailTarget\n      });\n      request = new up.Request(requestAttrs);\n      onSuccess = function(response) {\n        return processResponse(true, improvedTarget, request, response, successOptions);\n      };\n      onFailure = function(response) {\n        var promise, rejection;\n        rejection = function() {\n          return Promise.reject(response);\n        };\n        if (response.isFatalError()) {\n          return rejection();\n        } else {\n          promise = processResponse(false, improvedFailTarget, request, response, failureOptions);\n          return u.always(promise, rejection);\n        }\n      };\n      promise = up.request(request);\n      if (!options.preload) {\n        promise = promise.then(onSuccess, onFailure);\n      }\n      return promise;\n    };\n\n    /***\n    @internal\n     */\n    processResponse = function(isSuccess, selector, request, response, options) {\n      var hash, historyUrl, isReloadable, sourceUrl;\n      sourceUrl = response.url;\n      historyUrl = sourceUrl;\n      if (hash = request.hash) {\n        options.hash = hash;\n        historyUrl += hash;\n      }\n      isReloadable = response.method === 'GET';\n      if (isSuccess) {\n        if (isReloadable) {\n          if (!(options.history === false || u.isString(options.history))) {\n            options.history = historyUrl;\n          }\n          if (!(options.source === false || u.isString(options.source))) {\n            options.source = sourceUrl;\n          }\n        } else {\n          if (!u.isString(options.history)) {\n            options.history = false;\n          }\n          if (!u.isString(options.source)) {\n            options.source = 'keep';\n          }\n        }\n      } else {\n        if (isReloadable) {\n          if (options.history !== false) {\n            options.history = historyUrl;\n          }\n          if (options.source !== false) {\n            options.source = sourceUrl;\n          }\n        } else {\n          options.history = false;\n          options.source = 'keep';\n        }\n      }\n      if (shouldExtractTitle(options) && response.title) {\n        options.title = response.title;\n      }\n      return extract(selector, response.text, options);\n    };\n    shouldExtractTitle = function(options) {\n      return !(options.title === false || u.isString(options.title) || (options.history === false && options.title !== true));\n    };\n\n    /***\n    Updates a selector on the current page with the\n    same selector from the given HTML string.\n    \n    \\#\\#\\# Example\n    \n    Let's say your current HTML looks like this:\n    \n        <div class=\"one\">old one</div>\n        <div class=\"two\">old two</div>\n    \n    We now replace the second `<div>`, using an HTML string\n    as the source:\n    \n        html = '<div class=\"one\">new one</div>' +\n               '<div class=\"two\">new two</div>';\n    \n        up.extract('.two', html)\n    \n    Unpoly looks for the selector `.two` in the strings and updates its\n    contents in the current page. The current page now looks like this:\n    \n        <div class=\"one\">old one</div>\n        <div class=\"two\">new two</div>\n    \n    Note how only `.two` has changed. The update for `.one` was\n    discarded, since it didn't match the selector.\n    \n    @function up.extract\n    @param {string|Element|jQuery} selectorOrElement\n    @param {string} html\n    @param {Object} [options]\n      See options for [`up.replace()`](/up.replace).\n    @return {Promise}\n      A promise that will be fulfilled then the selector was updated\n      and all animation has finished.\n    @stable\n     */\n    extract = function(selectorOrElement, html, options) {\n      return up.log.group('Extracting %s from %d bytes of HTML', selectorOrElement, html != null ? html.length : void 0, function() {\n        options = u.options(options, {\n          historyMethod: 'push',\n          keep: true,\n          layer: 'auto'\n        });\n        if (options.saveScroll !== false) {\n          up.viewport.saveScroll();\n        }\n        return u.rejectOnError(function() {\n          var extractSteps, i, len, responseDoc, responseTitle, step, swapPromises;\n          if (typeof options.provideTarget === \"function\") {\n            options.provideTarget();\n          }\n          responseDoc = new up.HtmlParser(html);\n          extractSteps = bestMatchingSteps(selectorOrElement, responseDoc, options);\n          if (shouldExtractTitle(options) && (responseTitle = responseDoc.title())) {\n            options.title = responseTitle;\n          }\n          updateHistoryAndTitle(options);\n          swapPromises = [];\n          for (i = 0, len = extractSteps.length; i < len; i++) {\n            step = extractSteps[i];\n            up.log.group('Swapping fragment %s', step.selector, function() {\n              var swapOptions, swapPromise;\n              swapOptions = u.merge(options, u.only(step, 'origin', 'reveal'));\n              responseDoc.prepareForInsertion(step.newElement);\n              swapPromise = swapElements(step.oldElement, step.newElement, step.pseudoClass, step.transition, swapOptions);\n              return swapPromises.push(swapPromise);\n            });\n          }\n          return Promise.all(swapPromises);\n        });\n      });\n    };\n    bestPreflightSelector = function(selectorOrElement, options) {\n      var cascade;\n      cascade = new up.ExtractCascade(selectorOrElement, options);\n      return cascade.bestPreflightSelector();\n    };\n    bestMatchingSteps = function(selectorOrElement, response, options) {\n      var cascade;\n      options = u.merge(options, {\n        response: response\n      });\n      cascade = new up.ExtractCascade(selectorOrElement, options);\n      return cascade.bestMatchingSteps();\n    };\n    updateHistoryAndTitle = function(options) {\n      options = u.options(options, {\n        historyMethod: 'push'\n      });\n      if (options.history) {\n        up.history[options.historyMethod](options.history);\n      }\n      if (u.isString(options.title)) {\n        return document.title = options.title;\n      }\n    };\n    swapElements = function(oldElement, newElement, pseudoClass, transition, options) {\n      var child, childNode, i, keepPlan, len, morphOptions, parent, promise, ref, wrapper;\n      transition || (transition = 'none');\n      if (options.source === 'keep') {\n        options = u.merge(options, {\n          source: source(oldElement)\n        });\n      }\n      setSource(newElement, options.source);\n      if (pseudoClass) {\n        wrapper = e.createFromSelector('.up-insertion');\n        while (childNode = newElement.firstChild) {\n          wrapper.appendChild(childNode);\n        }\n        if (pseudoClass === 'before') {\n          oldElement.insertAdjacentElement('afterbegin', wrapper);\n        } else {\n          oldElement.insertAdjacentElement('beforeend', wrapper);\n        }\n        ref = wrapper.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          hello(child, options);\n        }\n        promise = up.viewport.scrollAfterInsertFragment(wrapper, options);\n        promise = u.always(promise, up.animate(wrapper, transition, options));\n        promise = promise.then(function() {\n          return e.unwrap(wrapper);\n        });\n        return promise;\n      } else if (keepPlan = findKeepPlan(oldElement, newElement, options)) {\n        emitFragmentKept(keepPlan);\n        return Promise.resolve();\n      } else {\n        options.keepPlans = transferKeepableElements(oldElement, newElement, options);\n        parent = oldElement.parentNode;\n        morphOptions = u.merge(options, {\n          beforeStart: function() {\n            return markElementAsDestroying(oldElement);\n          },\n          afterInsert: function() {\n            return up.hello(newElement, options);\n          },\n          beforeDetach: function() {\n            return up.syntax.clean(oldElement);\n          },\n          afterDetach: function() {\n            e.remove(oldElement);\n            return emitFragmentDestroyed(oldElement, {\n              parent: parent,\n              log: false\n            });\n          }\n        });\n        return up.morph(oldElement, newElement, transition, morphOptions);\n      }\n    };\n    transferKeepableElements = function(oldElement, newElement, options) {\n      var i, keepPlans, keepable, keepableClone, len, plan, ref;\n      keepPlans = [];\n      if (options.keep) {\n        ref = oldElement.querySelectorAll('[up-keep]');\n        for (i = 0, len = ref.length; i < len; i++) {\n          keepable = ref[i];\n          if (plan = findKeepPlan(keepable, newElement, u.merge(options, {\n            descendantsOnly: true\n          }))) {\n            keepableClone = keepable.cloneNode(true);\n            e.replace(keepable, keepableClone);\n            e.replace(plan.newElement, keepable);\n            keepPlans.push(plan);\n          }\n        }\n      }\n      return keepPlans;\n    };\n    findKeepPlan = function(element, newElement, options) {\n      var keepEventArgs, keepable, partner, partnerSelector, plan;\n      if (options.keep) {\n        keepable = element;\n        if (partnerSelector = e.booleanOrStringAttr(keepable, 'up-keep')) {\n          u.isString(partnerSelector) || (partnerSelector = '&');\n          partnerSelector = e.resolveSelector(partnerSelector, keepable);\n          if (options.descendantsOnly) {\n            partner = e.first(newElement, partnerSelector);\n          } else {\n            partner = e.subtree(newElement, partnerSelector)[0];\n          }\n          if (partner && e.matches(partner, '[up-keep]')) {\n            plan = {\n              oldElement: keepable,\n              newElement: partner,\n              newData: up.syntax.data(partner)\n            };\n            keepEventArgs = {\n              target: keepable,\n              newFragment: partner,\n              newData: plan.newData,\n              log: ['Keeping element %o', keepable]\n            };\n            if (up.event.nobodyPrevents('up:fragment:keep', keepEventArgs)) {\n              return plan;\n            }\n          }\n        }\n      }\n    };\n\n    /***\n    Elements with an `up-keep` attribute will be persisted during\n    [fragment updates](/a-up-target).\n    \n    For example:\n    \n        <audio up-keep src=\"song.mp3\"></audio>\n    \n    The element you're keeping should have an umambiguous class name, ID or `up-id`\n    attribute so Unpoly can find its new position within the page update.\n    \n    Emits events [`up:fragment:keep`](/up:fragment:keep) and [`up:fragment:kept`](/up:fragment:kept).\n    \n    \\#\\#\\# Controlling if an element will be kept\n    \n    Unpoly will **only** keep an existing element if:\n    \n    - The existing element has an `up-keep` attribute\n    - The response contains an element matching the CSS selector of the existing element\n    - The matching element *also* has an `up-keep` attribute\n    - The [`up:fragment:keep`](/up:fragment:keep) event that is [emitted](/up.emit) on the existing element\n      is not prevented by a event listener.\n    \n    Let's say we want only keep an `<audio>` element as long as it plays\n    the same song (as identified by the tag's `src` attribute).\n    \n    On the client we can achieve this by listening to an `up:keep:fragment` event\n    and preventing it if the `src` attribute of the old and new element differ:\n    \n        up.compiler('audio', function(element) {\n          element.addEventListener('up:fragment:keep', function(event) {\n            if element.getAttribute('src') !== event.newElement.getAttribute('src') {\n              event.preventDefault()\n            }\n          })\n        })\n    \n    If we don't want to solve this on the client, we can achieve the same effect\n    on the server. By setting the value of the `up-keep` attribute we can\n    define the CSS selector used for matching elements.\n    \n        <audio up-keep=\"audio[src='song.mp3']\" src=\"song.mp3\"></audio>\n    \n    Now, if a response no longer contains an `<audio src=\"song.mp3\">` tag, the existing\n    element will be destroyed and replaced by a fragment from the response.\n    \n    @selector [up-keep]\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) before an existing element is [kept](/up-keep) during\n    a page update.\n    \n    Event listeners can call `event.preventDefault()` on an `up:fragment:keep` event\n    to prevent the element from being persisted. If the event is prevented, the element\n    will be replaced by a fragment from the response.\n    \n    @event up:fragment:keep\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the element from being preserved.\n    @param {Element} event.target\n      The fragment that will be kept.\n    @param {Element} event.newFragment\n      The discarded element.\n    @param {Object} event.newData\n      The value of the [`up-data`](/up-data) attribute of the discarded element,\n      parsed as a JSON object.\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) when an existing element has been [kept](/up-keep)\n    during a page update.\n    \n    Event listeners can inspect the discarded update through `event.newElement`\n    and `event.newData` and then modify the preserved element when necessary.\n    \n    @event up:fragment:kept\n    @param {Element} event.target\n      The fragment that has been kept.\n    @param {Element} event.newFragment\n      The discarded fragment.\n    @param {Object} event.newData\n      The value of the [`up-data`](/up-data) attribute of the discarded fragment,\n      parsed as a JSON object.\n    @stable\n     */\n\n    /***\n    Compiles a page fragment that has been inserted into the DOM\n    by external code.\n    \n    **As long as you manipulate the DOM using Unpoly, you will never\n    need to call this method.** You only need to use `up.hello()` if the\n    DOM is manipulated without Unpoly' involvement, e.g. by setting\n    the `innerHTML` property or calling jQuery methods like\n    `html`, `insertAfter` or `appendTo`:\n    \n        element = document.createElement('div')\n        element.innerHTML = '... HTML that needs to be activated ...'\n        up.hello(element)\n    \n    This function emits the [`up:fragment:inserted`](/up:fragment:inserted)\n    event.\n    \n    @function up.hello\n    @param {string|Element|jQuery} selectorOrElement\n    @param {string|Element|jQuery} [options.origin]\n    @param {string|Element|jQuery} [options.kept]\n    @return {Element}\n      The compiled element\n    @stable\n     */\n    hello = function(selectorOrElement, options) {\n      var element, i, keptElements, len, plan, ref;\n      element = e.get(selectorOrElement);\n      options = u.options(options, {\n        keepPlans: []\n      });\n      keptElements = [];\n      ref = options.keepPlans;\n      for (i = 0, len = ref.length; i < len; i++) {\n        plan = ref[i];\n        emitFragmentKept(plan);\n        keptElements.push(plan.oldElement);\n      }\n      up.syntax.compile(element, {\n        skip: keptElements\n      });\n      emitFragmentInserted(element, options);\n      return element;\n    };\n\n    /***\n    When any page fragment has been [inserted or updated](/up.replace),\n    this event is [emitted](/up.emit) on the fragment.\n    \n    If you're looking to run code when a new fragment matches\n    a selector, use `up.compiler()` instead.\n    \n    \\#\\#\\# Example\n    \n        up.on('up:fragment:inserted', function(event, fragment) {\n          console.log(\"Looks like we have a new %o!\", fragment)\n        })\n    \n    @event up:fragment:inserted\n    @param {Element} event.target\n      The fragment that has been inserted or updated.\n    @stable\n     */\n    emitFragmentInserted = function(element, options) {\n      return up.emit(element, 'up:fragment:inserted', {\n        log: ['Inserted fragment %o', element],\n        origin: options.origin\n      });\n    };\n    emitFragmentKept = function(keepPlan) {\n      var eventAttrs, keptElement;\n      keptElement = keepPlan.oldElement;\n      eventAttrs = {\n        target: keptElement,\n        newFragment: keepPlan.newElement,\n        newData: keepPlan.newData,\n        log: ['Kept fragment %o', keptElement]\n      };\n      return up.emit('up:fragment:kept', eventAttrs);\n    };\n    emitFragmentDestroyed = function(fragment, options) {\n      var log, parent;\n      if (shouldLogDestruction(fragment, options)) {\n        log = ['Destroyed fragment %o', fragment];\n      }\n      parent = options.parent || up.fail(\"Missing { parent } option\");\n      return up.emit(parent, 'up:fragment:destroyed', {\n        fragment: fragment,\n        parent: parent,\n        log: log\n      });\n    };\n    isRealElement = function(element) {\n      return !e.closest(element, '.up-destroying');\n    };\n\n    /***\n    Returns the first element matching the given selector, but\n    ignores elements that are being [destroyed](/up.destroy) or that are being\n    removed by a [transition](/up.morph).\n    \n    Returns `undefined` if no element matches these conditions.\n    \n    \\#\\#\\# Example\n    \n    To select the first element with the selector `.foo`:\n    \n        var fooInModal = up.fragment.first('.foo')\n    \n    You may also pass a `{ layer }` option to only match elements witin a layer:\n    \n        var fooInModal = up.fragment.first('.foo', { layer: 'modal' })\n    \n    You may also pass a root element as a first argument:\n    \n        var container = up.fragment.first('.container')\n        var fooInContainer = up.fragment.first(container, '.foo')\n    \n    \\#\\#\\# Similar features\n    \n    - The [`.up-destroying`](/up-destroying) class is assigned to elements during their removal animation.\n    - The [`up.element.first()`](/up.element.first) function simply returns the first element matching a selector\n      without further filtering.\n    \n    @function up.fragment.first\n    @param {Element|jQuery} [root=document]\n      The root element for the search. Only the root's children will be matched.\n    \n      May be omitted to search through all elements in the `document`.\n    @param {string} selector\n      The selector to match\n    @param {string} [options.layer='auto']\n      The name of the layer in which to find the element.\n    \n      Valid values are `'auto'`, `'page'`, `'modal'` and `'popup'`.\n    @param {string|Element|jQuery} [options.origin]\n      An second element or selector that can be referenced as `&` in the first selector:\n    \n          var input = document.querySelector('input.email')\n          up.fragment.first('fieldset:has(&)', { origin: input }) // returns the <fieldset> containing input\n    @return {Element|undefined}\n      The first element that is neither a ghost or being destroyed,\n      or `undefined` if no such element was found.\n    @experimental\n     */\n    first = function() {\n      var args, layer, options, origin, ref, root, selector;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      options = u.extractOptions(args);\n      selector = args.pop();\n      root = args[0] || document;\n      layer = (ref = options.layer) != null ? ref : 'auto';\n      origin = options.origin;\n      selector = e.resolveSelector(selector, origin);\n      if (layer === 'auto') {\n        return firstInPriority(root, selector, origin);\n      } else {\n        return firstInLayer(root, selector, layer);\n      }\n    };\n    firstInPriority = function(parent, selector, origin) {\n      var layers, originLayer;\n      layers = ['popup', 'modal', 'page'];\n      if (origin) {\n        originLayer = layerOf(origin);\n        u.remove(layers, originLayer);\n        layers.unshift(originLayer);\n      }\n      return u.findResult(layers, function(layer) {\n        return firstInLayer(parent, selector, layer);\n      });\n    };\n    firstInLayer = function(parent, selector, layer) {\n      var elements;\n      elements = e.all(parent, selector);\n      return u.findResult(elements, function(element) {\n        if (isRealElement(element) && matchesLayer(element, layer)) {\n          return element;\n        }\n      });\n    };\n\n    /***\n    @function up.fragment.layerOf\n    @internal\n     */\n    layerOf = function(element) {\n      if (up.popup.contains(element)) {\n        return 'popup';\n      } else if (up.modal.contains(element)) {\n        return 'modal';\n      } else {\n        return 'page';\n      }\n    };\n    matchesLayer = function(element, layer) {\n      return !layer || layerOf(element) === layer;\n    };\n\n    /***\n    @function up.fragment.createPlaceHolder\n    @internal\n     */\n    createPlaceholder = function(selector, container) {\n      if (container == null) {\n        container = document.body;\n      }\n      return e.affix(container, selector, {\n        \"class\": 'up-placeholder'\n      });\n    };\n\n    /***\n    Destroys the given element or selector.\n    \n    Takes care that all [`up.compiler()`](/up.compiler) destructors, if any, are called.\n    \n    The element is removed from the DOM.\n    Note that if you choose to animate the element removal using `options.animate`,\n    the element won't be removed until after the animation has completed.\n    \n    Emits events [`up:fragment:destroyed`](/up:fragment:destroyed).\n    \n    @function up.destroy\n    @param {string|Element|jQuery} selectorOrElement\n    @param {string} [options.history]\n      A URL that will be pushed as a new history entry when the element begins destruction.\n    @param {string} [options.title]\n      The document title to set when the element begins destruction.\n    @param {string|Function(element, options): Promise} [options.animation='none']\n      The animation to use before the element is removed from the DOM.\n    @param {number} [options.duration]\n      The duration of the animation. See [`up.animate()`](/up.animate).\n    @param {number} [options.delay]\n      The delay before the animation starts. See [`up.animate()`](/up.animate).\n    @param {string} [options.easing]\n      The timing function that controls the animation's acceleration. [`up.animate()`](/up.animate).\n    @return {Promise}\n      A promise that will be fulfilled once the element has been removed from the DOM.\n    @stable\n     */\n    destroy = function(selectorOrElement, options) {\n      var animate, element, wipe;\n      element = e.get(selectorOrElement);\n      options = u.options(options, {\n        animation: false\n      });\n      if (!element) {\n        return Promise.resolve();\n      }\n      markElementAsDestroying(element);\n      updateHistoryAndTitle(options);\n      animate = function() {\n        var animateOptions;\n        animateOptions = up.motion.animateOptions(options);\n        return up.motion.animate(element, options.animation, animateOptions);\n      };\n      wipe = function() {\n        var parent;\n        parent = element.parentNode;\n        up.syntax.clean(element);\n        if (up.browser.canJQuery()) {\n          jQuery(element).remove();\n        } else {\n          e.remove(element);\n        }\n        return emitFragmentDestroyed(element, {\n          parent: parent,\n          log: options.log\n        });\n      };\n      return animate().then(wipe);\n    };\n    shouldLogDestruction = function(element, options) {\n      return options.log !== false && !e.matches(element, '.up-placeholder, .up-tooltip, .up-modal, .up-popup');\n    };\n\n    /***\n    Elements are assigned the `.up-destroying` class before they are [destroyed](/up.destroy)\n    or while they are being removed by a [transition](/up.morph).\n    \n    If the removal is animated, the class is assigned before the animation starts.\n    \n    To select an element while ignoring elements that are being destroyed,\n    see the [`up.fragment.first()`](/up.fragment.first) function.\n    \n    @selector .up-destroying\n    @stable\n     */\n    markElementAsDestroying = function(element) {\n      element.classList.add('up-destroying');\n      return element.setAttribute('aria-hidden', 'true');\n    };\n\n    /***\n    This event is [emitted](/up.emit) after a page fragment was [destroyed](/up.destroy) and removed from the DOM.\n    \n    If the destruction is animated, this event is emitted after the animation has ended.\n    \n    The event is emitted on the parent element of the fragment that was removed.\n    \n    @event up:fragment:destroyed\n    @param {Element} event.fragment\n      The detached element that has been removed from the DOM.\n    @param {Element} event.parent\n      The former parent element of the fragment that has now been detached from the DOM.\n    @param {Element} event.target\n      The former parent element of the fragment that has now been detached from the DOM.\n    @stable\n     */\n\n    /***\n    Replaces the given element with a fresh copy fetched from the server.\n    \n    \\#\\#\\# Example\n    \n        up.on('new-mail', function() { up.reload('.inbox') })\n    \n    Unpoly remembers the URL from which a fragment was loaded, so you\n    don't usually need to give an URL when reloading.\n    \n    @function up.reload\n    @param {string|Element|jQuery} selectorOrElement\n    @param {Object} [options]\n      See options for [`up.replace()`](/up.replace)\n    @param {string} [options.url]\n      The URL from which to reload the fragment.\n      This defaults to the URL from which the fragment was originally loaded.\n    @stable\n     */\n    reload = function(selectorOrElement, options) {\n      var sourceUrl;\n      options = u.options(options, {\n        cache: false\n      });\n      sourceUrl = options.url || source(selectorOrElement);\n      return replace(selectorOrElement, sourceUrl, options);\n    };\n    up.on('up:app:boot', function() {\n      var body;\n      body = document.body;\n      setSource(body, up.browser.url());\n      return hello(body);\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      createPlaceholder: createPlaceholder,\n      replace: replace,\n      reload: reload,\n      destroy: destroy,\n      extract: extract,\n      first: first,\n      source: source,\n      hello: hello,\n      config: config,\n      layerOf: layerOf\n    };\n  })();\n\n  up.replace = up.fragment.replace;\n\n  up.extract = up.fragment.extract;\n\n  up.reload = up.fragment.reload;\n\n  up.destroy = up.fragment.destroy;\n\n  up.hello = up.fragment.hello;\n\n  up.first = function() {\n    var args, ref;\n    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    up.legacy.warn('up.first() has been renamed to up.fragment.first()');\n    return (ref = up.fragment).first.apply(ref, args);\n  };\n\n  up.legacy.renamedModule('flow', 'fragment');\n\n  up.legacy.renamedModule('dom', 'fragment');\n\n}).call(this);\n\n/***\nAnimation\n=========\n  \nWhenever you [update a page fragment](/up.link) you can animate the change.\n\nLet's say you are using an [`up-target`](/a-up-target) link to update an element\nwith content from the server. You can add an attribute [`up-transition`](/a-up-target#up-transition)\nto smoothly fade out the old element while fading in the new element:\n\n    <a href=\"/users\" up-target=\".list\" up-transition=\"cross-fade\">Show users</a>\n\n\\#\\#\\# Transitions vs. animations\n\nWhen we morph between an old and a new element, we call it a *transition*.\nIn contrast, when we animate a new element without simultaneously removing an\nold element, we call it an *animation*.\n\nAn example for an animation is opening a new dialog. We can animate the appearance\nof the dialog by adding an [`[up-animation]`](/a-up-modal#up-animation) attribute to the opening link:\n\n    <a href=\"/users\" up-modal=\".list\" up-animation=\"move-from-top\">Show users</a>\n\n\\#\\#\\# Which animations are available?\n\nUnpoly ships with a number of [predefined transitions](/up.morph#named-transitions)\nand [predefined animations](/up.animate#named-animations).\n\nYou can define custom animations using [`up.transition()`](/up.transition) and\n[`up.animation()`](/up.animation).\n\n@module up.motion\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.motion = (function() {\n    var animCount, animate, animateNow, animateOptions, composeTransitionFn, config, defaultNamedAnimations, defaultNamedTransitions, e, findAnimationFn, findNamedAnimation, findTransitionFn, finish, isEnabled, isNone, morph, motionController, namedAnimations, namedTransitions, registerAnimation, registerTransition, reset, skipAnimate, snapshot, swapElementsDirectly, translateCss, u, willAnimate;\n    u = up.util;\n    e = up.element;\n    namedAnimations = {};\n    defaultNamedAnimations = {};\n    namedTransitions = {};\n    defaultNamedTransitions = {};\n    motionController = new up.MotionController('motion');\n\n    /***\n    Sets default options for animations and transitions.\n    \n    @property up.motion.config\n    @param {number} [config.duration=300]\n      The default duration for all animations and transitions (in milliseconds).\n    @param {number} [config.delay=0]\n      The default delay for all animations and transitions (in milliseconds).\n    @param {string} [config.easing='ease']\n      The default timing function that controls the acceleration of animations and transitions.\n    \n      See [W3C documentation](http://www.w3.org/TR/css3-transitions/#transition-timing-function)\n      for a list of pre-defined timing functions.\n    @param {boolean} [config.enabled=true]\n      Whether animation is enabled.\n    \n      Set this to `false` to disable animation globally.\n      This can be useful in full-stack integration tests like a Selenium test suite.\n    \n      Regardless of this setting, all animations will be skipped on browsers\n      that do not support [CSS transitions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions).\n    @stable\n     */\n    config = new up.Config({\n      duration: 300,\n      delay: 0,\n      easing: 'ease',\n      enabled: true\n    });\n    reset = function() {\n      motionController.reset();\n      namedAnimations = u.copy(defaultNamedAnimations);\n      namedTransitions = u.copy(defaultNamedTransitions);\n      return config.reset();\n    };\n\n    /***\n    Returns whether Unpoly will perform animations.\n    \n    Set [`up.motion.config.enabled`](/up.motion.config) `false` in order to disable animations globally.\n    \n    @function up.motion.isEnabled\n    @return {boolean}\n    @stable\n     */\n    isEnabled = function() {\n      return config.enabled;\n    };\n\n    /***\n    Applies the given animation to the given element.\n    \n    \\#\\#\\# Example\n    \n        up.animate('.warning', 'fade-in')\n    \n    You can pass additional options:\n    \n        up.animate('.warning', 'fade-in', {\n          delay: 1000,\n          duration: 250,\n          easing: 'linear'\n        })\n    \n    \\#\\#\\# Named animations\n    \n    The following animations are pre-defined:\n    \n    | `fade-in`          | Changes the element's opacity from 0% to 100% |\n    | `fade-out`         | Changes the element's opacity from 100% to 0% |\n    | `move-to-top`      | Moves the element upwards until it exits the screen at the top edge |\n    | `move-from-top`    | Moves the element downwards from beyond the top edge of the screen until it reaches its current position |\n    | `move-to-bottom`   | Moves the element downwards until it exits the screen at the bottom edge |\n    | `move-from-bottom` | Moves the element upwards from beyond the bottom edge of the screen until it reaches its current position |\n    | `move-to-left`     | Moves the element leftwards until it exists the screen at the left edge  |\n    | `move-from-left`   | Moves the element rightwards from beyond the left edge of the screen until it reaches its current position |\n    | `move-to-right`    | Moves the element rightwards until it exists the screen at the right edge  |\n    | `move-from-right`  | Moves the element leftwards from beyond the right  edge of the screen until it reaches its current position |\n    | `none`             | An animation that has no visible effect. Sounds useless at first, but can save you a lot of `if` statements. |\n    \n    You can define additional named animations using [`up.animation()`](/up.animation).\n    \n    \\#\\#\\# Animating CSS properties directly\n    \n    By passing an object instead of an animation name, you can animate\n    the CSS properties of the given element:\n    \n        var warning = document.querySelector('.warning')\n        warning.style.opacity = 0\n        up.animate(warning, { opacity: 1 })\n    \n    CSS properties must be given in `kebab-case`, not `camelCase`.\n    \n    \\#\\#\\# Multiple animations on the same element\n    \n    Unpoly doesn't allow more than one concurrent animation on the same element.\n    \n    If you attempt to animate an element that is already being animated,\n    the previous animation will instantly jump to its last frame before\n    the new animation begins.\n    \n    @function up.animate\n    @param {Element|jQuery|string} elementOrSelector\n      The element to animate.\n    @param {string|Function(element, options): Promise|Object} animation\n      Can either be:\n    \n      - The animation's name\n      - A function performing the animation\n      - An object of CSS attributes describing the last frame of the animation (using kebeb-case property names)\n    @param {number} [options.duration=300]\n      The duration of the animation, in milliseconds.\n    @param {number} [options.delay=0]\n      The delay before the animation starts, in milliseconds.\n    @param {string} [options.easing='ease']\n      The timing function that controls the animation's acceleration.\n    \n      See [W3C documentation](http://www.w3.org/TR/css3-transitions/#transition-timing-function)\n      for a list of pre-defined timing functions.\n    @return {Promise}\n      A promise for the animation's end.\n    @stable\n     */\n    animate = function(elementOrSelector, animation, options) {\n      var animationFn, element, runNow, willRun;\n      element = e.get(elementOrSelector);\n      options = animateOptions(options);\n      animationFn = findAnimationFn(animation);\n      willRun = willAnimate(element, animation, options);\n      if (willRun) {\n        runNow = function() {\n          return animationFn(element, options);\n        };\n        return motionController.startFunction(element, runNow, options);\n      } else {\n        return skipAnimate(element, animation);\n      }\n    };\n    willAnimate = function(element, animationOrTransition, options) {\n      options = animateOptions(options);\n      return isEnabled() && !isNone(animationOrTransition) && options.duration > 0 && !e.isSingleton(element);\n    };\n    skipAnimate = function(element, animation) {\n      if (u.isOptions(animation)) {\n        e.setStyle(element, animation);\n      }\n      return Promise.resolve();\n    };\n    animCount = 0;\n\n    /***\n    Animates the given element's CSS properties using CSS transitions.\n    \n    Does not track the animation, nor does it finishes existing animations\n    (use `up.motion.animate()` for that). It does, however, listen to the motionController's\n    finish event.\n    \n    @function animateNow\n    @param {Element|jQuery|string} elementOrSelector\n      The element to animate.\n    @param {Object} lastFrame\n      The CSS properties that should be transitioned to.\n    @param {number} [options.duration=300]\n      The duration of the animation, in milliseconds.\n    @param {number} [options.delay=0]\n      The delay before the animation starts, in milliseconds.\n    @param {string} [options.easing='ease']\n      The timing function that controls the animation's acceleration.\n      See [W3C documentation](http://www.w3.org/TR/css3-transitions/#transition-timing-function)\n      for a list of pre-defined timing functions.\n    @return {Promise}\n      A promise that fulfills when the animation ends.\n    @internal\n     */\n    animateNow = function(element, lastFrame, options) {\n      var cssTransition;\n      options = u.merge(options, {\n        finishEvent: motionController.finishEvent\n      });\n      cssTransition = new up.CssTransition(element, lastFrame, options);\n      return cssTransition.start();\n    };\n\n    /***\n    Extracts animation-related options from the given options hash.\n    If `element` is given, also inspects the element for animation-related\n    attributes like `up-easing` or `up-duration`.\n    \n    @param {Object} userOptions\n    @param {Element|jQuery} [element]\n    @param {Object} [moduleDefaults]\n    @function up.motion.animateOptions\n    @internal\n     */\n    animateOptions = function() {\n      var args, consolidatedOptions, element, moduleDefaults, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, userOptions;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      userOptions = (ref = args.shift()) != null ? ref : {};\n      moduleDefaults = u.extractOptions(args);\n      element = args.pop() || e.none();\n      consolidatedOptions = {};\n      consolidatedOptions.easing = (ref1 = (ref2 = (ref3 = userOptions.easing) != null ? ref3 : element.getAttribute('up-easing')) != null ? ref2 : moduleDefaults.easing) != null ? ref1 : config.easing;\n      consolidatedOptions.duration = (ref4 = (ref5 = (ref6 = userOptions.duration) != null ? ref6 : e.numberAttr(element, 'up-duration')) != null ? ref5 : moduleDefaults.duration) != null ? ref4 : config.duration;\n      consolidatedOptions.delay = (ref7 = (ref8 = (ref9 = userOptions.delay) != null ? ref9 : e.numberAttr(element, 'up-delay')) != null ? ref8 : moduleDefaults.delay) != null ? ref7 : config.delay;\n      consolidatedOptions.trackMotion = userOptions.trackMotion;\n      return consolidatedOptions;\n    };\n    findNamedAnimation = function(name) {\n      return namedAnimations[name] || up.fail(\"Unknown animation %o\", name);\n    };\n\n    /***\n    Completes [animations](/up.animate) and [transitions](/up.morph).\n    \n    If called without arguments, all animations on the screen are completed.\n    If given an element (or selector), animations on that element and its children\n    are completed.\n    \n    Animations are completed by jumping to the last animation frame instantly.\n    Promises returned by animation and transition functions instantly settle.\n    \n    Emits the `up:motion:finish` event that is already handled by `up.animate()`.\n    \n    Does nothing if there are no animation to complete.\n    \n    @function up.motion.finish\n    @param {Element|jQuery|string} [elementOrSelector]\n    @return {Promise}\n      A promise that fulfills when animations and transitions have finished.\n    @stable\n     */\n    finish = function(elementOrSelector) {\n      return motionController.finish(elementOrSelector);\n    };\n\n    /***\n    This event is emitted on an [animating](/up.animating) element by `up.motion.finish()` to\n    request the animation to instantly finish and skip to the last frame.\n    \n    Promises returned by completed animation functions are expected to settle.\n    \n    Animations started by `up.animate()` already handle this event.\n    \n    @event up:motion:finish\n    @param {Element} event.target\n      The animating element.\n    @experimental\n     */\n\n    /***\n    Performs an animated transition between the `source` and `target` elements.\n    \n    Transitions are implement by performing two animations in parallel,\n    causing `source` to disappear and the `target` to appear.\n    \n    - `target` is [inserted before](https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore) `source`\n    - `source` is removed from the [document flow](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning) with `position: absolute`.\n       It will be positioned over its original place in the flow that is now occupied by `target`.\n    - Both `source` and `target` are animated in parallel\n    - `source` is removed from the DOM\n    \n    \\#\\#\\# Named transitions\n    \n    The following transitions are pre-defined:\n    \n    | `cross-fade` | Fades out the first element. Simultaneously fades in the second element. |\n    | `move-up`    | Moves the first element upwards until it exits the screen at the top edge. Simultaneously moves the second element upwards from beyond the bottom edge of the screen until it reaches its current position. |\n    | `move-down`  | Moves the first element downwards until it exits the screen at the bottom edge. Simultaneously moves the second element downwards from beyond the top edge of the screen until it reaches its current position. |\n    | `move-left`  | Moves the first element leftwards until it exists the screen at the left edge. Simultaneously moves the second element leftwards from beyond the right  edge of the screen until it reaches its current position. |\n    | `move-right` | Moves the first element rightwards until it exists the screen at the right edge. Simultaneously moves the second element rightwards from beyond the left edge of the screen until it reaches its current position. |\n    | `none`       | A transition that has no visible effect. Sounds useless at first, but can save you a lot of `if` statements. |\n    \n    You can define additional named transitions using [`up.transition()`](/up.transition).\n    \n    You can also compose a transition from two [named animations](/named-animations).\n    separated by a slash character (`/`):\n    \n    - `move-to-bottom/fade-in`\n    - `move-to-left/move-from-top`\n    \n    \\#\\#\\# Implementation details\n    \n    During a transition both the old and new element occupy\n    the same position on the screen.\n    \n    Since the CSS layout flow will usually not allow two elements to\n    overlay the same space, Unpoly:\n    \n    - The old and new elements are cloned\n    - The old element is removed from the layout flow using `display: hidden`\n    - The new element is hidden, but still leaves space in the layout flow by setting `visibility: hidden`\n    - The clones are [absolutely positioned](https://developer.mozilla.org/en-US/docs/Web/CSS/position#Absolute_positioning)\n      over the original elements.\n    - The transition is applied to the cloned elements.\n      At no point will the hidden, original elements be animated.\n    - When the transition has finished, the clones are removed from the DOM and the new element is shown.\n      The old element remains hidden in the DOM.\n    \n    @function up.morph\n    @param {Element|jQuery|string} source\n    @param {Element|jQuery|string} target\n    @param {Function(oldElement, newElement)|string} transition\n    @param {number} [options.duration=300]\n      The duration of the animation, in milliseconds.\n    @param {number} [options.delay=0]\n      The delay before the animation starts, in milliseconds.\n    @param {string} [options.easing='ease']\n      The timing function that controls the transition's acceleration.\n    \n      See [W3C documentation](http://www.w3.org/TR/css3-transitions/#transition-timing-function)\n      for a list of pre-defined timing functions.\n    @param {boolean} [options.reveal=false]\n      Whether to reveal the new element by scrolling its parent viewport.\n    @return {Promise}\n      A promise that fulfills when the transition ends.\n    @stable\n     */\n    morph = function(oldElement, newElement, transitionObject, options) {\n      var afterDetach, afterInsert, beforeDetach, beforeStart, oldRemote, promise, scrollNew, scrollTopBeforeReveal, trackable, transitionFn, viewport, willMorph;\n      options = u.options(options);\n      u.assign(options, animateOptions(options));\n      oldElement = e.get(oldElement);\n      newElement = e.get(newElement);\n      transitionFn = findTransitionFn(transitionObject);\n      willMorph = willAnimate(oldElement, transitionFn, options);\n      beforeStart = u.pluckKey(options, 'beforeStart') || u.noop;\n      afterInsert = u.pluckKey(options, 'afterInsert') || u.noop;\n      beforeDetach = u.pluckKey(options, 'beforeDetach') || u.noop;\n      afterDetach = u.pluckKey(options, 'afterDetach') || u.noop;\n      beforeStart();\n      scrollNew = function() {\n        var scrollOptions;\n        scrollOptions = u.merge(options, {\n          scrollBehavior: 'auto'\n        });\n        return up.viewport.scrollAfterInsertFragment(newElement, scrollOptions);\n      };\n      if (willMorph) {\n        if (motionController.isActive(oldElement) && options.trackMotion === false) {\n          return transitionFn(oldElement, newElement, options);\n        }\n        up.puts('Morphing %o to %o with transition %o', oldElement, newElement, transitionObject);\n        viewport = up.viewport.closest(oldElement);\n        scrollTopBeforeReveal = viewport.scrollTop;\n        oldRemote = up.viewport.absolutize(oldElement, {\n          afterMeasure: function() {\n            e.insertBefore(oldElement, newElement);\n            return afterInsert();\n          }\n        });\n        trackable = function() {\n          var promise;\n          promise = scrollNew();\n          promise = promise.then(function() {\n            var scrollTopAfterReveal;\n            scrollTopAfterReveal = viewport.scrollTop;\n            oldRemote.moveBounds(0, scrollTopAfterReveal - scrollTopBeforeReveal);\n            return transitionFn(oldElement, newElement, options);\n          });\n          promise = promise.then(function() {\n            beforeDetach();\n            e.remove(oldRemote.bounds);\n            return afterDetach();\n          });\n          return promise;\n        };\n        return motionController.startFunction([oldElement, newElement], trackable, options);\n      } else {\n        beforeDetach();\n        swapElementsDirectly(oldElement, newElement);\n        afterInsert();\n        afterDetach();\n        promise = scrollNew();\n        return promise;\n      }\n    };\n    findTransitionFn = function(object) {\n      var namedTransition;\n      if (isNone(object)) {\n        return void 0;\n      } else if (u.isFunction(object)) {\n        return object;\n      } else if (u.isArray(object)) {\n        return composeTransitionFn.apply(null, object);\n      } else if (u.isString(object)) {\n        if (object.indexOf('/') >= 0) {\n          return composeTransitionFn.apply(null, object.split('/'));\n        } else if (namedTransition = namedTransitions[object]) {\n          return findTransitionFn(namedTransition);\n        }\n      } else {\n        return up.fail(\"Unknown transition %o\", object);\n      }\n    };\n    composeTransitionFn = function(oldAnimation, newAnimation) {\n      var newAnimationFn, oldAnimationFn;\n      if (isNone(oldAnimation) && isNone(oldAnimation)) {\n        return void 0;\n      } else {\n        oldAnimationFn = findAnimationFn(oldAnimation) || u.asyncNoop;\n        newAnimationFn = findAnimationFn(newAnimation) || u.asyncNoop;\n        return function(oldElement, newElement, options) {\n          return Promise.all([oldAnimationFn(oldElement, options), newAnimationFn(newElement, options)]);\n        };\n      }\n    };\n    findAnimationFn = function(object) {\n      if (isNone(object)) {\n        return void 0;\n      } else if (u.isFunction(object)) {\n        return object;\n      } else if (u.isString(object)) {\n        return findNamedAnimation(object);\n      } else if (u.isOptions(object)) {\n        return function(element, options) {\n          return animateNow(element, object, options);\n        };\n      } else {\n        return up.fail('Unknown animation %o', object);\n      }\n    };\n    swapElementsDirectly = function(oldElement, newElement) {\n      return e.replace(oldElement, newElement);\n    };\n\n    /***\n    Defines a named transition that [morphs](/up.element) from one element to another.\n    \n    \\#\\#\\# Example\n    \n    Here is the definition of the pre-defined `cross-fade` animation:\n    \n        up.transition('cross-fade', (oldElement, newElement, options) ->\n          Promise.all([\n            up.animate(oldElement, 'fade-out', options),\n            up.animate(newElement, 'fade-in', options)\n          ])\n        )\n    \n    It is recommended that your transitions use [`up.animate()`](/up.animate),\n    passing along the `options` that were passed to you.\n    \n    If you choose to *not* use `up.animate()` and roll your own\n    logic instead, your code must honor the following contract:\n    \n    1. It must honor the options `{ delay, duration, easing }` if given.\n    2. It must *not* remove any of the given elements from the DOM.\n    3. It returns a promise that is fulfilled when the transition has ended.\n    4. If during the animation an event `up:motion:finish` is emitted on\n       either element, the transition instantly jumps to the last frame\n       and resolves the returned promise.\n    \n    Calling [`up.animate()`](/up.animate) with an object argument\n    will take care of all these points.\n    \n    @function up.transition\n    @param {string} name\n    @param {Function(oldElement, newElement, options): Promise|Array} transition\n    @stable\n     */\n    registerTransition = function(name, transition) {\n      return namedTransitions[name] = findTransitionFn(transition);\n    };\n\n    /***\n    Defines a named animation.\n    \n    Here is the definition of the pre-defined `fade-in` animation:\n    \n        up.animation('fade-in', function(element, options) {\n          element.style.opacity = 0\n          up.animate(element, { opacity: 1 }, options)\n        })\n    \n    It is recommended that your definitions always end by calling\n    calling [`up.animate()`](/up.animate) with an object argument, passing along\n    the `options` that were passed to you.\n    \n    If you choose to *not* use `up.animate()` and roll your own\n    animation code instead, your code must honor the following contract:\n    \n    1. It must honor the options `{ delay, duration, easing }` if given\n    2. It must *not* remove any of the given elements from the DOM.\n    3. It returns a promise that is fulfilled when the transition has ended\n    4. If during the animation an event `up:motion:finish` is emitted on\n       the given element, the transition instantly jumps to the last frame\n       and resolves the returned promise.\n    \n    Calling [`up.animate()`](/up.animate) with an object argument\n    will take care of all these points.\n    \n    @function up.animation\n    @param {string} name\n    @param {Function(element, options): Promise} animation\n    @stable\n     */\n    registerAnimation = function(name, animation) {\n      return namedAnimations[name] = findAnimationFn(animation);\n    };\n    snapshot = function() {\n      defaultNamedAnimations = u.copy(namedAnimations);\n      return defaultNamedTransitions = u.copy(namedTransitions);\n    };\n\n    /***\n    Returns whether the given animation option will cause the animation\n    to be skipped.\n    \n    @function up.motion.isNone\n    @internal\n     */\n    isNone = function(animationOrTransition) {\n      return !animationOrTransition || animationOrTransition === 'none' || u.isBlank(animationOrTransition);\n    };\n    registerAnimation('fade-in', function(element, options) {\n      e.setStyle(element, {\n        opacity: 0\n      });\n      return animateNow(element, {\n        opacity: 1\n      }, options);\n    });\n    registerAnimation('fade-out', function(element, options) {\n      e.setStyle(element, {\n        opacity: 1\n      });\n      return animateNow(element, {\n        opacity: 0\n      }, options);\n    });\n    translateCss = function(x, y) {\n      return {\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\"\n      };\n    };\n    registerAnimation('move-to-top', function(element, options) {\n      var box, travelDistance;\n      e.setStyle(element, translateCss(0, 0));\n      box = element.getBoundingClientRect();\n      travelDistance = box.top + box.height;\n      return animateNow(element, translateCss(0, -travelDistance), options);\n    });\n    registerAnimation('move-from-top', function(element, options) {\n      var box, travelDistance;\n      e.setStyle(element, translateCss(0, 0));\n      box = element.getBoundingClientRect();\n      travelDistance = box.top + box.height;\n      e.setStyle(element, translateCss(0, -travelDistance));\n      return animateNow(element, translateCss(0, 0), options);\n    });\n    registerAnimation('move-to-bottom', function(element, options) {\n      var box, travelDistance;\n      e.setStyle(element, translateCss(0, 0));\n      box = element.getBoundingClientRect();\n      travelDistance = e.root().clientHeight - box.top;\n      return animateNow(element, translateCss(0, travelDistance), options);\n    });\n    registerAnimation('move-from-bottom', function(element, options) {\n      var box, travelDistance;\n      e.setStyle(element, translateCss(0, 0));\n      box = element.getBoundingClientRect();\n      travelDistance = up.viewport.rootHeight() - box.top;\n      e.setStyle(element, translateCss(0, travelDistance));\n      return animateNow(element, translateCss(0, 0), options);\n    });\n    registerAnimation('move-to-left', function(element, options) {\n      var box, travelDistance;\n      e.setStyle(element, translateCss(0, 0));\n      box = element.getBoundingClientRect();\n      travelDistance = box.left + box.width;\n      return animateNow(element, translateCss(-travelDistance, 0), options);\n    });\n    registerAnimation('move-from-left', function(element, options) {\n      var box, travelDistance;\n      e.setStyle(element, translateCss(0, 0));\n      box = element.getBoundingClientRect();\n      travelDistance = box.left + box.width;\n      e.setStyle(element, translateCss(-travelDistance, 0));\n      return animateNow(element, translateCss(0, 0), options);\n    });\n    registerAnimation('move-to-right', function(element, options) {\n      var box, travelDistance;\n      e.setStyle(element, translateCss(0, 0));\n      box = element.getBoundingClientRect();\n      travelDistance = up.viewport.rootWidth() - box.left;\n      return animateNow(element, translateCss(travelDistance, 0), options);\n    });\n    registerAnimation('move-from-right', function(element, options) {\n      var box, travelDistance;\n      e.setStyle(element, translateCss(0, 0));\n      box = element.getBoundingClientRect();\n      travelDistance = up.viewport.rootWidth() - box.left;\n      e.setStyle(element, translateCss(travelDistance, 0));\n      return animateNow(element, translateCss(0, 0), options);\n    });\n    registerAnimation('roll-down', function(element, options) {\n      var deferred, previousHeightStr, styleMemo;\n      previousHeightStr = e.style(element, 'height');\n      styleMemo = e.setTemporaryStyle(element, {\n        height: '0px',\n        overflow: 'hidden'\n      });\n      deferred = animate(element, {\n        height: previousHeightStr\n      }, options);\n      deferred.then(styleMemo);\n      return deferred;\n    });\n    registerTransition('move-left', ['move-to-left', 'move-from-right']);\n    registerTransition('move-right', ['move-to-right', 'move-from-left']);\n    registerTransition('move-up', ['move-to-top', 'move-from-bottom']);\n    registerTransition('move-down', ['move-to-bottom', 'move-from-top']);\n    registerTransition('cross-fade', ['fade-out', 'fade-in']);\n    up.on('up:framework:booted', snapshot);\n    up.on('up:framework:reset', reset);\n    return {\n      morph: morph,\n      animate: animate,\n      animateOptions: animateOptions,\n      finish: finish,\n      finishCount: function() {\n        return motionController.finishCount;\n      },\n      transition: registerTransition,\n      animation: registerAnimation,\n      config: config,\n      isEnabled: isEnabled,\n      isNone: isNone\n    };\n  })();\n\n  up.transition = up.motion.transition;\n\n  up.animation = up.motion.animation;\n\n  up.morph = up.motion.morph;\n\n  up.animate = up.motion.animate;\n\n}).call(this);\n\n/***\nAJAX acceleration\n=================\n\nUnpoly comes with a number of tricks to shorten the latency between browser and server.\n\n\\#\\#\\# Server responses are cached by default\n\nUnpoly caches server responses for a few minutes,\nmaking requests to these URLs return instantly.\nAll Unpoly functions and selectors go through this cache, unless\nyou explicitly pass a `{ cache: false }` option or set an `up-cache=\"false\"` attribute.\n\nThe cache holds up to 70 responses for 5 minutes. You can configure the cache size and expiry using\n[`up.proxy.config`](/up.proxy.config), or clear the cache manually using [`up.proxy.clear()`](/up.proxy.clear).\n\nAlso the entire cache is cleared with every non-`GET` request (like `POST` or `PUT`).\n\nIf you need to make cache-aware requests from your [custom JavaScript](/up.syntax),\nuse [`up.request()`](/up.request).\n\n\\#\\#\\# Preloading links\n\nUnpoly also lets you speed up reaction times by [preloading\nlinks](/a-up-preload) when the user hovers over the click area (or puts the mouse/finger\ndown). This way the response will already be cached when\nthe user releases the mouse/finger.\n\n\\#\\#\\# Spinners\n\nYou can listen to the [`up:proxy:slow`](/up:proxy:slow) event to implement a spinner\nthat appears during a long-running request.\n\n\\#\\#\\# More acceleration\n\nOther Unpoly modules contain even more tricks to outsmart network latency:\n\n- [Instantaneous feedback for links that are currently loading](/a.up-active)\n- [Follow links on `mousedown` instead of `click`](/a-up-instant)\n\n@module up.proxy\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.proxy = (function() {\n    var ajax, alias, cache, cancelPreloadDelay, cancelSlowDelay, clear, config, e, get, isBusy, isIdle, isSafeMethod, load, loadEnded, loadOrQueue, loadStarted, makeRequest, pendingCount, pokeQueue, preload, preloadAfterDelay, preloadDelayTimer, queue, queuedLoaders, registerAliasForRedirect, remove, reset, responseReceived, set, slowDelayTimer, slowEventEmitted, startPreloadDelay, stopPreload, u, waitingLink, wrapMethod;\n    u = up.util;\n    e = up.element;\n    waitingLink = void 0;\n    preloadDelayTimer = void 0;\n    slowDelayTimer = void 0;\n    pendingCount = void 0;\n    slowEventEmitted = void 0;\n    queuedLoaders = [];\n\n    /***\n    @property up.proxy.config\n    @param {number} [config.preloadDelay=75]\n      The number of milliseconds to wait before [`[up-preload]`](/a-up-preload)\n      starts preloading.\n    @param {number} [config.cacheSize=70]\n      The maximum number of responses to cache.\n      If the size is exceeded, the oldest items will be dropped from the cache.\n    @param {number} [config.cacheExpiry=300000]\n      The number of milliseconds until a cache entry expires.\n      Defaults to 5 minutes.\n    @param {number} [config.slowDelay=300]\n      How long the proxy waits until emitting the [`up:proxy:slow` event](/up:proxy:slow).\n      Use this to prevent flickering of spinners.\n    @param {number} [config.maxRequests=4]\n      The maximum number of concurrent requests to allow before additional\n      requests are queued. This currently ignores preloading requests.\n    \n      You might find it useful to set this to `1` in full-stack integration\n      tests (e.g. Selenium).\n    \n      Note that your browser might [impose its own request limit](http://www.browserscope.org/?category=network)\n      regardless of what you configure here.\n    @param {Array<string>} [config.wrapMethods]\n      An array of uppercase HTTP method names. AJAX requests with one of these methods\n      will be converted into a `POST` request and carry their original method as a `_method`\n      parameter. This is to [prevent unexpected redirect behavior](https://makandracards.com/makandra/38347).\n    @param {Array<string>} [config.safeMethods]\n      An array of uppercase HTTP method names that are considered [safe](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1).\n      The proxy cache will only cache safe requests and will clear the entire\n      cache after an unsafe request.\n    @stable\n     */\n    config = new up.Config({\n      slowDelay: 300,\n      preloadDelay: 75,\n      cacheSize: 70,\n      cacheExpiry: 1000 * 60 * 5,\n      maxRequests: 4,\n      wrapMethods: ['PATCH', 'PUT', 'DELETE'],\n      safeMethods: ['GET', 'OPTIONS', 'HEAD']\n    });\n    cache = new up.Cache({\n      size: function() {\n        return config.cacheSize;\n      },\n      expiry: function() {\n        return config.cacheExpiry;\n      },\n      key: function(request) {\n        return up.Request.wrap(request).cacheKey();\n      },\n      cachable: function(request) {\n        return up.Request.wrap(request).isCachable();\n      }\n    });\n\n    /***\n    Returns a cached response for the given request.\n    \n    Returns `undefined` if the given request is not currently cached.\n    \n    @function up.proxy.get\n    @return {Promise<up.Response>}\n      A promise for the response.\n    @experimental\n     */\n    get = function(request) {\n      var candidate, candidates, i, len, requestForBody, requestForHtml, response;\n      request = up.Request.wrap(request);\n      candidates = [request];\n      if (request.target !== 'html') {\n        requestForHtml = request.variant({\n          target: 'html'\n        });\n        candidates.push(requestForHtml);\n        if (request.target !== 'body') {\n          requestForBody = request.variant({\n            target: 'body'\n          });\n          candidates.push(requestForBody);\n        }\n      }\n      for (i = 0, len = candidates.length; i < len; i++) {\n        candidate = candidates[i];\n        if (response = cache.get(candidate)) {\n          return response;\n        }\n      }\n    };\n    cancelPreloadDelay = function() {\n      clearTimeout(preloadDelayTimer);\n      return preloadDelayTimer = null;\n    };\n    cancelSlowDelay = function() {\n      clearTimeout(slowDelayTimer);\n      return slowDelayTimer = null;\n    };\n    reset = function() {\n      waitingLink = null;\n      cancelPreloadDelay();\n      cancelSlowDelay();\n      pendingCount = 0;\n      config.reset();\n      cache.clear();\n      slowEventEmitted = false;\n      return queuedLoaders = [];\n    };\n    reset();\n\n    /***\n    Makes an AJAX request to the given URL.\n    \n    \\#\\#\\# Example\n    \n        up.request('/search', { params: { query: 'sunshine' } }).then(function(response) {\n          console.log('The response text is %o', response.text)\n        }).catch(function() {\n          console.error('The request failed')\n        })\n    \n    \\#\\#\\# Caching\n    \n    All responses are cached by default. If requesting a URL with a non-`GET` method, the response will\n    not be cached and the entire cache will be cleared.\n    \n    You can configure caching with the [`up.proxy.config`](/up.proxy.config) property.\n    \n    \\#\\#\\# Events\n    \n    If a network connection is attempted, the proxy will emit\n    a [`up:proxy:load`](/up:proxy:load) event with the `request` as its argument.\n    Once the response is received, a [`up:proxy:loaded`](/up:proxy:loaded) event will\n    be emitted.\n    \n    @function up.request\n    @param {string} [url]\n      The URL for the request.\n    \n      Instead of passing the URL as a string argument, you can also pass it as an `{ url }` option.\n    @param {string} [options.url]\n      You can omit the first string argument and pass the URL as\n      a `request` property instead.\n    @param {string} [options.method='GET']\n      The HTTP method for the options.\n    @param {boolean} [options.cache]\n      Whether to use a cached response for [safe](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1)\n      requests, if available. If set to `false` a network connection will always be attempted.\n    @param {Object} [options.headers={}]\n      An object of additional HTTP headers.\n    @param {Object|FormData|string|Array} [options.params={}]\n      [Parameters](/up.Params) that should be sent as the request's payload.\n    @param {string} [options.timeout]\n      A timeout in milliseconds.\n    \n      If [`up.proxy.config.maxRequests`](/up.proxy.config#config.maxRequests) is set, the timeout\n      will not include the time spent waiting in the queue.\n    @param {string} [options.target='body']\n      The CSS selector that will be sent as an [`X-Up-Target` header](/up.protocol#optimizing-responses).\n    @param {string} [options.failTarget='body']\n      The CSS selector that will be sent as an [`X-Up-Fail-Target` header](/up.protocol#optimizing-responses).\n    @return {Promise<up.Response>}\n      A promise for the response.\n    @stable\n     */\n    makeRequest = function() {\n      var args, ignoreCache, promise, request, requestOrOptions, url;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      if (u.isString(args[0])) {\n        url = args.shift();\n      }\n      requestOrOptions = args.shift() || {};\n      if (url) {\n        requestOrOptions.url = url;\n      }\n      request = up.Request.wrap(requestOrOptions);\n      if (!request.isSafe()) {\n        clear();\n      }\n      ignoreCache = request.cache === false;\n      if (!ignoreCache && (promise = get(request))) {\n        up.puts('Re-using cached response for %s %s', request.method, request.url);\n      } else {\n        promise = loadOrQueue(request);\n        set(request, promise);\n        promise[\"catch\"](function() {\n          return remove(request);\n        });\n      }\n      if (!request.preload) {\n        loadStarted();\n        u.always(promise, loadEnded);\n      }\n      return promise;\n    };\n\n    /***\n    Makes an AJAX request to the given URL and caches the response.\n    \n    The function returns a promise that fulfills with the response text.\n    \n    \\#\\#\\# Example\n    \n        up.request('/search', { params: { query: 'sunshine' } }).then(function(text) {\n          console.log('The response text is %o', text)\n        }).catch(function() {\n          console.error('The request failed')\n        })\n    \n    @function up.ajax\n    @param {string} [url]\n      The URL for the request.\n    \n      Instead of passing the URL as a string argument, you can also pass it as an `{ url }` option.\n    @param {string} [request.url]\n      You can omit the first string argument and pass the URL as\n      a `request` property instead.\n    @param {string} [request.method='GET']\n      The HTTP method for the request.\n    @param {boolean} [request.cache]\n      Whether to use a cached response for [safe](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1)\n      requests, if available. If set to `false` a network connection will always be attempted.\n    @param {Object} [request.headers={}]\n      An object of additional header key/value pairs to send along\n      with the request.\n    @param {Object|FormData|string|Array} [options.params]\n      [Parameters](/up.Params) that should be sent as the request's payload.\n    \n      On IE 11 and Edge, `FormData` payloads require a [polyfill for `FormData#entries()`](https://github.com/jimmywarting/FormData).\n    @param {string} [request.timeout]\n      A timeout in milliseconds for the request.\n    \n      If [`up.proxy.config.maxRequests`](/up.proxy.config#config.maxRequests) is set, the timeout\n      will not include the time spent waiting in the queue.\n    @return {Promise<string>}\n      A promise for the response text.\n    @deprecated\n      Use [`up.request()`](/up.request) instead.\n     */\n    ajax = function() {\n      var args;\n      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n      up.legacy.warn('up.ajax() has been deprecated. Use up.request() instead.');\n      return new Promise(function(resolve, reject) {\n        var pickResponseText;\n        pickResponseText = function(response) {\n          return resolve(response.text);\n        };\n        return makeRequest.apply(null, args).then(pickResponseText, reject);\n      });\n    };\n\n    /***\n    Returns `true` if the proxy is not currently waiting\n    for a request to finish. Returns `false` otherwise.\n    \n    @function up.proxy.isIdle\n    @return {boolean}\n      Whether the proxy is idle\n    @experimental\n     */\n    isIdle = function() {\n      return pendingCount === 0;\n    };\n\n    /***\n    Returns `true` if the proxy is currently waiting\n    for a request to finish. Returns `false` otherwise.\n    \n    @function up.proxy.isBusy\n    @return {boolean}\n      Whether the proxy is busy\n    @experimental\n     */\n    isBusy = function() {\n      return pendingCount > 0;\n    };\n    loadStarted = function() {\n      var emission;\n      pendingCount += 1;\n      if (!slowDelayTimer) {\n        emission = function() {\n          if (isBusy()) {\n            up.emit('up:proxy:slow', {\n              log: 'Proxy is slow to respond'\n            });\n            return slowEventEmitted = true;\n          }\n        };\n        return slowDelayTimer = u.timer(config.slowDelay, emission);\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when [AJAX requests](/up.request)\n    are taking long to finish.\n    \n    By default Unpoly will wait 300 ms for an AJAX request to finish\n    before emitting `up:proxy:slow`. You can configure this time like this:\n    \n        up.proxy.config.slowDelay = 150;\n    \n    Once all responses have been received, an [`up:proxy:recover`](/up:proxy:recover)\n    will be emitted.\n    \n    Note that if additional requests are made while Unpoly is already busy\n    waiting, **no** additional `up:proxy:slow` events will be triggered.\n    \n    \n    \\#\\#\\# Spinners\n    \n    You can [listen](/up.on) to the `up:proxy:slow`\n    and [`up:proxy:recover`](/up:proxy:recover) events to implement a spinner\n    that appears during a long-running request,\n    and disappears once the response has been received:\n    \n        <div class=\"spinner\">Please wait!</div>\n    \n    Here is the JavaScript to make it alive:\n    \n        up.compiler('.spinner', function(element) {\n          show = () => { up.element.show(element) }\n          hide = () => { up.element.hide(element) }\n    \n          hide()\n    \n          return [\n            up.on('up:proxy:slow', show),\n            up.on('up:proxy:recover', hide)\n          ]\n        })\n    \n    The `up:proxy:slow` event will be emitted after a delay of 300 ms\n    to prevent the spinner from flickering on and off.\n    You can change (or remove) this delay by [configuring `up.proxy`](/up.proxy.config) like this:\n    \n        up.proxy.config.slowDelay = 150;\n    \n    \n    @event up:proxy:slow\n    @stable\n     */\n    loadEnded = function() {\n      pendingCount -= 1;\n      if (isIdle()) {\n        cancelSlowDelay();\n        if (slowEventEmitted) {\n          up.emit('up:proxy:recover', {\n            log: 'Proxy has recovered from slow response'\n          });\n          return slowEventEmitted = false;\n        }\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when [AJAX requests](/up.request)\n    have [taken long to finish](/up:proxy:slow), but have finished now.\n    \n    See [`up:proxy:slow`](/up:proxy:slow) for more documentation on\n    how to use this event for implementing a spinner that shows during\n    long-running requests.\n    \n    @event up:proxy:recover\n    @stable\n     */\n    loadOrQueue = function(request) {\n      if (pendingCount < config.maxRequests) {\n        return load(request);\n      } else {\n        return queue(request);\n      }\n    };\n    queue = function(request) {\n      var loader;\n      up.puts('Queuing request for %s %s', request.method, request.url);\n      loader = function() {\n        return load(request);\n      };\n      loader = u.previewable(loader);\n      queuedLoaders.push(loader);\n      return loader.promise;\n    };\n    load = function(request) {\n      var eventProps, responsePromise;\n      eventProps = {\n        request: request,\n        log: ['Loading %s %s', request.method, request.url]\n      };\n      if (up.event.nobodyPrevents('up:proxy:load', eventProps)) {\n        responsePromise = request.send();\n        u.always(responsePromise, responseReceived);\n        u.always(responsePromise, pokeQueue);\n        return responsePromise;\n      } else {\n        u.microtask(pokeQueue);\n        return Promise.reject(new Error('Event up:proxy:load was prevented'));\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) before an [AJAX request](/up.request)\n    is sent over the network.\n    \n    @event up:proxy:load\n    @param {up.Request} event.request\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the request from being sent.\n    @experimental\n     */\n    registerAliasForRedirect = function(response) {\n      var newRequest, request;\n      request = response.request;\n      if (response.url && request.url !== response.url) {\n        newRequest = request.variant({\n          method: response.method,\n          url: response.url\n        });\n        return up.proxy.alias(request, newRequest);\n      }\n    };\n    responseReceived = function(response) {\n      if (response.isFatalError()) {\n        return up.emit('up:proxy:fatal', {\n          log: 'Fatal error during request',\n          request: response.request,\n          response: response\n        });\n      } else {\n        if (!response.isError()) {\n          registerAliasForRedirect(response);\n        }\n        return up.emit('up:proxy:loaded', {\n          log: ['Server responded with HTTP %d (%d bytes)', response.status, response.text.length],\n          request: response.request,\n          response: response\n        });\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when the response to an\n    [AJAX request](/up.request) has been received.\n    \n    Note that this event will also be emitted when the server signals an\n    error with an HTTP status like `500`. Only if the request\n    encounters a fatal error (like a loss of network connectivity),\n    [`up:proxy:fatal`](/up:proxy:fatal) is emitted instead.\n    \n    @event up:proxy:loaded\n    @param {up.Request} event.request\n    @param {up.Response} event.response\n    @experimental\n     */\n\n    /***\n    This event is [emitted](/up.emit) when an [AJAX request](/up.request)\n    encounters fatal error like a timeout or loss of network connectivity.\n    \n    Note that this event will *not* be emitted when the server produces an\n    error message with an HTTP status like `500`. When the server can produce\n    any response, [`up:proxy:loaded`](/up:proxy:loaded) is emitted instead.\n    \n    @event up:proxy:fatal\n     */\n    pokeQueue = function() {\n      var base;\n      if (typeof (base = queuedLoaders.shift()) === \"function\") {\n        base();\n      }\n      return void 0;\n    };\n\n    /***\n    Makes the proxy assume that `newRequest` has the same response as the\n    already cached `oldRequest`.\n    \n    Unpoly uses this internally when the user redirects from `/old` to `/new`.\n    In that case, both `/old` and `/new` will cache the same response from `/new`.\n    \n    @function up.proxy.alias\n    @param {Object} oldRequest\n    @param {Object} newRequest\n    @experimental\n     */\n    alias = cache.alias;\n\n    /***\n    Manually stores a promise for the response to the given request.\n    \n    @function up.proxy.set\n    @param {string} request.url\n    @param {string} [request.method='GET']\n    @param {string} [request.target='body']\n    @param {Promise<up.Response>} response\n      A promise for the response.\n    @experimental\n     */\n    set = cache.set;\n\n    /***\n    Manually removes the given request from the cache.\n    \n    You can also [configure](/up.proxy.config) when the proxy\n    automatically removes cache entries.\n    \n    @function up.proxy.remove\n    @param {string} request.url\n    @param {string} [request.method='GET']\n    @param {string} [request.target='body']\n    @experimental\n     */\n    remove = cache.remove;\n\n    /***\n    Removes all cache entries.\n    \n    Unpoly also automatically clears the cache whenever it processes\n    a request with an [unsafe](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1)\n    HTTP method like `POST`.\n    \n    @function up.proxy.clear\n    @stable\n     */\n    clear = cache.clear;\n    preloadAfterDelay = function(link) {\n      var curriedPreload, delay;\n      delay = e.numberAttr(link, 'up-delay') || config.preloadDelay;\n      if (link !== waitingLink) {\n        waitingLink = link;\n        cancelPreloadDelay();\n        curriedPreload = function() {\n          u.muteRejection(preload(link));\n          return waitingLink = null;\n        };\n        return startPreloadDelay(curriedPreload, delay);\n      }\n    };\n    startPreloadDelay = function(block, delay) {\n      return preloadDelayTimer = setTimeout(block, delay);\n    };\n    stopPreload = function(link) {\n      if (link === waitingLink) {\n        waitingLink = void 0;\n        return cancelPreloadDelay();\n      }\n    };\n\n    /***\n    Preloads the given link.\n    \n    When the link is clicked later, the response will already be cached,\n    making the interaction feel instant.\n    \n    @function up.proxy.preload\n    @param {string|Element|jQuery} linkOrSelector\n      The element whose destination should be preloaded.\n    @param {Object} options\n      Options that will be passed to the function making the HTTP requests.\n    @return\n      A promise that will be fulfilled when the request was loaded and cached\n    @experimental\n     */\n    preload = function(linkOrSelector, options) {\n      var link, preloadEventAttrs;\n      link = e.get(linkOrSelector);\n      if (up.link.isSafe(link)) {\n        preloadEventAttrs = {\n          log: ['Preloading link %o', link],\n          target: link\n        };\n        return up.event.whenEmitted('up:link:preload', preloadEventAttrs).then(function() {\n          var variant;\n          variant = up.link.followVariantForLink(link);\n          return variant.preloadLink(link, options);\n        });\n      } else {\n        return Promise.reject(new Error(\"Won't preload unsafe link\"));\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) before a link is [preloaded](/up.preload).\n    \n    @event up:link:preload\n    @param {Element} event.target\n      The link element that will be preloaded.\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the link from being preloaded.\n    @stable\n     */\n\n    /***\n    @internal\n     */\n    isSafeMethod = function(method) {\n      return u.contains(config.safeMethods, method);\n    };\n\n    /***\n    @internal\n     */\n    wrapMethod = function(method, params) {\n      if (u.contains(config.wrapMethods, method)) {\n        params.add(up.protocol.config.methodParam, method);\n        method = 'POST';\n      }\n      return method;\n    };\n\n    /***\n    Links with an `up-preload` attribute will silently fetch their target\n    when the user hovers over the click area, or when the user puts her\n    mouse/finger down (before releasing).\n    \n    When the link is clicked later, the response will already be cached,\n    making the interaction feel instant.   \n    \n    @selector a[up-preload]\n    @param [up-delay=75]\n      The number of milliseconds to wait between hovering\n      and preloading. Increasing this will lower the load in your server,\n      but will also make the interaction feel less instant.\n    @stable\n     */\n    up.compiler('a[up-preload], [up-href][up-preload]', function(link) {\n      if (up.link.isSafe(link)) {\n        link.addEventListener('mouseenter', function(event) {\n          if (up.link.shouldProcessEvent(event, link)) {\n            return preloadAfterDelay(link);\n          }\n        });\n        return link.addEventListener('mouseleave', function() {\n          return stopPreload(link);\n        });\n      }\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      preload: preload,\n      ajax: ajax,\n      request: makeRequest,\n      get: get,\n      alias: alias,\n      clear: clear,\n      remove: remove,\n      isIdle: isIdle,\n      isBusy: isBusy,\n      isSafeMethod: isSafeMethod,\n      wrapMethod: wrapMethod,\n      config: config\n    };\n  })();\n\n  up.ajax = up.proxy.ajax;\n\n  up.request = up.proxy.request;\n\n}).call(this);\n\n/***\nLinking to fragments\n====================\n\nThe `up.link` module lets you build links that update fragments instead of entire pages.\n\n\\#\\#\\# Motivation\n\nIn a traditional web application, the entire page is destroyed and re-created when the\nuser follows a link:\n\n![Traditional page flow](/images/tutorial/fragment_flow_vanilla.svg){:width=\"620\" class=\"picture has_border is_sepia has_padding\"}\n\nThis makes for an unfriendly experience:\n\n- State changes caused by AJAX updates get lost during the page transition.\n- Unsaved form changes get lost during the page transition.\n- The JavaScript VM is reset during the page transition.\n- If the page layout is composed from multiple scrollable containers\n  (e.g. a pane view), the scroll positions get lost during the page transition.\n- The user sees a \"flash\" as the browser loads and renders the new page,\n  even if large portions of the old and new page are the same (navigation, layout, etc.).\n\nUnpoly fixes this by letting you annotate links with an [`up-target`](/a-up-target)\nattribute. The value of this attribute is a CSS selector that indicates which page\nfragment to update. The server **still renders full HTML pages**, but we only use\nthe targeted fragments and discard the rest:\n\n![Unpoly page flow](/images/tutorial/fragment_flow_unpoly.svg){:width=\"620\" class=\"picture has_border is_sepia has_padding\"}\n\nWith this model, following links feels smooth. All transient DOM changes outside the updated fragment are preserved.\nPages also load much faster since the DOM, CSS and Javascript environments do not need to be\ndestroyed and recreated for every request.\n\n\n\\#\\#\\# Example\n\nLet's say we are rendering three pages with a tabbed navigation to switch between screens:\n\nYour HTML could look like this:\n\n```\n<nav>\n  <a href=\"/pages/a\">A</a>\n  <a href=\"/pages/b\">B</a>\n  <a href=\"/pages/b\">C</a>\n</nav>\n\n<article>\n  Page A\n</article>\n```\n\nSince we only want to update the `<article>` tag, we annotate the links\nwith an `up-target` attribute:\n\n```\n<nav>\n  <a href=\"/pages/a\" up-target=\"article\">A</a>\n  <a href=\"/pages/b\" up-target=\"article\">B</a>\n  <a href=\"/pages/b\" up-target=\"article\">C</a>\n</nav>\n```\n\nNote that instead of `article` you can use any other CSS selector like `#main .article`.\n\nWith these [`up-target`](/a-up-target) annotations Unpoly only updates the targeted part of the screen.\nThe JavaScript environment will persist and the user will not see a white flash while the\nnew page is loading.\n\n@module up.link\n */\n\n(function() {\n  up.link = (function() {\n    var DEFAULT_FOLLOW_VARIANT, addFollowVariant, allowDefault, defaultFollow, defaultPreload, e, follow, followMethod, followVariantForLink, followVariants, isFollowable, isSafe, makeFollowable, shouldProcessEvent, u, visit;\n    u = up.util;\n    e = up.element;\n\n    /***\n    Fetches this given URL with JavaScript and [replaces](/up.replace) the\n    current `<body>` element with the response's `<body>` element.\n    \n    \\#\\#\\# Example\n    \n    This would replace the current page with the response for `/users`:\n    \n        up.visit('/users')\n    \n    @function up.visit\n    @param {string} url\n      The URL to visit.\n    @param {string} [options.target='body']\n      The selector to replace.\n    @param {Object} [options]\n      See options for [`up.replace()`](/up.replace)\n    @stable\n     */\n    visit = function(url, options) {\n      var ref, selector;\n      if (options == null) {\n        options = {};\n      }\n      selector = (ref = options.target) != null ? ref : 'body';\n      return up.replace(selector, url, options);\n    };\n\n    /***\n    Fetches the given link's `[href]` with JavaScript and [replaces](/up.replace) the current page with HTML from the response.\n    \n    By default the page's `<body>` element will be replaced.\n    If the link has an attribute like `a[up-target]`\n    or `a[up-modal]`, the respective Unpoly behavior will be used.\n    \n    Emits the event `up:link:follow`.\n    \n    \\#\\#\\# Examples\n    \n    Assume we have a link with an `a[up-target]` attribute:\n    \n        <a href=\"/users\" up-target=\".main\">Users</a>\n    \n    Calling `up.follow()` with this link will replace the page's `.main` fragment\n    as if the user had clicked on the link:\n    \n        var link = document.querySelector('a')\n        up.follow(link)\n    \n    @function up.follow\n    @param {Element|jQuery|string} linkOrSelector\n      An element or selector which is either an `<a>` tag or any element with an `[up-href]` attribute.\n    @param {string} [options.target]\n      The selector to replace.\n    \n      Defaults to the link's `[up-target]`, `[up-modal]` or `[up-popup]` attribute.\n      If no target is given, the `<body>` element will be replaced.\n    @param {String} [options.url]\n      The URL to navigate to.\n    \n      Defaults to the link's `[up-href]` or `[href]` attribute.\n    @param {boolean|string} [options.reveal=true]\n      Whether to [reveal](/up.reveal) the target fragment after it was replaced.\n    \n      You can also pass a CSS selector for the element to reveal.\n    @param {boolean|string} [options.failReveal=true]\n      Whether to [reveal](/up.reveal) the target fragment when the server responds with an error.\n    \n      You can also pass a CSS selector for the element to reveal.\n    @return {Promise}\n      A promise that will be fulfilled when the link destination\n      has been loaded and rendered.\n    @stable\n     */\n    follow = function(linkOrSelector, options) {\n      var link, variant;\n      link = e.get(linkOrSelector);\n      variant = followVariantForLink(link);\n      return variant.followLink(link, options);\n    };\n\n    /***\n    This event is [emitted](/up.emit) when a link is [followed](/up.follow) through Unpoly.\n    \n    The event is emitted on the `<a>` element that is being followed.\n    \n    @event up:link:follow\n    @param {Element} event.target\n      The link element that will be followed.\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the link from being followed.\n    @stable\n     */\n\n    /***\n    @function defaultFollow\n    @internal\n     */\n    defaultFollow = function(link, options) {\n      var ref, ref1, ref2, ref3, ref4, target, url;\n      options = u.options(options);\n      url = (ref = (ref1 = options.url) != null ? ref1 : link.getAttribute('up-href')) != null ? ref : link.getAttribute('href');\n      target = (ref2 = options.target) != null ? ref2 : link.getAttribute('up-target');\n      if (options.failTarget == null) {\n        options.failTarget = link.getAttribute('up-fail-target');\n      }\n      if (options.fallback == null) {\n        options.fallback = link.getAttribute('up-fallback');\n      }\n      if (options.transition == null) {\n        options.transition = e.booleanOrStringAttr(link, 'up-transition');\n      }\n      if (options.failTransition == null) {\n        options.failTransition = e.booleanOrStringAttr(link, 'up-fail-transition');\n      }\n      if (options.history == null) {\n        options.history = e.booleanOrStringAttr(link, 'up-history');\n      }\n      if (options.reveal == null) {\n        options.reveal = (ref3 = e.booleanOrStringAttr(link, 'up-reveal')) != null ? ref3 : true;\n      }\n      if (options.failReveal == null) {\n        options.failReveal = (ref4 = e.booleanOrStringAttr(link, 'up-fail-reveal')) != null ? ref4 : true;\n      }\n      if (options.cache == null) {\n        options.cache = e.booleanAttr(link, 'up-cache');\n      }\n      if (options.restoreScroll == null) {\n        options.restoreScroll = e.booleanAttr(link, 'up-restore-scroll');\n      }\n      options.method = followMethod(link, options);\n      if (options.origin == null) {\n        options.origin = link;\n      }\n      if (options.layer == null) {\n        options.layer = link.getAttribute('up-layer');\n      }\n      if (options.failLayer == null) {\n        options.failLayer = link.getAttribute('up-fail-layer');\n      }\n      if (options.confirm == null) {\n        options.confirm = link.getAttribute('up-confirm');\n      }\n      if (options.scrollBehavior == null) {\n        options.scrollBehavior = link.getAttribute('up-scroll-behavior');\n      }\n      if (options.scrollSpeed == null) {\n        options.scrollSpeed = link.getAttribute('up-scroll-speed');\n      }\n      options = u.merge(options, up.motion.animateOptions(options, link));\n      return up.browser.whenConfirmed(options).then(function() {\n        return up.replace(target, url, options);\n      });\n    };\n    defaultPreload = function(link, options) {\n      options = u.options(options);\n      options.preload = true;\n      return defaultFollow(link, options);\n    };\n\n    /***\n    Returns the HTTP method that should be used when following the given link.\n    \n    Looks at the link's `up-method` or `data-method` attribute.\n    Defaults to `\"get\"`.\n    \n    @function up.link.followMethod\n    @param link\n    @param options.method {string}\n    @internal\n     */\n    followMethod = function(link, options) {\n      var rawMethod, ref, ref1, ref2;\n      if (options == null) {\n        options = {};\n      }\n      rawMethod = (ref = (ref1 = (ref2 = options.method) != null ? ref2 : link.getAttribute('up-method')) != null ? ref1 : link.getAttribute('data-method')) != null ? ref : 'GET';\n      return rawMethod.toUpperCase();\n    };\n\n    /***\n    No-op that is called when we allow a browser's default action to go through,\n    so we can spy on it in unit tests. See `link_spec.js`.\n    \n    @function allowDefault\n    @internal\n     */\n    allowDefault = function(event) {};\n    followVariants = [];\n\n    /***\n    Registers the given handler for links with the given selector.\n    \n    This does more than a simple `click` handler:\n    \n    - It also handles `[up-instant]`\n    - It also handles `[up-href]`\n    \n    @function up.link.addFollowVariant\n    @param {string} simplifiedSelector\n      A selector without `a` or `[up-href]`, e.g. `[up-target]`\n    @param {Function(element, options)} options.follow\n    @param {Function(element, options)} options.preload\n    @internal\n     */\n    addFollowVariant = function(simplifiedSelector, options) {\n      var variant;\n      variant = new up.FollowVariant(simplifiedSelector, options);\n      followVariants.push(variant);\n      variant.registerEvents();\n      return variant;\n    };\n\n    /***\n    Returns whether the given link will be [followed](/up.follow) by Unpoly\n    instead of making a full page load.\n    \n    A link will be followed by Unpoly if it has an attribute\n    like `a[up-target]` or `a[up-modal]`.\n    \n    @function up.link.isFollowable\n    @param {Element|jQuery|string} linkOrSelector\n      The link to check.\n    @experimental\n     */\n    isFollowable = function(linkOrSelector) {\n      linkOrSelector = e.get(linkOrSelector);\n      return !!followVariantForLink(linkOrSelector, {\n        \"default\": false\n      });\n    };\n\n    /***\n    Returns the handler function that can be used to follow the given link.\n    E.g. it wil return a handler calling `up.modal.follow` if the link is a `[up-modal]`,\n    but a handler calling `up.link.follow` if the links is `[up-target]`.\n    \n    @param {Element} link\n    @return {Object}\n    @internal\n     */\n    followVariantForLink = function(link, options) {\n      var variant;\n      if (options == null) {\n        options = {};\n      }\n      variant = u.find(followVariants, function(variant) {\n        return variant.matchesLink(link);\n      });\n      if (options[\"default\"] !== false) {\n        variant || (variant = DEFAULT_FOLLOW_VARIANT);\n      }\n      return variant;\n    };\n\n    /***\n    Makes sure that the given link will be [followed](/up.follow)\n    by Unpoly instead of making a full page load.\n    \n    This is done by giving the link an `a[up-follow]` attribute\n    unless it already have it an attribute like `a[up-target]` or `a[up-modal]`.\n    \n    @function up.link.makeFollowable\n    @param {Element|jQuery|string} linkOrSelector\n      The link to process.\n    @experimental\n     */\n    makeFollowable = function(link) {\n      if (!isFollowable(link)) {\n        return link.setAttribute('up-follow', '');\n      }\n    };\n    shouldProcessEvent = function(event, link) {\n      var betterTarget, betterTargetSelector, target;\n      target = event.target;\n      if (!u.isUnmodifiedMouseEvent(event)) {\n        return false;\n      }\n      if (target === link) {\n        return true;\n      }\n      betterTargetSelector = \"a, [up-href], \" + (up.form.fieldSelector());\n      betterTarget = e.closest(target, betterTargetSelector);\n      return !betterTarget || betterTarget === link;\n    };\n\n    /***\n    Returns whether the given link has a [safe](https://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.1.1)\n    HTTP method like `GET`.\n    \n    @function up.link.isSafe\n    @experimental\n     */\n    isSafe = function(selectorOrLink, options) {\n      var method;\n      method = followMethod(selectorOrLink, options);\n      return up.proxy.isSafeMethod(method);\n    };\n\n    /***\n    [Follows](/up.follow) this link with JavaScript and replaces a CSS selector\n    on the current page with a corresponding element from the response.\n    \n    \\#\\#\\# Example\n    \n    This will update the fragment `<div class=\"main\">` with the same element\n    fetched from `/posts/5`:\n    \n        <a href=\"/posts/5\" up-target=\".main\">Read post</a>\n    \n    \\#\\#\\# Updating multiple fragments\n    \n    You can update multiple fragments from a single request by separating\n    separators with a comma (like in CSS).\n    \n    For instance, if opening a post should\n    also update a bubble showing the number of unread posts, you might\n    do this:\n    \n        <a href=\"/posts/5\" up-target=\".main, .unread-count\">Read post</a>\n    \n    \\#\\#\\# Appending or prepending content\n    \n    By default Unpoly will replace the given selector with the same\n    selector from the server response. Instead of replacing you\n    can *append* the loaded content to the existing content by using the\n    `:after` pseudo selector. In the same fashion, you can use `:before`\n    to indicate that you would like the *prepend* the loaded content.\n    \n    A practical example would be a paginated list of items. Below the list is\n    a button to load the next page. You can append to the existing list\n    by using `:after` in the `up-target` selector like this:\n    \n        <ul class=\"tasks\">\n          <li>Wash car</li>\n          <li>Purchase supplies</li>\n          <li>Fix tent</li>\n        </ul>\n    \n        <a href=\"/page/2\" class=\"next-page\" up-target=\".tasks:after, .next-page\">\n          Load more tasks\n        </a>\n    \n    \\#\\#\\# Following elements that are no links\n    \n    You can also use `[up-target]` to turn an arbitrary element into a link.\n    In this case, put the link's destination into the `[up-href]` attribute:\n    \n        <button up-target=\".main\" up-href=\"/foo/bar\">Go</button>\n    \n    Note that using any element other than `<a>` will prevent users from\n    opening the destination in a new tab.\n    \n    @selector a[up-target]\n    @param {string} up-target\n      The CSS selector to replace\n    \n      Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-method='get']\n      The HTTP method to use for the request.\n    @param {string} [up-transition='none']\n      The [transition](/up.motion) to use for morphing between the old and new elements.\n    @param [up-fail-target='body']\n      The CSS selector to replace if the server responds with an error.\n    \n      Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-fail-transition='none']\n      The [transition](/up.motion) to use for morphing between the old and new elements\n      when the server responds with an error.\n    @param {string} [up-fallback]\n      The selector to update when the original target was not found in the page.\n    @param {string} [up-href]\n      The destination URL to follow.\n      If omitted, the the link's `href` attribute will be used.\n    @param {string} [up-confirm]\n      A message that will be displayed in a cancelable confirmation dialog\n      before the link is followed.\n    @param {string} [up-reveal='true']\n      Whether to reveal the target element after it was replaced.\n    \n      You can also pass a CSS selector for the element to reveal.\n      Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-fail-reveal='true']\n      Whether to reveal the target element when the server responds with an error.\n    \n      You can also pass a CSS selector for the element to reveal.\n      Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-restore-scroll='false']\n      Whether to restore previously known scroll position of all viewports\n      within the target selector.\n    @param {string} [up-cache]\n      Whether to force the use of a cached response (`true`)\n      or never use the cache (`false`)\n      or make an educated guess (default).\n    @param {string} [up-layer='auto']\n      The name of the layer that ought to be updated. Valid values are\n      `'auto'`, `'page'`, `'modal'` and `'popup'`.\n    \n      If set to `'auto'` (default), Unpoly will try to find a match in the link's layer.\n      If no match was found in that layer,\n      Unpoly will search in other layers, starting from the topmost layer.\n    @param {string} [up-fail-layer='auto']\n      The name of the layer that ought to be updated if the server sends a\n      non-200 status code.\n    @param [up-history]\n      Whether to push an entry to the browser history when following the link.\n    \n      Set this to `'false'` to prevent the URL bar from being updated.\n      Set this to a URL string to update the history with the given URL.\n    @stable\n     */\n    DEFAULT_FOLLOW_VARIANT = addFollowVariant('[up-target], [up-follow]', {\n      follow: function(link, options) {\n        return defaultFollow(link, options);\n      },\n      preload: function(link, options) {\n        return defaultPreload(link, options);\n      }\n    });\n\n    /***\n    Fetches this link's `[href]` with JavaScript and [replaces](/up.replace) the\n    current `<body>` element with the response's `<body>` element.\n    \n    To only update a fragment instead of the entire `<body>`, see `a[up-target]`.\n    \n    \\#\\#\\# Example\n    \n        <a href=\"/users\" up-follow>User list</a>\n    \n    \\#\\#\\# Turn any element into a link\n    \n    You can also use `[up-follow]` to turn an arbitrary element into a link.\n    In this case, put the link's destination into the `up-href` attribute:\n    \n        <span up-follow up-href=\"/foo/bar\">Go</span>\n    \n    Note that using any element other than `<a>` will prevent users from\n    opening the destination in a new tab.\n    \n    @selector a[up-follow]\n    \n    @param {string} [up-method='get']\n      The HTTP method to use for the request.\n    @param [up-fail-target='body']\n      The selector to replace if the server responds with an error.\n    @param {string} [up-fallback]\n      The selector to update when the original target was not found in the page.\n    @param {string} [up-transition='none']\n      The [transition](/up.motion) to use for morphing between the old and new elements.\n    @param {string} [up-fail-transition='none']\n      The [transition](/up.motion) to use for morphing between the old and new elements\n      when the server responds with an error.\n    @param [up-href]\n      The destination URL to follow.\n      If omitted, the the link's `href` attribute will be used.\n    @param {string} [up-confirm]\n      A message that will be displayed in a cancelable confirmation dialog\n      before the link is followed.\n    @param {string} [up-history]\n      Whether to push an entry to the browser history when following the link.\n    \n      Set this to `'false'` to prevent the URL bar from being updated.\n      Set this to a URL string to update the history with the given URL.\n    @param [up-restore-scroll='false']\n      Whether to restore the scroll position of all viewports\n      within the response.\n    @stable\n     */\n\n    /***\n    By adding an `up-instant` attribute to a link, the destination will be\n    fetched on `mousedown` instead of `click` (`mouseup`).\n    \n        <a href=\"/users\" up-target=\".main\" up-instant>User list</a>\n    \n    This will save precious milliseconds that otherwise spent\n    on waiting for the user to release the mouse button. Since an\n    AJAX request will be triggered right way, the interaction will\n    appear faster.\n    \n    Note that using `[up-instant]` will prevent a user from canceling a\n    click by moving the mouse away from the link. However, for\n    navigation actions this isn't needed. E.g. popular operation\n    systems switch tabs on `mousedown` instead of `click`.\n    \n    `[up-instant]` will also work for links that open [modals](/up.modal) or [popups](/up.popup).\n    \n    @selector a[up-instant]\n    @stable\n     */\n\n    /***\n    [Follows](/up.follow) this link *as fast as possible*.\n    \n    This is done by:\n    \n    - [Following the link through AJAX](/a-up-target) instead of a full page load\n    - [Preloading the link's destination URL](/a-up-preload)\n    - [Triggering the link on `mousedown`](/a-up-instant) instead of on `click`\n    \n    \\#\\#\\# Example\n    \n    Use `up-dash` like this:\n    \n        <a href=\"/users\" up-dash=\".main\">User list</a>\n    \n    This is shorthand for:\n    \n        <a href=\"/users\" up-target=\".main\" up-instant up-preload>User list</a>\n    \n    @selector a[up-dash]\n    @param {string} [up-dash='body']\n      The CSS selector to replace\n    \n      Inside the CSS selector you may refer to this link as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @stable\n     */\n    up.macro('[up-dash]', function(element) {\n      var newAttrs, target;\n      target = e.booleanOrStringAttr(element, 'up-dash');\n      element.removeAttribute('up-dash');\n      newAttrs = {\n        'up-preload': '',\n        'up-instant': ''\n      };\n      if (target === true) {\n        makeFollowable(element);\n      } else {\n        newAttrs['up-target'] = target;\n      }\n      return e.setMissingAttrs(element, newAttrs);\n    });\n\n    /***\n    Add an `[up-expand]` attribute to any element to enlarge the click area of a\n    descendant link.\n    \n    `[up-expand]` honors all the Unppoly attributes in expanded links, like\n    `a[up-target]`, `a[up-instant]` or `a[up-preload]`.\n    It also expands links that open [modals](/up.modal) or [popups](/up.popup).\n    \n    \n    \\#\\#\\# Example\n    \n        <div class=\"notification\" up-expand>\n          Record was saved!\n          <a href=\"/records\">Close</a>\n        </div>\n    \n    In the example above, clicking anywhere within `.notification` element\n    would [follow](/up.follow) the *Close* link.\n    \n    \\#\\#\\# Elements with multiple contained links\n    \n    If a container contains more than one link, you can set the value of the\n    `up-expand` attribute to a CSS selector to define which link should be expanded:\n    \n        <div class=\"notification\" up-expand=\".close\">\n          Record was saved!\n          <a class=\"details\" href=\"/records/5\">Details</a>\n          <a class=\"close\" href=\"/records\">Close</a>\n        </div>\n    \n    \\#\\#\\# Limitations\n    \n    `[up-expand]` has some limitations for advanced browser users:\n    \n    - Users won't be able to right-click the expanded area to open a context menu\n    - Users won't be able to `CTRL`+click the expanded area to open a new tab\n    \n    To overcome these limitations, consider nesting the entire clickable area in an actual `<a>` tag.\n    [It's OK to put block elements inside an anchor tag](https://makandracards.com/makandra/43549-it-s-ok-to-put-block-elements-inside-an-a-tag).\n    \n    @selector [up-expand]\n    @param {string} [up-expand]\n      A CSS selector that defines which containing link should be expanded.\n    \n      If omitted, the first link in this element will be expanded.\n    @stable\n     */\n    up.macro('[up-expand]', function(area) {\n      var attribute, childLink, childLinks, i, len, name, newAttrs, ref, selector, upAttributePattern;\n      selector = area.getAttribute('up-expand') || 'a, [up-href]';\n      childLinks = e.all(area, selector);\n      if (childLink = childLinks[0]) {\n        upAttributePattern = /^up-/;\n        newAttrs = {};\n        newAttrs['up-href'] = childLink.getAttribute('href');\n        ref = childLink.attributes;\n        for (i = 0, len = ref.length; i < len; i++) {\n          attribute = ref[i];\n          name = attribute.name;\n          if (name.match(upAttributePattern)) {\n            newAttrs[name] = attribute.value;\n          }\n        }\n        e.setMissingAttrs(area, newAttrs);\n        area.removeAttribute('up-expand');\n        return makeFollowable(area);\n      }\n    });\n    return {\n      visit: visit,\n      follow: follow,\n      makeFollowable: makeFollowable,\n      isSafe: isSafe,\n      isFollowable: isFollowable,\n      shouldProcessEvent: shouldProcessEvent,\n      followMethod: followMethod,\n      addFollowVariant: addFollowVariant,\n      followVariantForLink: followVariantForLink,\n      allowDefault: allowDefault\n    };\n  })();\n\n  up.visit = up.link.visit;\n\n  up.follow = up.link.follow;\n\n}).call(this);\n\n/***\nForms\n=====\n  \nUnpoly comes with functionality to [submit](/form-up-target) and [validate](/input-up-validate)\nforms without leaving the current page. This means you can replace page fragments,\nopen dialogs with sub-forms, etc. all without losing form state.\n\n@module up.form\n */\n\n(function() {\n  var slice = [].slice;\n\n  up.form = (function() {\n    var autosubmit, closestContainer, config, e, fieldSelector, findFields, findSubmissionFields, findSwitcherForTarget, findValidateTarget, observe, observeCallbackFromElement, reset, submit, submitButtonSelector, submittingButton, switchTarget, switchTargets, switcherValues, u, validate;\n    u = up.util;\n    e = up.element;\n\n    /***\n    Sets default options for form submission and validation.\n    \n    @property up.form.config\n    @param {number} [config.observeDelay=0]\n      The number of miliseconds to wait before [`up.observe()`](/up.observe) runs the callback\n      after the input value changes. Use this to limit how often the callback\n      will be invoked for a fast typist.\n    @param {Array} [config.validateTargets=['[up-fieldset]:has(&)', 'fieldset:has(&)', 'label:has(&)', 'form:has(&)']]\n      An array of CSS selectors that are searched around a form field\n      that wants to [validate](/up.validate). The first matching selector\n      will be updated with the validation messages from the server.\n    \n      By default this looks for a `<fieldset>`, `<label>` or `<form>`\n      around the validating input field.\n    @param {string} [config.fields]\n      An array of CSS selectors that represent form fields, such as `input` or `select`.\n    @param {string} [config.submitButtons]\n      An array of CSS selectors that represent submit buttons, such as `input[type=submit]`.\n    @stable\n     */\n    config = new up.Config({\n      validateTargets: ['[up-fieldset]:has(&)', 'fieldset:has(&)', 'label:has(&)', 'form:has(&)'],\n      fields: ['select', 'input:not([type=submit]):not([type=image])', 'button[type]:not([type=submit])', 'textarea'],\n      submitButtons: ['input[type=submit]', 'input[type=image]', 'button[type=submit]', 'button:not([type])'],\n      observeDelay: 0\n    });\n    reset = function() {\n      return config.reset();\n    };\n\n    /***\n    @function up.form.fieldSelector\n    @internal\n     */\n    fieldSelector = function(suffix) {\n      if (suffix == null) {\n        suffix = '';\n      }\n      return config.fields.map(function(field) {\n        return field + suffix;\n      }).join(',');\n    };\n\n    /***\n    Returns a list of form fields within the given element.\n    \n    You can configure what Unpoly considers a form field by adding CSS selectors to the\n    [`up.form.config.fields`](/up.form.config#config.fields) array.\n    \n    If the given element is itself a form field, a list of that given element is returned.\n    \n    @function up.form.fields\n    @param {Element|jQuery} root\n      The element to scan for contained form fields.\n    \n      If the element is itself a form field, a list of that element is returned.\n    @return {NodeList<Element>|Array<Element>}\n    @experimental\n     */\n    findFields = function(root) {\n      var fields, outsideFieldSelector, outsideFields;\n      root = e.get(root);\n      fields = e.subtree(root, fieldSelector());\n      if (e.matches(root, 'form[id]')) {\n        outsideFieldSelector = fieldSelector(e.attributeSelector('form', root.id));\n        outsideFields = e.all(outsideFieldSelector);\n        fields.push.apply(fields, outsideFields);\n        fields = u.uniq(fields);\n      }\n      return fields;\n    };\n\n    /****\n    @function up.form.submissionFields\n    @internal\n     */\n    findSubmissionFields = function(root) {\n      var button, fields;\n      fields = findFields(root);\n      if (button = submittingButton(root)) {\n        fields = u.toArray(fields);\n        fields.push(button);\n      }\n      return fields;\n    };\n\n    /***\n    @function up.form.submittingButton\n    @internal\n     */\n    submittingButton = function(form) {\n      var focusedElement, selector;\n      selector = submitButtonSelector();\n      focusedElement = document.activeElement;\n      if (focusedElement && e.matches(focusedElement, selector) && form.contains(focusedElement)) {\n        return focusedElement;\n      } else {\n        return e.first(form, selector);\n      }\n    };\n\n    /***\n    @function up.form.submitButtonSelector\n    @internal\n     */\n    submitButtonSelector = function() {\n      return config.submitButtons.join(',');\n    };\n\n    /***\n    Submits a form via AJAX and updates a page fragment with the response.\n    \n        up.submit('form.new-user', { target: '.main' })\n    \n    Instead of loading a new page, the form is submitted via AJAX.\n    The response is parsed for a CSS selector and the matching elements will\n    replace corresponding elements on the current page.\n    \n    The unobtrusive variant of this is the [`form[up-target]`](/form-up-target) selector.\n    See the documentation for [`form[up-target]`](/form-up-target) for more\n    information on how AJAX form submissions work in Unpoly.\n    \n    Emits the event [`up:form:submit`](/up:form:submit).\n    \n    @function up.submit\n    @param {Element|jQuery|string} formOrSelector\n      A reference or selector for the form to submit.\n      If the argument points to an element that is not a form,\n      Unpoly will search its ancestors for the closest form.\n    @param {string} [options.url]\n      The URL where to submit the form.\n      Defaults to the form's `action` attribute, or to the current URL of the browser window.\n    @param {string} [options.method='post']\n      The HTTP method used for the form submission.\n      Defaults to the form's `up-method`, `data-method` or `method` attribute, or to `'post'`\n      if none of these attributes are given.\n    @param {string} [options.target]\n      The CSS selector to update when the form submission succeeds (server responds with status 200).\n      Defaults to the form's `up-target` attribute.\n    \n      Inside the CSS selector you may refer to the form as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [options.failTarget]\n      The CSS selector to update when the form submission fails (server responds with non-200 status).\n      Defaults to the form's `up-fail-target` attribute, or to an auto-generated\n      selector that matches the form itself.\n    \n      Inside the CSS selector you may refer to the form as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [options.fallback]\n      The selector to update when the original target was not found in the page.\n      Defaults to the form's `up-fallback` attribute.\n    @param {boolean|string} [options.history=true]\n      Successful form submissions will add a history entry and change the browser's\n      location bar if the form either uses the `GET` method or the response redirected\n      to another page (this requires the `unpoly-rails` gem).\n      If you want to prevent history changes in any case, set this to `false`.\n      If you pass a string, it is used as the URL for the browser history.\n    @param {string} [options.transition='none']\n      The transition to use when a successful form submission updates the `options.target` selector.\n      Defaults to the form's `up-transition` attribute, or to `'none'`.\n    @param {string} [options.failTransition='none']\n      The transition to use when a failed form submission updates the `options.failTarget` selector.\n      Defaults to the form's `up-fail-transition` attribute, or to `options.transition`, or to `'none'`.\n    @param {number} [options.duration]\n      The duration of the transition. See [`up.morph()`](/up.morph).\n    @param {number} [options.delay]\n      The delay before the transition starts. See [`up.morph()`](/up.morph).\n    @param {string} [options.easing]\n      The timing function that controls the transition's acceleration. [`up.morph()`](/up.morph).\n    @param {Element|string} [options.reveal=true]\n      Whether to reveal the target fragment after it was replaced.\n    \n      You can also pass a CSS selector for the element to reveal.\n    @param {boolean|string} [options.failReveal=true]\n      Whether to [reveal](/up.reveal) the target fragment when the server responds with an error.\n    \n      You can also pass a CSS selector for the element to reveal.\n    @param {boolean} [options.restoreScroll]\n      If set to `true`, this will attempt to [`restore scroll positions`](/up.restoreScroll)\n      previously seen on the destination URL.\n    @param {boolean} [options.cache]\n      Whether to force the use of a cached response (`true`)\n      or never use the cache (`false`)\n      or make an educated guess (`undefined`).\n    \n      By default only responses to `GET` requests are cached\n      for a few minutes.\n    @param {Object} [options.headers={}]\n      An object of additional header key/value pairs to send along\n      with the request.\n    @param {string} [options.layer='auto']\n      The name of the layer that ought to be updated. Valid values are\n      `'auto'`, `'page'`, `'modal'` and `'popup'`.\n    \n      If set to `'auto'` (default), Unpoly will try to find a match in the form's layer.\n    @param {string} [options.failLayer='auto']\n      The name of the layer that ought to be updated if the server sends a non-200 status code.\n    @param {Object|FormData|string|Array|up.Params} [options.params]\n      Extra form [parameters](/up.Params) that will be submitted in addition to\n      the parameters from the form.\n    @return {Promise}\n      A promise for the successful form submission.\n    @stable\n     */\n    submit = function(formOrSelector, options) {\n      var form, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, target, url;\n      options = u.options(options);\n      form = e.get(formOrSelector);\n      form = e.closest(form, 'form');\n      target = (ref = (ref1 = options.target) != null ? ref1 : form.getAttribute('up-target')) != null ? ref : 'body';\n      if (options.failTarget == null) {\n        options.failTarget = (ref2 = form.getAttribute('up-fail-target')) != null ? ref2 : e.toSelector(form);\n      }\n      if (options.reveal == null) {\n        options.reveal = (ref3 = e.booleanOrStringAttr(form, 'up-reveal')) != null ? ref3 : true;\n      }\n      if (options.failReveal == null) {\n        options.failReveal = (ref4 = e.booleanOrStringAttr(form, 'up-fail-reveal')) != null ? ref4 : true;\n      }\n      if (options.fallback == null) {\n        options.fallback = form.getAttribute('up-fallback');\n      }\n      if (options.history == null) {\n        options.history = (ref5 = e.booleanOrStringAttr(form, 'up-history')) != null ? ref5 : true;\n      }\n      if (options.transition == null) {\n        options.transition = e.booleanOrStringAttr(form, 'up-transition');\n      }\n      if (options.failTransition == null) {\n        options.failTransition = e.booleanOrStringAttr(form, 'up-fail-transition');\n      }\n      if (options.method == null) {\n        options.method = u.normalizeMethod((ref6 = (ref7 = (ref8 = form.getAttribute('up-method')) != null ? ref8 : form.getAttribute('data-method')) != null ? ref7 : form.getAttribute('method')) != null ? ref6 : 'post');\n      }\n      if (options.cache == null) {\n        options.cache = e.booleanAttr(form, 'up-cache');\n      }\n      if (options.restoreScroll == null) {\n        options.restoreScroll = e.booleanAttr(form, 'up-restore-scroll');\n      }\n      if (options.origin == null) {\n        options.origin = form;\n      }\n      if (options.layer == null) {\n        options.layer = form.getAttribute('up-layer');\n      }\n      if (options.failLayer == null) {\n        options.failLayer = form.getAttribute('up-fail-layer');\n      }\n      options.params = up.Params.fromForm(form).addAll(options.params);\n      options = u.merge(options, up.motion.animateOptions(options, form));\n      if (options.validate) {\n        options.headers || (options.headers = {});\n        options.transition = false;\n        options.failTransition = false;\n        options.headers[up.protocol.config.validateHeader] = options.validate;\n      }\n      url = (ref9 = (ref10 = options.url) != null ? ref10 : form.getAttribute('action')) != null ? ref9 : up.browser.url();\n      if (options.method === 'GET') {\n        url = up.Params.stripURL(url);\n      }\n      return up.event.whenEmitted('up:form:submit', {\n        log: 'Submitting form',\n        target: form\n      }).then(function() {\n        var promise;\n        up.feedback.start(form);\n        if (!(up.browser.canPushState() || options.history === false)) {\n          form.submit();\n          return u.unresolvablePromise();\n        }\n        promise = up.replace(target, url, options);\n        u.always(promise, function() {\n          return up.feedback.stop(form);\n        });\n        return promise;\n      });\n    };\n\n    /***\n    This event is [emitted](/up.emit) when a form is [submitted](/up.submit) through Unpoly.\n    \n    The event is emitted on the`<form>` element.\n    \n    @event up:form:submit\n    @param {Element} event.target\n      The `<form>` element that will be submitted.\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the form from being submitted.\n    @stable\n     */\n\n    /***\n    Observes form fields and runs a callback when a value changes.\n    \n    This is useful for observing text fields while the user is typing.\n    \n    The unobtrusive variant of this is the [`[up-observe]`](/up-observe) attribute.\n    \n    \\#\\#\\# Example\n    \n    The following would print to the console whenever an input field changes:\n    \n        up.observe('input.query', function(value) {\n          console.log('Query is now %o', value)\n        })\n    \n    Instead of a single form field, you can also pass multiple fields,\n    a `<form>` or any container that contains form fields.\n    The callback will be run if any of the given fields change:\n    \n        up.observe('form', function(value, name) {\n          console.log('The value of %o is now %o', name, value)\n        })\n    \n    You may also pass the `{ batch: true }` option to receive all\n    changes since the last callback in a single object:\n    \n        up.observe('form', { batch: true }, function(diff) {\n          console.log('Observed one or more changes: %o', diff)\n        })\n    \n    @function up.observe\n    @param {string|Element|Array<Element>|jQuery} elements\n      The form fields that will be observed.\n    \n      You can pass one or more fields, a `<form>` or any container that contains form fields.\n      The callback will be run if any of the given fields change.\n    @param {boolean} [options.batch=false]\n      If set to `true`, the `onChange` callback will receive multiple\n      detected changes in a single diff object as its argument.\n    @param {number} [options.delay=up.form.config.observeDelay]\n      The number of miliseconds to wait before executing the callback\n      after the input value changes. Use this to limit how often the callback\n      will be invoked for a fast typist.\n    @param {Function(value, name): string} onChange\n      The callback to run when the field's value changes.\n    \n      If given as a function, it receives two arguments (`value`, `name`).\n      `value` is a string with the new attribute value and `string` is the name\n      of the form field that changed.\n    \n      If given as a string, it will be evaled as JavaScript code in a context where\n      (`value`, `name`) are set.\n    @return {Function()}\n      A destructor function that removes the observe watch when called.\n    @stable\n     */\n    observe = function() {\n      var args, callback, elements, fields, observer, options, ref, ref1, ref2, ref3;\n      elements = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n      elements = e.list(elements);\n      fields = u.flatMap(elements, findFields);\n      callback = (ref = (ref1 = u.extractCallback(args)) != null ? ref1 : observeCallbackFromElement(elements[0])) != null ? ref : up.fail('up.observe: No change callback given');\n      options = u.extractOptions(args);\n      options.delay = (ref2 = (ref3 = options.delay) != null ? ref3 : e.numberAttr(elements[0], 'up-delay')) != null ? ref2 : config.observeDelay;\n      observer = new up.FieldObserver(fields, options, callback);\n      observer.start();\n      return observer.stop;\n    };\n    observeCallbackFromElement = function(element) {\n      var rawCallback;\n      if (rawCallback = element.getAttribute('up-observe')) {\n        return new Function('value', 'name', rawCallback);\n      }\n    };\n\n    /***\n    [Observes](/up.observe) a field or form and submits the form when a value changes.\n    \n    Both the form and the changed field will be assigned a CSS class [`form-up-active`](/form-up-active)\n    while the autosubmitted form is processing.\n    \n    The unobtrusive variant of this is the [`up-autosubmit`](/form-up-autosubmit) attribute.\n    \n    @function up.autosubmit\n    @param {string|Element|jQuery} selectorOrElement\n      The field or form to observe.\n    @param {Object} [options]\n      See options for [`up.observe()`](/up.observe)\n    @return {Function()}\n      A destructor function that removes the observe watch when called.\n    @stable\n     */\n    autosubmit = function(selectorOrElement, options) {\n      return observe(selectorOrElement, options, function() {\n        return submit(selectorOrElement);\n      });\n    };\n    findValidateTarget = function(field, options) {\n      var option, ref;\n      option = (ref = options.target) != null ? ref : field.getAttribute('up-validate');\n      option || (option = u.findResult(config.validateTargets, function(defaultTarget) {\n        var resolvedDefault;\n        resolvedDefault = e.resolveSelector(defaultTarget, options.origin);\n        if (e.first(resolvedDefault)) {\n          return resolvedDefault;\n        }\n      }));\n      if (!option) {\n        up.fail('Could not find validation target for %o (tried defaults %o)', field, config.validateTargets);\n      }\n      return e.resolveSelector(option, options.origin);\n    };\n\n    /***\n    Performs a server-side validation of a form field.\n    \n    `up.validate()` submits the given field's form with an additional `X-Up-Validate`\n    HTTP header. Upon seeing this header, the server is expected to validate (but not save)\n    the form submission and render a new copy of the form with validation errors.\n    \n    The unobtrusive variant of this is the [`input[up-validate]`](/input-up-validate) selector.\n    See the documentation for [`input[up-validate]`](/input-up-validate) for more information\n    on how server-side validation works in Unpoly.\n    \n    \\#\\#\\# Example\n    \n        up.validate('input[name=email]', { target: '.email-errors' })\n    \n    @function up.validate\n    @param {string|Element|jQuery} fieldOrSelector\n    \n    @param {string|Element|jQuery} [options.target]\n    @return {Promise}\n      A promise that is fulfilled when the server-side\n      validation is received and the form was updated.\n    @stable\n     */\n    validate = function(fieldOrSelector, options) {\n      var field, promise, ref;\n      field = e.get(fieldOrSelector);\n      options = u.options(options);\n      options.origin = field;\n      options.target = findValidateTarget(field, options);\n      options.failTarget = options.target;\n      if (options.reveal == null) {\n        options.reveal = (ref = e.booleanOrStringAttr(field, 'up-reveal')) != null ? ref : false;\n      }\n      options.history = false;\n      options.validate = field.getAttribute('name') || ':none';\n      options = u.merge(options, up.motion.animateOptions(options, field));\n      promise = up.submit(field, options);\n      return promise;\n    };\n    switcherValues = function(field) {\n      var checkedButton, form, groupName, meta, value, values;\n      value = void 0;\n      meta = void 0;\n      if (e.matches(field, 'input[type=checkbox]')) {\n        if (field.checked) {\n          value = field.value;\n          meta = ':checked';\n        } else {\n          meta = ':unchecked';\n        }\n      } else if (e.matches(field, 'input[type=radio]')) {\n        form = closestContainer(field);\n        groupName = field.getAttribute('name');\n        checkedButton = form.querySelector(\"input[type=radio]\" + (e.attributeSelector('name', groupName)) + \":checked\");\n        if (checkedButton) {\n          meta = ':checked';\n          value = checkedButton.value;\n        } else {\n          meta = ':unchecked';\n        }\n      } else {\n        value = field.value;\n      }\n      values = [];\n      if (u.isPresent(value)) {\n        values.push(value);\n        values.push(':present');\n      } else {\n        values.push(':blank');\n      }\n      if (u.isPresent(meta)) {\n        values.push(meta);\n      }\n      return values;\n    };\n\n    /***\n    Shows or hides a target selector depending on the value.\n    \n    See [`input[up-switch]`](/input-up-switch) for more documentation and examples.\n    \n    This function does not currently have a very useful API outside\n    of our use for `up-switch`'s UJS behavior, that's why it's currently\n    still marked `@internal`.\n    \n    @function up.form.switchTargets\n    @param {Element} switcher\n    @param {string} [options.target]\n      The target selectors to switch.\n      Defaults to an `[up-switch]` attribute on the given field.\n    @internal\n     */\n    switchTargets = function(switcher, options) {\n      var fieldValues, form, ref, targetSelector;\n      if (options == null) {\n        options = {};\n      }\n      targetSelector = (ref = options.target) != null ? ref : switcher.getAttribute('up-switch');\n      form = closestContainer(switcher);\n      u.isPresent(targetSelector) || up.fail(\"No switch target given for %o\", switcher);\n      fieldValues = switcherValues(switcher);\n      return u.each(e.all(form, targetSelector), function(target) {\n        return switchTarget(target, fieldValues);\n      });\n    };\n\n    /***\n    @internal\n     */\n    switchTarget = function(target, fieldValues) {\n      var hideValues, show, showValues;\n      fieldValues || (fieldValues = switcherValues(findSwitcherForTarget(target)));\n      if (hideValues = target.getAttribute('up-hide-for')) {\n        hideValues = u.splitValues(hideValues);\n        show = u.intersect(fieldValues, hideValues).length === 0;\n      } else {\n        if (showValues = target.getAttribute('up-show-for')) {\n          showValues = u.splitValues(showValues);\n        } else {\n          showValues = [':present', ':checked'];\n        }\n        show = u.intersect(fieldValues, showValues).length > 0;\n      }\n      e.toggle(target, show);\n      return target.classList.add('up-switched');\n    };\n\n    /***\n    @internal\n     */\n    findSwitcherForTarget = function(target) {\n      var form, switcher, switchers;\n      form = closestContainer(target);\n      switchers = e.all(form, '[up-switch]');\n      switcher = u.find(switchers, function(switcher) {\n        var targetSelector;\n        targetSelector = switcher.getAttribute('up-switch');\n        return e.matches(target, targetSelector);\n      });\n      return switcher || u.fail('Could not find [up-switch] field for %o', target);\n    };\n    closestContainer = function(element) {\n      return e.closest(element, 'form, body');\n    };\n\n    /***\n    Forms with an `up-target` attribute are [submitted via AJAX](/up.submit)\n    instead of triggering a full page reload.\n    \n        <form method=\"post\" action=\"/users\" up-target=\".main\">\n          ...\n        </form>\n    \n    The server response is searched for the selector given in `up-target`.\n    The selector content is then [replaced](/up.replace) in the current page.\n    \n    The programmatic variant of this is the [`up.submit()`](/up.submit) function.\n    \n    \\#\\#\\# Failed submission\n    \n    When the server was unable to save the form due to invalid params,\n    it will usually re-render an updated copy of the form with\n    validation messages.\n    \n    For Unpoly to be able to detect a failed form submission,\n    the form must be re-rendered with a non-200 HTTP status code.\n    We recommend to use either 400 (bad request) or\n    422 (unprocessable entity).\n    \n    In Ruby on Rails, you can pass a\n    [`:status` option to `render`](http://guides.rubyonrails.org/layouts_and_rendering.html#the-status-option)\n    for this:\n    \n        class UsersController < ApplicationController\n    \n          def create\n            user_params = params[:user].permit(:email, :password)\n            @user = User.new(user_params)\n            if @user.save?\n              sign_in @user\n            else\n              render 'form', status: :bad_request\n            end\n          end\n    \n        end\n    \n    Note that you can also use\n    [`input[up-validate]`](/input-up-validate) to perform server-side\n    validations while the user is completing fields.\n    \n    \\#\\#\\# Redirects\n    \n    Unpoly requires an additional response header to detect redirects,\n    which are otherwise undetectable for an AJAX client.\n    \n    After the form's action performs a redirect, the next response should echo\n    the new request's URL as a response header `X-Up-Location`.\n    \n    If you are using Unpoly via the `unpoly-rails` gem, these headers\n    are set automatically for every request.\n    \n    \\#\\#\\# Giving feedback while the form is processing\n    \n    The `<form>` element will be assigned a CSS class [`up-active`](/form.up-active) while\n    the submission is loading.\n    \n    You can also [implement a spinner](/up.proxy/#spinners)\n    by [listening](/up.on) to the [`up:proxy:slow`](/up:proxy:slow)\n    and [`up:proxy:recover`](/up:proxy:recover) events.\n    \n    @selector form[up-target]\n    @param {string} up-target\n      The CSS selector to [replace](/up.replace) if the form submission is successful (200 status code).\n    \n      Inside the CSS selector you may refer to this form as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-fail-target]\n      The CSS selector to [replace](/up.replace) if the form submission is not successful (non-200 status code).\n    \n      Inside the CSS selector you may refer to this form as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    \n      If omitted, Unpoly will replace the `<form>` tag itself, assuming that the server has echoed the form with validation errors.\n    @param [up-fallback]\n      The selector to replace if the server responds with an error.\n    @param {string} [up-transition]\n      The animation to use when the form is replaced after a successful submission.\n    @param {string} [up-fail-transition]\n      The animation to use when the form is replaced after a failed submission.\n    @param [up-history]\n      Whether to push a browser history entry after a successful form submission.\n    \n      By default the form's target URL is used. If the form redirects to another URL,\n      the redirect target will be used.\n    \n      Set this to `'false'` to prevent the URL bar from being updated.\n      Set this to a URL string to update the history with the given URL.\n    @param {string} [up-method]\n      The HTTP method to be used to submit the form (`get`, `post`, `put`, `delete`, `patch`).\n      Alternately you can use an attribute `data-method`\n      ([Rails UJS](https://github.com/rails/jquery-ujs/wiki/Unobtrusive-scripting-support-for-jQuery))\n      or `method` (vanilla HTML) for the same purpose.\n    @param {string} [up-layer='auto']\n      The name of the layer that ought to be updated. Valid values are\n      `'auto'`, `'page'`, `'modal'` and `'popup'`.\n    \n      If set to `'auto'` (default), Unpoly will try to find a match in the form's layer.\n      If no match was found in that layer,\n      Unpoly will search in other layers, starting from the topmost layer.\n    @param {string} [up-fail-layer='auto']\n      The name of the layer that ought to be updated if the server sends a\n      non-200 status code.\n    @param {string} [up-reveal='true']\n      Whether to reveal the target element after it was replaced.\n    \n      You can also pass a CSS selector for the element to reveal.\n      Inside the CSS selector you may refer to the form as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-fail-reveal='true']\n      Whether to reveal the target element when the server responds with an error.\n    \n      You can also pass a CSS selector for the element to reveal. You may use this, for example,\n      to reveal the first validation error message:\n    \n          <form up-target=\".content\" up-fail-reveal=\".error\">\n            ...\n          </form>\n    \n      Inside the CSS selector you may refer to the form as `&` ([like in Sass](https://sass-lang.com/documentation/file.SASS_REFERENCE.html#parent-selector)).\n    @param {string} [up-restore-scroll='false']\n      Whether to restore previously known scroll position of all viewports\n      within the target selector.\n    @param {string} [up-cache]\n      Whether to force the use of a cached response (`true`)\n      or never use the cache (`false`)\n      or make an educated guess (`undefined`).\n    \n      By default only responses to `GET` requests are cached for a few minutes.\n    @stable\n     */\n    up.on('submit', 'form[up-target]', function(event, form) {\n      up.event.consumeAction(event);\n      return u.muteRejection(submit(form));\n    });\n\n    /***\n    When a form field with this attribute is changed, the form is validated on the server\n    and is updated with validation messages.\n    \n    To validate the form, Unpoly will submit the form with an additional `X-Up-Validate` HTTP header.\n    When seeing this header, the server is expected to validate (but not save)\n    the form submission and render a new copy of the form with validation errors.\n    \n    The programmatic variant of this is the [`up.validate()`](/up.validate) function.\n    \n    \\#\\#\\# Example\n    \n    Let's look at a standard registration form that asks for an e-mail and password:\n    \n        <form action=\"/users\">\n    \n          <label>\n            E-mail: <input type=\"text\" name=\"email\" />\n          </label>\n    \n          <label>\n            Password: <input type=\"password\" name=\"password\" />\n          </label>\n    \n          <button type=\"submit\">Register</button>\n    \n        </form>\n    \n    When the user changes the `email` field, we want to validate that\n    the e-mail address is valid and still available. Also we want to\n    change the `password` field for the minimum required password length.\n    We can do this by giving both fields an `up-validate` attribute:\n    \n        <form action=\"/users\">\n    \n          <label>\n            E-mail: <input type=\"text\" name=\"email\" up-validate />\n          </label>\n    \n          <label>\n            Password: <input type=\"password\" name=\"password\" up-validate />\n          </label>\n    \n          <button type=\"submit\">Register</button>\n    \n        </form>\n    \n    Whenever a field with `up-validate` changes, the form is POSTed to\n    `/users` with an additional `X-Up-Validate` HTTP header.\n    When seeing this header, the server is expected to validate (but not save)\n    the form submission and render a new copy of the form with validation errors.\n    \n    In Ruby on Rails the processing action should behave like this:\n    \n        class UsersController < ApplicationController\n    \n           * This action handles POST /users\n          def create\n            user_params = params[:user].permit(:email, :password)\n            @user = User.new(user_params)\n            if request.headers['X-Up-Validate']\n              @user.valid?  # run validations, but don't save to the database\n              render 'form' # render form with error messages\n            elsif @user.save?\n              sign_in @user\n            else\n              render 'form', status: :bad_request\n            end\n          end\n    \n        end\n    \n    Note that if you're using the `unpoly-rails` gem you can simply say `up.validate?`\n    instead of manually checking for `request.headers['X-Up-Validate']`.\n    \n    The server now renders an updated copy of the form with eventual validation errors:\n    \n        <form action=\"/users\">\n    \n          <label class=\"has-error\">\n            E-mail: <input type=\"text\" name=\"email\" value=\"foo@bar.com\" />\n            Has already been taken!\n          </label>\n    \n          <button type=\"submit\">Register</button>\n    \n        </form>\n    \n    The `<label>` around the e-mail field is now updated to have the `has-error`\n    class and display the validation message.\n    \n    \\#\\#\\# How validation results are displayed\n    \n    Although the server will usually respond to a validation with a complete,\n    fresh copy of the form, Unpoly will by default not update the entire form.\n    This is done in order to preserve volatile state such as the scroll position\n    of `<textarea>` elements.\n    \n    By default Unpoly looks for a `<fieldset>`, `<label>` or `<form>`\n    around the validating input field, or any element with an\n    `up-fieldset` attribute.\n    With the Bootstrap bindings, Unpoly will also look\n    for a container with the `form-group` class.\n    \n    You can change this default behavior by setting [`up.form.config.validateTargets`](/up.form.config#config.validateTargets):\n    \n        // Always update the entire form containing the current field (\"&\")\n        up.form.config.validateTargets = ['form &']\n    \n    You can also individually override what to update by setting the `up-validate`\n    attribute to a CSS selector:\n    \n        <input type=\"text\" name=\"email\" up-validate=\".email-errors\">\n        <span class=\"email-errors\"></span>\n    \n    \\#\\#\\# Updating dependent fields\n    \n    The `[up-validate]` behavior is also a great way to partially update a form\n    when one fields depends on the value of another field.\n    \n    Let's say you have a form with one `<select>` to pick a department (sales, engineering, ...)\n    and another `<select>` to pick an employeee from the selected department:\n    \n        <form action=\"/contracts\">\n          <select name=\"department\">...</select> <!-- options for all departments -->\n          <select name=\"employeed\">...</select> <!-- options for employees of selected department -->\n        </form>\n    \n    The list of employees needs to be updated as the appartment changes:\n    \n        <form action=\"/contracts\">\n          <select name=\"department\" up-validate=\"[name=employee]\">...</select>\n          <select name=\"employee\">...</select>\n        </form>\n    \n    In order to update the `department` field in addition to the `employee` field, you could say\n    `up-validate=\"&, [name=employee]\"`, or simply `up-validate=\"form\"` to update the entire form.\n    \n    @selector input[up-validate]\n    @param {string} up-validate\n      The CSS selector to update with the server response.\n    \n      This defaults to a fieldset or form group around the validating field.\n    @stable\n     */\n\n    /***\n    Performs [server-side validation](/input-up-validate) when any fieldset within this form changes.\n    \n    You can configure what Unpoly considers a fieldset by adding CSS selectors to the\n    [`up.form.config.validateTargets`](/up.form.config#config.validateTargets) array.\n    \n    @selector form[up-validate]\n    @stable\n     */\n    up.on('change', '[up-validate]', function(event) {\n      var field;\n      field = findFields(event.target)[0];\n      return u.muteRejection(validate(field));\n    });\n\n    /***\n    Show or hide elements when a `<select>` or `<input>` has a given value.\n    \n    \\#\\#\\# Example: Select options\n    \n    The controlling form field gets an `up-switch` attribute with a selector for the elements to show or hide:\n    \n        <select name=\"advancedness\" up-switch=\".target\">\n          <option value=\"basic\">Basic parts</option>\n          <option value=\"advanced\">Advanced parts</option>\n          <option value=\"very-advanced\">Very advanced parts</option>\n        </select>\n    \n    The target elements can use [`[up-show-for]`](/up-show-for) and [`[up-hide-for]`](/up-hide-for)\n    attributes to indicate for which values they should be shown or hidden:\n    \n        <div class=\"target\" up-show-for=\"basic\">\n          only shown for advancedness = basic\n        </div>\n    \n        <div class=\"target\" up-hide-for=\"basic\">\n          hidden for advancedness = basic\n        </div>\n    \n        <div class=\"target\" up-show-for=\"advanced very-advanced\">\n          shown for advancedness = advanced or very-advanced\n        </div>\n    \n    \\#\\#\\# Example: Text field\n    \n    The controlling `<input>` gets an `up-switch` attribute with a selector for the elements to show or hide:\n    \n        <input type=\"text\" name=\"user\" up-switch=\".target\">\n    \n        <div class=\"target\" up-show-for=\"alice\">\n          only shown for user alice\n        </div>\n    \n    You can also use the pseudo-values `:blank` to match an empty input value,\n    or `:present` to match a non-empty input value:\n    \n        <input type=\"text\" name=\"user\" up-switch=\".target\">\n    \n        <div class=\"target\" up-show-for=\":blank\">\n          please enter a username\n        </div>\n    \n    \\#\\#\\# Example: Checkbox\n    \n    For checkboxes you can match against the pseudo-values `:checked` or `:unchecked`:\n    \n        <input type=\"checkbox\" name=\"flag\" up-switch=\".target\">\n    \n        <div class=\"target\" up-show-for=\":checked\">\n          only shown when checkbox is checked\n        </div>\n    \n        <div class=\"target\" up-show-for=\":cunhecked\">\n          only shown when checkbox is unchecked\n        </div>\n    \n    Of course you can also match against the `value` property of the checkbox element:\n    \n        <input type=\"checkbox\" name=\"flag\" value=\"active\" up-switch=\".target\">\n    \n        <div class=\"target\" up-show-for=\"active\">\n          only shown when checkbox is checked\n        </div>\n    \n    @selector input[up-switch]\n    @param {string} up-switch\n      A CSS selector for elements whose visibility depends on this field's value.\n    @stable\n     */\n\n    /***\n    Only shows this element if an input field with [`[up-switch]`](/input-up-switch) has one of the given values.\n    \n    See [`input[up-switch]`](/input-up-switch) for more documentation and examples.\n    \n    @selector [up-show-for]\n    @param {string} [up-show-for]\n      A space-separated list of input values for which this element should be shown.\n    @stable\n     */\n\n    /***\n    Hides this element if an input field with [`[up-switch]`](/input-up-switch) has one of the given values.\n    \n    See [`input[up-switch]`](/input-up-switch) for more documentation and examples.\n    \n    @selector [up-hide-for]\n    @param {string} [up-hide-for]\n      A space-separated list of input values for which this element should be hidden.\n    @stable\n     */\n    up.compiler('[up-switch]', function(switcher) {\n      return switchTargets(switcher);\n    });\n    up.on('change', '[up-switch]', function(event, switcher) {\n      return switchTargets(switcher);\n    });\n    up.compiler('[up-show-for]:not(.up-switched), [up-hide-for]:not(.up-switched)', function(element) {\n      return switchTarget(element);\n    });\n\n    /***\n    Observes this field and runs a callback when a value changes.\n    \n    This is useful for observing text fields while the user is typing.\n    If you want to submit the form after a change see [`input[up-autosubmit]`](/input-up-autosubmit).\n    \n    The programmatic variant of this is the [`up.observe()`](/up.observe) function.\n    \n    \\#\\#\\# Example\n    \n    The following would run a global `showSuggestions(value)` function\n    whenever the `<input>` changes:\n    \n        <input name=\"query\" up-observe=\"showSuggestions(value)\">\n    \n    \\#\\#\\# Callback context\n    \n    The script given to `[up-observe]` runs with the following context:\n    \n    | Name     | Type      | Description                           |\n    | -------- | --------- | ------------------------------------- |\n    | `value`  | `string`  | The current value of the field        |\n    | `this`   | `Element` | The form field                        |\n    | `$field` | `jQuery`  | The form field as a jQuery collection |\n    \n    \\#\\#\\# Observing radio buttons\n    \n    Multiple radio buttons with the same `[name]` (a radio button group)\n    produce a single value for the form.\n    \n    To observe radio buttons group, use the `[up-observe]` attribute on an\n    element that contains all radio button elements with a given name:\n    \n        <div up-observe=\"formatSelected(value)\">\n          <input type=\"radio\" name=\"format\" value=\"html\"> HTML format\n          <input type=\"radio\" name=\"format\" value=\"pdf\"> PDF format\n          <input type=\"radio\" name=\"format\" value=\"txt\"> Text format\n        </div>\n    \n    @selector input[up-observe]\n    @param {string} up-observe\n      The code to run when the field's value changes.\n    @param {string} up-delay\n      The number of miliseconds to wait after a change before the code is run.\n    @stable\n     */\n\n    /***\n    Observes this form and runs a callback when any field changes.\n    \n    This is useful for observing text fields while the user is typing.\n    If you want to submit the form after a change see [`input[up-autosubmit]`](/input-up-autosubmit).\n    \n    The programmatic variant of this is the [`up.observe()`](/up.observe) function.\n    \n    \\#\\#\\# Example\n    \n    The would call a function `somethingChanged(value)`\n    when any `<input>` within the `<form>` changes:\n    \n        <form up-observe=\"somethingChanged(value)\">\n          <input name=\"foo\">\n          <input name=\"bar\">\n        </form>\n    \n    \\#\\#\\# Callback context\n    \n    The script given to `up-observe` runs with the following context:\n    \n    | Name     | Type      | Description                           |\n    | -------- | --------- | ------------------------------------- |\n    | `value`  | `string`  | The current value of the field        |\n    | `this`   | `Element` | The form field                        |\n    | `$field` | `jQuery`  | The form field as a jQuery collection |\n    \n    @selector form[up-observe]\n    @param {string} up-observe\n      The code to run when any field's value changes.\n    @param {string} up-delay\n      The number of miliseconds to wait after a change before the code is run.\n    @stable\n     */\n    up.compiler('[up-observe]', function(formOrField) {\n      return observe(formOrField);\n    });\n\n    /***\n    Submits this field's form when this field changes its values.\n    \n    Both the form and the changed field will be assigned a CSS class [`up-active`](/form-up-active)\n    while the autosubmitted form is loading.\n    \n    The programmatic variant of this is the [`up.autosubmit()`](/up.autosubmit) function.\n    \n    \\#\\#\\# Example\n    \n    The following would automatically submit the form when the query is changed:\n    \n        <form method=\"GET\" action=\"/search\">\n          <input type=\"search\" name=\"query\" up-autosubmit>\n          <input type=\"checkbox\" name=\"archive\"> Include archive\n        </form>\n    \n    \\#\\#\\# Auto-submitting radio buttons\n    \n    Multiple radio buttons with the same `[name]` (a radio button group)\n    produce a single value for the form.\n    \n    To auto-submit radio buttons group, use the `[up-submit]` attribute on an\n    element that contains all radio button elements with a given name:\n    \n        <div up-autosubmit>\n          <input type=\"radio\" name=\"format\" value=\"html\"> HTML format\n          <input type=\"radio\" name=\"format\" value=\"pdf\"> PDF format\n          <input type=\"radio\" name=\"format\" value=\"txt\"> Text format\n        </div>\n    \n    @selector input[up-autosubmit]\n    @param {string} up-delay\n      The number of miliseconds to wait after a change before the form is submitted.\n    @stable\n     */\n\n    /***\n    Submits the form when *any* field changes.\n    \n    Both the form and the field will be assigned a CSS class [`up-active`](/form-up-active)\n    while the autosubmitted form is loading.\n    \n    The programmatic variant of this is the [`up.autosubmit()`](/up.autosubmit) function.\n    \n    \\#\\#\\# Example\n    \n    This will submit the form when either query or checkbox was changed:\n    \n        <form method=\"GET\" action=\"/search\" up-autosubmit>\n          <input type=\"search\" name=\"query\">\n          <input type=\"checkbox\" name=\"archive\"> Include archive\n        </form>\n    \n    @selector form[up-autosubmit]\n    @param {string} up-delay\n      The number of miliseconds to wait after a change before the form is submitted.\n    @stable\n     */\n    up.compiler('[up-autosubmit]', function(formOrField) {\n      return autosubmit(formOrField);\n    });\n    up.compiler('[autofocus]', {\n      batch: true\n    }, function(inputs) {\n      return u.last(inputs).focus();\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      config: config,\n      submit: submit,\n      observe: observe,\n      validate: validate,\n      autosubmit: autosubmit,\n      fieldSelector: fieldSelector,\n      fields: findFields,\n      submissionFields: findSubmissionFields\n    };\n  })();\n\n  up.submit = up.form.submit;\n\n  up.observe = up.form.observe;\n\n  up.autosubmit = up.form.autosubmit;\n\n  up.validate = up.form.validate;\n\n}).call(this);\n\n/***\nPop-up overlays\n===============\n\nInstead of [linking to a page fragment](/up.link), you can choose\nto show a fragment in a popup overlay that rolls down from an anchoring element.\n\nTo open a popup, add an [`up-popup` attribute](/a-up-popup) to a link:\n\n    <a href=\"/options\" up-popup=\".menu\">Show options</a>\n\nWhen this link is clicked, Unpoly will request the path `/options` and extract\nan element matching the selector `.menu` from the response. The matching element\nwill then be placed in the popup overlay.\n\n\n\\#\\#\\# Closing behavior\n\nThe popup closes when the user clicks anywhere outside the popup area.\n\nThe popup also closes *when a link within the popup changes a fragment behind the popup*.\nThis is useful to have the popup interact with the page that\nopened it, e.g. by updating parts of a larger form.\n\nTo disable this behavior, give the opening link an [`up-sticky`](/a-up-popup#up-sticky) attribute.\n\n\n\\#\\#\\# Customizing the popup design\n\nPopups have a minimal default design:\n\n- Popup contents are displayed in a white box\n- There is a a subtle box shadow around the popup\n- The box will grow to fit the popup contents\n\nThe easiest way to change how the popup looks is to override the\n[default CSS styles](https://github.com/unpoly/unpoly/blob/master/lib/assets/stylesheets/unpoly/popup.sass).\n\nThe HTML of a popup element looks like this:\n\n    <div class=\"up-popup\">\n      <div class=\"up-popup-content\">\n        Fragment content here\n      </div>\n    </div>\n\nThe popup element is appended to the [viewport](/up.viewport) of the anchor element.\n\n@module up.popup\n */\n\n(function() {\n  up.popup = (function() {\n    var attachAsap, attachNow, autoclose, chain, closeAsap, closeNow, config, contains, createHiddenFrame, discardHistory, e, isOpen, preloadNow, reset, state, syncPosition, toggleAsap, u, unveilFrame;\n    u = up.util;\n    e = up.element;\n\n    /***\n    Sets default options for future popups.\n    \n    @property up.popup.config\n    @param {string} [config.position='bottom']\n      Defines on which side of the opening element the popup is attached.\n    \n      Valid values are `'top'`, `'right'`, `'bottom'` and `'left'`.\n    @param {string} [config.align='left']\n      Defines the alignment of the popup along its side.\n    \n      When the popup's `{ position }` is `'top'` or `'bottom'`, valid `{ align }` values are `'left'`, `center'` and `'right'`.\n      When the popup's `{ position }` is `'left'` or `'right'`, valid `{ align }` values are `top'`, `center'` and `bottom'`.\n    @param {string} [config.history=false]\n      Whether opening a popup will add a browser history entry.\n    @param {string} [config.openAnimation='fade-in']\n      The animation used to open a popup.\n    @param {string} [config.closeAnimation='fade-out']\n      The animation used to close a popup.\n    @param {string} [config.openDuration]\n      The duration of the open animation (in milliseconds).\n    @param {string} [config.closeDuration]\n      The duration of the close animation (in milliseconds).\n    @param {string} [config.openEasing]\n      The timing function controlling the acceleration of the opening animation.\n    @param {string} [config.closeEasing]\n      The timing function controlling the acceleration of the closing animation.\n    @param {boolean} [options.sticky=false]\n      If set to `true`, the popup remains\n      open even it changes the page in the background.\n    @stable\n     */\n    config = new up.Config({\n      openAnimation: 'fade-in',\n      closeAnimation: 'fade-out',\n      openDuration: 150,\n      closeDuration: 100,\n      openEasing: null,\n      closeEasing: null,\n      position: 'bottom',\n      align: 'left',\n      history: false\n    });\n\n    /***\n    Returns the URL from which the current popup's contents were loaded.\n    \n    Returns `undefined` if no  popup is open.\n    \n    @function up.popup.url\n    @return {string}\n      the source URL\n    @stable\n     */\n\n    /***\n    Returns the URL of the page or modal behind the popup.\n    \n    @function up.popup.coveredUrl\n    @return {string}\n    @experimental\n     */\n    state = new up.Config({\n      phase: 'closed',\n      anchor: null,\n      popup: null,\n      content: null,\n      tether: null,\n      position: null,\n      align: null,\n      sticky: null,\n      url: null,\n      coveredUrl: null,\n      coveredTitle: null\n    });\n    chain = new up.DivertibleChain();\n    reset = function() {\n      var ref;\n      if ((ref = state.tether) != null) {\n        ref.destroy();\n      }\n      state.reset();\n      chain.reset();\n      return config.reset();\n    };\n    discardHistory = function() {\n      state.coveredTitle = null;\n      return state.coveredUrl = null;\n    };\n    createHiddenFrame = function(targetSelector) {\n      state.tether = new up.Tether(u.only(state, 'anchor', 'position', 'align'));\n      state.popup = e.affix(state.tether.root, '.up-popup', {\n        'up-position': state.position,\n        'up-align': state.align\n      });\n      state.content = e.affix(state.popup, '.up-popup-content');\n      up.fragment.createPlaceholder(targetSelector, state.content);\n      return e.hide(state.popup);\n    };\n    unveilFrame = function() {\n      return e.show(state.popup);\n    };\n\n    /***\n    Forces the popup to update its position relative to its anchor element.\n    \n    Unpoly automatically keep popups aligned when\n    the document is resized or scrolled. Complex layout changes may make\n    it necessary to call this function.\n    \n    @function up.popup.sync\n    @experimental\n     */\n    syncPosition = function() {\n      var ref;\n      return (ref = state.tether) != null ? ref.sync() : void 0;\n    };\n\n    /***\n    Returns whether popup modal is currently open.\n    \n    @function up.popup.isOpen\n    @return {boolean}\n    @stable\n     */\n    isOpen = function() {\n      return state.phase === 'opened' || state.phase === 'opening';\n    };\n\n    /***\n    Attaches a popup overlay to the given element or selector.\n    \n    Emits events [`up:popup:open`](/up:popup:open) and [`up:popup:opened`](/up:popup:opened).\n    \n    @function up.popup.attach\n    @param {Element|jQuery|string} anchor\n      The element to which the popup will be attached.\n    @param {string} [options.url]\n      The URL from which to fetch the popup contents.\n    \n      If omitted, the `href` or `up-href` attribute of the anchor element will be used.\n    \n      Will be ignored if `options.html` is given.\n    @param {string} [options.target]\n      A CSS selector that will be extracted from the response and placed into the popup.\n    @param {string} [options.position='bottom']\n      Defines on which side of the opening element the popup is attached.\n    \n      Valid values are `'top'`, `'right'`, `'bottom'` and `'left'`.\n    @param {string} [options.align='left']\n      Defines the alignment of the popup along its side.\n    \n      When the popup's `{ position }` is `'top'` or `'bottom'`, valid `{ align }` values are `'left'`, `center'` and `'right'`.\n      When the popup's `{ position }` is `'left'` or `'right'`, valid `{ align }` values are `top'`, `center'` and `bottom'`.\n    @param {string} [options.html]\n      A string of HTML from which to extract the popup contents. No network request will be made.\n    @param {string} [options.confirm]\n      A message that will be displayed in a cancelable confirmation dialog\n      before the modal is being opened.\n    @param {string} [options.animation]\n      The animation to use when opening the popup.\n    @param {number} [options.duration]\n      The duration of the animation. See [`up.animate()`](/up.animate).\n    @param {number} [options.delay]\n      The delay before the animation starts. See [`up.animate()`](/up.animate).\n    @param {string} [options.easing]\n      The timing function that controls the animation's acceleration. [`up.animate()`](/up.animate).\n    @param {string} [options.method=\"GET\"]\n      Override the request method.\n    @param {boolean} [options.sticky=false]\n      If set to `true`, the popup remains\n      open even if the page changes in the background.\n    @param {boolean} [options.history=false]\n    @return {Promise}\n      A promise that will be fulfilled when the popup has been loaded and\n      the opening animation has completed.\n    @stable\n     */\n    attachAsap = function(elementOrSelector, options) {\n      return chain.asap(closeNow, (function() {\n        return attachNow(elementOrSelector, options);\n      }));\n    };\n    attachNow = function(elementOrSelector, options) {\n      var align, anchor, animateOptions, extractOptions, html, position, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, target, url;\n      anchor = e.get(elementOrSelector);\n      if (options == null) {\n        options = {};\n      }\n      url = (ref = (ref1 = u.pluckKey(options, 'url')) != null ? ref1 : anchor.getAttribute('up-href')) != null ? ref : anchor.getAttribute('href');\n      html = u.pluckKey(options, 'html');\n      url || html || up.fail('up.popup.attach() requires either an { url } or { html } option');\n      target = (ref2 = u.pluckKey(options, 'target')) != null ? ref2 : anchor.getAttribute('up-popup') || up.fail('No target selector given for [up-popup]');\n      position = (ref3 = (ref4 = options.position) != null ? ref4 : anchor.getAttribute('up-position')) != null ? ref3 : config.position;\n      align = (ref5 = (ref6 = options.align) != null ? ref6 : anchor.getAttribute('up-align')) != null ? ref5 : config.align;\n      if (options.animation == null) {\n        options.animation = (ref7 = anchor.getAttribute('up-animation')) != null ? ref7 : config.openAnimation;\n      }\n      if (options.sticky == null) {\n        options.sticky = (ref8 = e.booleanAttr(anchor, 'up-sticky')) != null ? ref8 : config.sticky;\n      }\n      options.history = up.browser.canPushState() ? (ref9 = (ref10 = options.history) != null ? ref10 : e.booleanOrStringAttr(anchor, 'up-history')) != null ? ref9 : config.history : false;\n      if (options.confirm == null) {\n        options.confirm = anchor.getAttribute('up-confirm');\n      }\n      options.method = up.link.followMethod(anchor, options);\n      options.layer = 'popup';\n      if (options.failTarget == null) {\n        options.failTarget = anchor.getAttribute('up-fail-target');\n      }\n      if (options.failLayer == null) {\n        options.failLayer = anchor.getAttribute('up-fail-layer');\n      }\n      options.provideTarget = function() {\n        return createHiddenFrame(target);\n      };\n      animateOptions = up.motion.animateOptions(options, anchor, {\n        duration: config.openDuration,\n        easing: config.openEasing\n      });\n      extractOptions = u.merge(options, {\n        animation: false\n      });\n      if (options.preload && url) {\n        return up.replace(target, url, options);\n      }\n      return up.browser.whenConfirmed(options).then(function() {\n        return up.event.whenEmitted('up:popup:open', {\n          url: url,\n          anchor: anchor,\n          log: 'Opening popup'\n        }).then(function() {\n          var promise;\n          state.phase = 'opening';\n          state.anchor = anchor;\n          state.position = position;\n          state.align = align;\n          if (options.history) {\n            state.coveredUrl = up.browser.url();\n            state.coveredTitle = document.title;\n          }\n          state.sticky = options.sticky;\n          if (html) {\n            promise = up.extract(target, html, extractOptions);\n          } else {\n            promise = up.replace(target, url, extractOptions);\n          }\n          promise = promise.then(function() {\n            unveilFrame();\n            syncPosition();\n            return up.animate(state.popup, options.animation, animateOptions);\n          });\n          promise = promise.then(function() {\n            state.phase = 'opened';\n            return up.emit(state.popup, 'up:popup:opened', {\n              anchor: state.anchor,\n              log: 'Popup opened'\n            });\n          });\n          return promise;\n        });\n      });\n    };\n\n    /***\n    This event is [emitted](/up.emit) when a popup is starting to open.\n    \n    @event up:popup:open\n    @param {Element} event.anchor\n      The element to which the popup will be attached.\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the popup from opening.\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) when a popup has finished opening.\n    \n    @event up:popup:opened\n    @param {Element} event.anchor\n      The element to which the popup was attached.\n    @stable\n     */\n\n    /***\n    Closes a currently opened popup overlay.\n    \n    Does nothing if no popup is currently open.\n    \n    Emits events [`up:popup:close`](/up:popup:close) and [`up:popup:closed`](/up:popup:closed).\n    \n    @function up.popup.close\n    @param {Object} options\n      See options for [`up.animate()`](/up.animate).\n    @return {Promise}\n      A promise that will be fulfilled once the modal's close\n      animation has finished.\n    @stable\n     */\n    closeAsap = function(options) {\n      return chain.asap(function() {\n        return closeNow(options);\n      });\n    };\n    closeNow = function(options) {\n      var animateOptions;\n      if (!isOpen()) {\n        return Promise.resolve();\n      }\n      options = u.options(options, {\n        animation: config.closeAnimation,\n        history: state.coveredUrl,\n        title: state.coveredTitle\n      });\n      animateOptions = up.motion.animateOptions(options, {\n        duration: config.closeDuration,\n        easing: config.closeEasing\n      });\n      u.assign(options, animateOptions);\n      return up.event.whenEmitted('up:popup:close', {\n        anchor: state.anchor,\n        log: 'Closing popup'\n      }).then(function() {\n        state.phase = 'closing';\n        state.url = null;\n        state.coveredUrl = null;\n        state.coveredTitle = null;\n        return up.destroy(state.popup, options).then(function() {\n          state.phase = 'closed';\n          state.tether.destroy();\n          state.tether = null;\n          state.popup = null;\n          state.content = null;\n          state.anchor = null;\n          state.sticky = null;\n          return up.emit('up:popup:closed', {\n            anchor: state.anchor,\n            log: 'Popup closed'\n          });\n        });\n      });\n    };\n    preloadNow = function(link, options) {\n      options = u.options(options);\n      options.preload = true;\n      return attachNow(link, options);\n    };\n    toggleAsap = function(link, options) {\n      if (link.classList.contains('up-current')) {\n        return closeAsap();\n      } else {\n        return attachAsap(link, options);\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when a popup dialog\n    is starting to [close](/up.popup.close).\n    \n    @event up:popup:close\n    @param {Element} event.anchor\n      The element to which the popup is attached.\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the popup from closing.\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) when a popup dialog\n    is done [closing](/up.popup.close).\n    \n    @event up:popup:closed\n    @param {Element} event.anchor\n      The element to which the popup was attached.\n    @stable\n     */\n    autoclose = function() {\n      if (!state.sticky) {\n        discardHistory();\n        return closeAsap();\n      }\n    };\n\n    /***\n    Returns whether the given element or selector is contained\n    within the current popup.\n    \n    @methods up.popup.contains\n    @param {string} elementOrSelector\n      The element to test\n    @return {boolean}\n    @stable\n     */\n    contains = function(elementOrSelector) {\n      var element;\n      element = e.get(elementOrSelector);\n      return !!e.closest(element, '.up-popup');\n    };\n\n    /***\n    Opens this link's destination of in a popup overlay:\n    \n        <a href=\"/decks\" up-popup=\".deck_list\">Switch deck</a>\n    \n    If the `up-sticky` attribute is set, the dialog does not auto-close\n    if a page fragment behind the popup overlay updates:\n    \n        <a href=\"/decks\" up-popup=\".deck_list\">Switch deck</a>\n        <a href=\"/settings\" up-popup=\".options\" up-sticky>Settings</a>\n    \n    @selector a[up-popup]\n    @param {string} up-popup\n      The CSS selector that will be extracted from the response and\n      displayed in a popup overlay.\n    @param {string} [up-position]\n      Defines on which side of the opening element the popup is attached.\n    \n      Valid values are `'top'`, `'right'`, `'bottom'` and `'left'`.\n    @param {string} [up-align]\n      Defines the alignment of the popup along its side.\n    \n      When the popup's `{ position }` is `'top'` or `'bottom'`, valid `{ align }` values are `'left'`, `center'` and `'right'`.\n      When the popup's `{ position }` is `'left'` or `'right'`, valid `{ align }` values are `top'`, `center'` and `bottom'`.\n    @param {string} [up-confirm]\n      A message that will be displayed in a cancelable confirmation dialog\n      before the popup is opened.\n    @param {string} [up-method='GET']\n      Override the request method.\n    @param [up-sticky]\n      If set to `true`, the popup remains\n      open even if the page changes in the background.\n    @param {string} [up-history='false']\n      Whether to push an entry to the browser history for the popup's source URL.\n    \n      Set this to `'false'` to prevent the URL bar from being updated.\n      Set this to a URL string to update the history with the given URL.\n    \n    @stable\n     */\n    up.link.addFollowVariant('[up-popup]', {\n      follow: function(link, options) {\n        return toggleAsap(link, options);\n      },\n      preload: function(link, options) {\n        return preloadNow(link, options);\n      }\n    });\n    up.on('click up:action:consumed', function(event) {\n      var target;\n      target = event.target;\n      if (!e.closest(target, '.up-popup, [up-popup]')) {\n        return u.muteRejection(closeAsap());\n      }\n    });\n    up.on('up:fragment:inserted', function(event, fragment) {\n      var newSource;\n      if (contains(fragment)) {\n        if (newSource = fragment.getAttribute('up-source')) {\n          return state.url = newSource;\n        }\n      } else if (event.origin && contains(event.origin)) {\n        return u.muteRejection(autoclose());\n      }\n    });\n    up.event.onEscape(function() {\n      return u.muteRejection(closeAsap());\n    });\n\n    /***\n    When this element is clicked, a currently open [popup](/up.popup) is closed.\n    \n    Does nothing if no popup is currently open.\n    \n    \\#\\#\\# Example\n    \n    Clickin on this `<span>` will close a currently open popup:\n    \n        <span class='up-close'>Close this popup</span>\n    \n    When a popup changes the current URL, you might need to deal with content being displayed\n    as either a popup or a full page.\n    \n    To make a link that closes the current popup, but follows to\n    a fallback destination if no popup is open:\n    \n        <a href=\"/fallback\" up-close>Okay</a>\n    \n    @selector .up-popup [up-close]\n    @stable\n     */\n    up.on('click', '.up-popup [up-close]', function(event) {\n      u.muteRejection(closeAsap());\n      return up.event.consumeAction(event);\n    });\n    up.on('up:history:restore', function() {\n      return u.muteRejection(closeAsap());\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      attach: attachAsap,\n      close: closeAsap,\n      url: function() {\n        return state.url;\n      },\n      coveredUrl: function() {\n        return state.coveredUrl;\n      },\n      config: config,\n      contains: contains,\n      isOpen: isOpen,\n      sync: syncPosition\n    };\n  })();\n\n}).call(this);\n\n/***\nModal dialogs\n=============\n\nInstead of [linking to a page fragment](/up.link), you can choose to show a fragment\nin a modal dialog. The existing page will remain open in the background.\n\nTo open a modal, add an [`[up-modal]`](/a-up-modal) attribute to a link:\n\n    <a href=\"/blogs\" up-modal=\".blog-list\">Switch blog</a>\n\nWhen this link is clicked, Unpoly will request the path `/blogs` and extract\nan element matching the selector `.blog-list` from the response. The matching element\nwill then be placed in a modal dialog.\n\n\n\\#\\#\\# Closing behavior\n\nBy default the dialog automatically closes\n*when a link inside a modal changes a fragment behind the modal*.\nThis is useful to have the dialog interact with the page that\nopened it, e.g. by updating parts of a larger form.\n\nTo disable this behavior, give the opening link an [`up-sticky`](/a-up-modal#up-sticky) attribute:\n\n\n\\#\\#\\# Customizing the dialog design\n\nDialogs have a minimal default design:\n\n- Contents are displayed in a white box with a subtle box shadow\n- The box will grow to fit the dialog contents, but never grow larger than the screen\n- The box is placed over a semi-transparent backdrop to dim the rest of the page\n- There is a button to close the dialog in the top-right corner\n\nThe easiest way to change how the dialog looks is to override the\n[default CSS styles](https://github.com/unpoly/unpoly/blob/master/lib/assets/stylesheets/unpoly/modal.sass).\n\nBy default the dialog uses the following DOM structure:\n\n    <div class=\"up-modal\">\n      <div class=\"up-modal-backdrop\">\n      <div class=\"up-modal-viewport\">\n        <div class=\"up-modal-dialog\">\n          <div class=\"up-modal-content\">\n            <!-- the matching element will be placed here -->\n          </div>\n          <div class=\"up-modal-close\" up-close>X</div>\n        </div>\n      </div>\n    </div>\n\nYou can change this structure by setting [`up.modal.config.template`](/up.modal.config#config.template) to a new template string\nor function.\n\n\n@module up.modal\n */\n\n(function() {\n  up.modal = (function() {\n    var animate, autoclose, bodyShifter, chain, closeAsap, closeNow, config, contains, createHiddenFrame, discardHistory, e, extractAsap, flavor, flavorDefault, flavorOverrides, flavors, followAsap, isOpen, markAsAnimating, openAsap, openNow, part, preloadNow, reset, state, templateHtml, u, unveilFrame, validateTarget, visitAsap;\n    u = up.util;\n    e = up.element;\n\n    /***\n    Sets default options for future modals.\n    \n    @property up.modal.config\n    @param {string} [config.history=true]\n      Whether opening a modal will add a browser history entry.\n    @param {number} [config.width]\n      The width of the dialog as a CSS value like `'400px'` or `'50%'`.\n    \n      Defaults to `undefined`, meaning that the dialog will grow to fit its contents\n      until it reaches `config.maxWidth`. Leaving this as `undefined` will\n      also allow you to control the width using CSS on `.up-modal-dialog.\n    @param {number} [config.maxWidth]\n      The width of the dialog as a CSS value like `'400px'` or `50%`.\n      You can set this to `undefined` to make the dialog fit its contents.\n      Be aware however, that e.g. Bootstrap stretches input elements\n      to `width: 100%`, meaning the dialog will also stretch to the full\n      width of the screen.\n    @param {number} [config.height='auto']\n      The height of the dialog in pixels.\n      Defaults to `undefined`, meaning that the dialog will grow to fit its contents.\n    @param {string|Function(config): string} [config.template]\n      A string containing the HTML structure of the modal.\n      You can supply an alternative template string, but make sure that it\n      defines tag with the classes `up-modal`, `up-modal-dialog` and  `up-modal-content`.\n    \n      You can also supply a function that returns a HTML string.\n      The function will be called with the modal options (merged from these defaults\n      and any per-open overrides) whenever a modal opens.\n    @param {string} [config.closeLabel='']\n      The label of the button that closes the dialog.\n    @param {boolean} [config.closable=true]\n      When `true`, the modal will render a close icon and close when the user\n      clicks on the backdrop or presses Escape.\n    \n      When `false`, you need to either supply an element with `[up-close]` or\n      close the modal manually with `up.modal.close()`.\n    @param {string} [config.openAnimation='fade-in']\n      The animation used to open the viewport around the dialog.\n    @param {string} [config.closeAnimation='fade-out']\n      The animation used to close the viewport the dialog.\n    @param {string} [config.backdropOpenAnimation='fade-in']\n      The animation used to open the backdrop that dims the page below the dialog.\n    @param {string} [config.backdropCloseAnimation='fade-out']\n      The animation used to close the backdrop that dims the page below the dialog.\n    @param {number} [config.openDuration]\n      The duration of the open animation (in milliseconds).\n    @param {number} [config.closeDuration]\n      The duration of the close animation (in milliseconds).\n    @param {string} [config.openEasing]\n      The timing function controlling the acceleration of the opening animation.\n    @param {string} [config.closeEasing]\n      The timing function controlling the acceleration of the closing animation.\n    @param {boolean} [options.sticky=false]\n      If set to `true`, the modal remains\n      open even it changes the page in the background.\n    @param {string} [options.flavor='default']\n      The default [flavor](/up.modal.flavors).\n    @stable\n     */\n    config = new up.Config({\n      maxWidth: null,\n      width: null,\n      height: null,\n      history: true,\n      openAnimation: 'fade-in',\n      closeAnimation: 'fade-out',\n      openDuration: null,\n      closeDuration: null,\n      openEasing: null,\n      closeEasing: null,\n      backdropOpenAnimation: 'fade-in',\n      backdropCloseAnimation: 'fade-out',\n      closeLabel: '',\n      closable: true,\n      sticky: false,\n      flavor: 'default',\n      position: null,\n      template: function(options) {\n        return \"<div class=\\\"up-modal\\\">\\n  <div class=\\\"up-modal-backdrop\\\"></div>\\n  <div class=\\\"up-modal-viewport\\\">\\n    <div class=\\\"up-modal-dialog\\\">\\n      <div class=\\\"up-modal-content\\\"></div>\\n      <div class=\\\"up-modal-close\\\" up-close>\" + options.closeLabel + \"</div>\\n    </div>\\n  </div>\\n</div>\";\n      }\n    });\n\n    /***\n    Define modal variants with their own default configuration, CSS or HTML template.\n    \n    \\#\\#\\# Example\n    \n    Unpoly's [`[up-drawer]`](/a-up-drawer) is implemented as a modal flavor:\n    \n        up.modal.flavors.drawer = {\n          openAnimation: 'move-from-right',\n          closeAnimation: 'move-to-right'\n        }\n    \n    Modals with that flavor will have a container with an `up-flavor` attribute:\n    \n        <div class='up-modal' up-flavor='drawer'>\n          ...\n        </div>\n    \n    We can target the `up-flavor` attribute to override the default dialog styles:\n    \n        .up-modal[up-flavor='drawer'] {\n    \n          .up-modal-dialog {\n            margin: 0;         // Remove margin so drawer starts at the screen edge\n            max-width: 350px;  // Set drawer size\n          }\n    \n          .up-modal-content {\n            min-height: 100vh; // Stretch background to full window height\n          }\n        }\n    \n    @property up.modal.flavors\n    @param {Object} flavors\n      An object where the keys are flavor names (e.g. `'drawer') and\n      the values are the respective default configurations.\n    @experimental\n     */\n    flavors = new up.Config({\n      \"default\": {}\n    });\n\n    /***\n    Returns the source URL for the fragment displayed in the current modal overlay,\n    or `undefined` if no modal is currently open.\n    \n    @function up.modal.url\n    @return {string}\n      the source URL\n    @stable\n     */\n\n    /***\n    Returns the URL of the page behind the modal overlay.\n    \n    @function up.modal.coveredUrl\n    @return {string}\n    @experimental\n     */\n    state = new up.Config({\n      phase: 'closed',\n      anchorElement: null,\n      modalElement: null,\n      sticky: null,\n      closable: null,\n      flavor: null,\n      url: null,\n      coveredUrl: null,\n      coveredTitle: null,\n      position: null\n    });\n    bodyShifter = new up.BodyShifter();\n    chain = new up.DivertibleChain();\n    reset = function() {\n      if (state.modalElement) {\n        e.remove(state.modalElement);\n      }\n      bodyShifter.unshift();\n      state.reset();\n      chain.reset();\n      config.reset();\n      return flavors.reset();\n    };\n    templateHtml = function() {\n      var template;\n      template = flavorDefault('template');\n      return u.evalOption(template, {\n        closeLabel: flavorDefault('closeLabel')\n      });\n    };\n    discardHistory = function() {\n      state.coveredTitle = null;\n      return state.coveredUrl = null;\n    };\n    part = function(name) {\n      var selector;\n      selector = \".up-modal-\" + name;\n      return state.modalElement.querySelector(selector);\n    };\n    createHiddenFrame = function(target, options) {\n      var closeElement, contentElement, dialogStyles, html, modalElement;\n      html = templateHtml();\n      state.modalElement = modalElement = e.createFromHtml(html);\n      modalElement.setAttribute('aria-modal', 'true');\n      modalElement.setAttribute('up-flavor', state.flavor);\n      if (u.isPresent(state.position)) {\n        modalElement.setAttribute('up-position', state.position);\n      }\n      dialogStyles = u.only(options, 'width', 'maxWidth', 'height');\n      e.setStyle(part('dialog'), dialogStyles);\n      if (!state.closable) {\n        closeElement = part('close');\n        e.remove(closeElement);\n      }\n      contentElement = part('content');\n      up.fragment.createPlaceholder(target, contentElement);\n      e.hide(modalElement);\n      return document.body.appendChild(modalElement);\n    };\n    unveilFrame = function() {\n      return e.show(state.modalElement);\n    };\n\n    /***\n    Returns whether a modal is currently open.\n    \n    This also returns `true` if the modal is in an opening or closing animation.\n    \n    @function up.modal.isOpen\n    @return {boolean}\n    @stable\n     */\n    isOpen = function() {\n      return state.phase === 'opened' || state.phase === 'opening';\n    };\n\n    /***\n    Opens the given link's destination in a modal overlay:\n    \n        var link = document.querySelector('a')\n        up.modal.follow(link)\n    \n    Any option attributes for [`a[up-modal]`](/a-up-modal) will be honored.\n    \n    Emits events [`up:modal:open`](/up:modal:open) and [`up:modal:opened`](/up:modal:opened).\n    \n    @function up.modal.follow\n    @param {Element|jQuery|string} linkOrSelector\n      The link to follow.\n    @param {string} [options.target]\n      The selector to extract from the response and open in a modal dialog.\n    @param {number} [options.width]\n      The width of the dialog in pixels.\n      By [default](/up.modal.config) the dialog will grow to fit its contents.\n    @param {number} [options.height]\n      The width of the dialog in pixels.\n      By [default](/up.modal.config) the dialog will grow to fit its contents.\n    @param {boolean} [options.sticky=false]\n      If set to `true`, the modal remains\n      open even it changes the page in the background.\n    @param {boolean} [config.closable=true]\n      When `true`, the modal will render a close icon and close when the user\n      clicks on the backdrop or presses Escape.\n    \n      When `false`, you need to either supply an element with `[up-close]` or\n      close the modal manually with `up.modal.close()`.\n    @param {string} [options.confirm]\n      A message that will be displayed in a cancelable confirmation dialog\n      before the modal is being opened.\n    @param {string} [options.method=\"GET\"]\n      Override the request method.\n    @param {boolean} [options.history=true]\n      Whether to add a browser history entry for the modal's source URL.\n    @param {string} [options.animation]\n      The animation to use when opening the modal.\n    @param {number} [options.duration]\n      The duration of the animation. See [`up.animate()`](/up.animate).\n    @param {number} [options.delay]\n      The delay before the animation starts. See [`up.animate()`](/up.animate).\n    @param {string} [options.easing]\n      The timing function that controls the animation's acceleration. [`up.animate()`](/up.animate).\n    @return {Promise}\n      A promise that will be fulfilled when the modal has been loaded and\n      the opening animation has completed.\n    @stable\n     */\n    followAsap = function(linkOrSelector, options) {\n      options = u.options(options);\n      options.link = e.get(linkOrSelector);\n      return openAsap(options);\n    };\n    preloadNow = function(link, options) {\n      options = u.options(options);\n      options.link = link;\n      options.preload = true;\n      return openNow(options);\n    };\n\n    /***\n    Opens a modal for the given URL.\n    \n    \\#\\#\\# Example\n    \n        up.modal.visit('/foo', { target: '.list' })\n    \n    This will request `/foo`, extract the `.list` selector from the response\n    and open the selected container in a modal dialog.\n    \n    Emits events [`up:modal:open`](/up:modal:open) and [`up:modal:opened`](/up:modal:opened).\n    \n    @function up.modal.visit\n    @param {string} url\n      The URL to load.\n    @param {string} options.target\n      The CSS selector to extract from the response.\n      The extracted content will be placed into the dialog window.\n    @param {Object} options\n      See options for [`up.modal.follow()`](/up.modal.follow).\n    @return {Promise}\n      A promise that will be fulfilled when the modal has been loaded and the opening\n      animation has completed.\n    @stable\n     */\n    visitAsap = function(url, options) {\n      options = u.options(options);\n      options.url = url;\n      return openAsap(options);\n    };\n\n    /***\n    [Extracts](/up.extract) the given CSS selector from the given HTML string and\n    opens the results in a modal.\n    \n    \\#\\#\\# Example\n    \n        var html = 'before <div class=\"content\">inner</div> after';\n        up.modal.extract('.content', html)\n    \n    The would open a modal with the following contents:\n    \n        <div class=\"content\">inner</div>\n    \n    Emits events [`up:modal:open`](/up:modal:open) and [`up:modal:opened`](/up:modal:opened).\n    \n    @function up.modal.extract\n    @param {string} selector\n      The CSS selector to extract from the HTML.\n    @param {string} html\n      The HTML containing the modal content.\n    @param {Object} options\n      See options for [`up.modal.follow()`](/up.modal.follow).\n    @return {Promise}\n      A promise that will be fulfilled when the modal has been opened and the opening\n      animation has completed.\n    @stable\n     */\n    extractAsap = function(selector, html, options) {\n      options = u.options(options);\n      options.html = html;\n      if (options.history == null) {\n        options.history = false;\n      }\n      options.target = selector;\n      return openAsap(options);\n    };\n    openAsap = function(options) {\n      return chain.asap(closeNow, (function() {\n        return openNow(options);\n      }));\n    };\n    openNow = function(options) {\n      var animateOptions, html, link, ref, ref1, ref10, ref11, ref12, ref13, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, target, url;\n      options = u.options(options);\n      link = u.pluckKey(options, 'link') || e.none();\n      url = (ref = (ref1 = u.pluckKey(options, 'url')) != null ? ref1 : link.getAttribute('up-href')) != null ? ref : link.getAttribute('href');\n      html = u.pluckKey(options, 'html');\n      target = (ref2 = u.pluckKey(options, 'target')) != null ? ref2 : link.getAttribute('up-modal');\n      validateTarget(target);\n      if (options.flavor == null) {\n        options.flavor = (ref3 = link.getAttribute('up-flavor')) != null ? ref3 : config.flavor;\n      }\n      if (options.position == null) {\n        options.position = (ref4 = link.getAttribute('up-position')) != null ? ref4 : flavorDefault('position', options.flavor);\n      }\n      options.position = u.evalOption(options.position, {\n        link: link\n      });\n      if (options.width == null) {\n        options.width = (ref5 = link.getAttribute('up-width')) != null ? ref5 : flavorDefault('width', options.flavor);\n      }\n      if (options.maxWidth == null) {\n        options.maxWidth = (ref6 = link.getAttribute('up-max-width')) != null ? ref6 : flavorDefault('maxWidth', options.flavor);\n      }\n      if (options.height == null) {\n        options.height = (ref7 = link.getAttribute('up-height')) != null ? ref7 : flavorDefault('height');\n      }\n      if (options.animation == null) {\n        options.animation = (ref8 = link.getAttribute('up-animation')) != null ? ref8 : flavorDefault('openAnimation', options.flavor);\n      }\n      options.animation = u.evalOption(options.animation, {\n        position: options.position\n      });\n      if (options.backdropAnimation == null) {\n        options.backdropAnimation = (ref9 = link.getAttribute('up-backdrop-animation')) != null ? ref9 : flavorDefault('backdropOpenAnimation', options.flavor);\n      }\n      options.backdropAnimation = u.evalOption(options.backdropAnimation, {\n        position: options.position\n      });\n      if (options.sticky == null) {\n        options.sticky = (ref10 = e.booleanAttr(link, 'up-sticky')) != null ? ref10 : flavorDefault('sticky', options.flavor);\n      }\n      if (options.closable == null) {\n        options.closable = (ref11 = e.booleanAttr(link, 'up-closable')) != null ? ref11 : flavorDefault('closable', options.flavor);\n      }\n      if (options.confirm == null) {\n        options.confirm = link.getAttribute('up-confirm');\n      }\n      options.method = up.link.followMethod(link, options);\n      options.layer = 'modal';\n      if (options.failTarget == null) {\n        options.failTarget = link.getAttribute('up-fail-target');\n      }\n      if (options.failLayer == null) {\n        options.failLayer = (ref12 = link.getAttribute('up-fail-layer')) != null ? ref12 : 'auto';\n      }\n      if (options.cache == null) {\n        options.cache = e.booleanAttr(link, 'up-cache');\n      }\n      animateOptions = up.motion.animateOptions(options, link, {\n        duration: flavorDefault('openDuration', options.flavor),\n        easing: flavorDefault('openEasing', options.flavor)\n      });\n      if (options.history == null) {\n        options.history = (ref13 = e.booleanOrStringAttr(link, 'up-history')) != null ? ref13 : flavorDefault('history', options.flavor);\n      }\n      if (!up.browser.canPushState()) {\n        options.history = false;\n      }\n      options.provideTarget = function() {\n        return createHiddenFrame(target, options);\n      };\n      if (options.preload) {\n        return up.replace(target, url, options);\n      }\n      return up.browser.whenConfirmed(options).then(function() {\n        return up.event.whenEmitted('up:modal:open', {\n          url: url,\n          log: 'Opening modal'\n        }).then(function() {\n          var extractOptions, promise;\n          state.phase = 'opening';\n          state.flavor = options.flavor;\n          state.sticky = options.sticky;\n          state.closable = options.closable;\n          state.position = options.position;\n          if (options.history) {\n            state.coveredUrl = up.browser.url();\n            state.coveredTitle = document.title;\n          }\n          extractOptions = u.merge(options, {\n            animation: false\n          });\n          if (html) {\n            promise = up.extract(target, html, extractOptions);\n          } else {\n            promise = up.replace(target, url, extractOptions);\n          }\n          promise = promise.then(function() {\n            bodyShifter.shift();\n            unveilFrame();\n            return animate(options.animation, options.backdropAnimation, animateOptions);\n          });\n          promise = promise.then(function() {\n            state.phase = 'opened';\n            return up.emit('up:modal:opened', {\n              log: 'Modal opened'\n            });\n          });\n          return promise;\n        });\n      });\n    };\n    validateTarget = function(target) {\n      if (u.isBlank(target)) {\n        return up.fail('Cannot open a modal without a target selector');\n      } else if (target === 'body') {\n        return up.fail('Cannot open the <body> in a modal');\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when a modal dialog is starting to open.\n    \n    @event up:modal:open\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the modal from opening.\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) when a modal dialog has finished opening.\n    \n    @event up:modal:opened\n    @stable\n     */\n\n    /***\n    Closes a currently opened modal overlay.\n    \n    Does nothing if no modal is currently open.\n    \n    Emits events [`up:modal:close`](/up:modal:close) and [`up:modal:closed`](/up:modal:closed).\n    \n    @function up.modal.close\n    @param {Object} options\n      See options for [`up.animate()`](/up.animate)\n    @return {Promise}\n      A promise that will be fulfilled once the modal's close\n      animation has finished.\n    @stable\n     */\n    closeAsap = function(options) {\n      return chain.asap(function() {\n        return closeNow(options);\n      });\n    };\n    closeNow = function(options) {\n      var animateOptions, backdropCloseAnimation, destroyOptions, ref, ref1, viewportCloseAnimation;\n      options = u.options(options);\n      if (!isOpen()) {\n        return Promise.resolve();\n      }\n      viewportCloseAnimation = (ref = options.animation) != null ? ref : flavorDefault('closeAnimation');\n      viewportCloseAnimation = u.evalOption(viewportCloseAnimation, {\n        position: state.position\n      });\n      backdropCloseAnimation = (ref1 = options.backdropAnimation) != null ? ref1 : flavorDefault('backdropCloseAnimation');\n      backdropCloseAnimation = u.evalOption(backdropCloseAnimation, {\n        position: state.position\n      });\n      animateOptions = up.motion.animateOptions(options, {\n        duration: flavorDefault('closeDuration'),\n        easing: flavorDefault('closeEasing')\n      });\n      destroyOptions = u.options(u.except(options, 'animation', 'duration', 'easing', 'delay'), {\n        history: state.coveredUrl,\n        title: state.coveredTitle\n      });\n      return up.event.whenEmitted(state.modalElement, 'up:modal:close', {\n        log: 'Closing modal'\n      }).then(function() {\n        var promise;\n        state.phase = 'closing';\n        state.url = null;\n        state.coveredUrl = null;\n        state.coveredTitle = null;\n        promise = animate(viewportCloseAnimation, backdropCloseAnimation, animateOptions);\n        promise = promise.then(function() {\n          return up.destroy(state.modalElement, destroyOptions);\n        });\n        promise = promise.then(function() {\n          bodyShifter.unshift();\n          state.phase = 'closed';\n          state.modalElement = null;\n          state.flavor = null;\n          state.sticky = null;\n          state.closable = null;\n          state.position = null;\n          return up.emit('up:modal:closed', {\n            log: 'Modal closed'\n          });\n        });\n        return promise;\n      });\n    };\n    markAsAnimating = function(isAnimating) {\n      if (isAnimating == null) {\n        isAnimating = true;\n      }\n      return e.toggleClass(state.modalElement, 'up-modal-animating', isAnimating);\n    };\n    animate = function(viewportAnimation, backdropAnimation, animateOptions) {\n      var promise;\n      if (up.motion.isNone(viewportAnimation)) {\n        return Promise.resolve();\n      } else {\n        markAsAnimating();\n        promise = Promise.all([up.animate(part('viewport'), viewportAnimation, animateOptions), up.animate(part('backdrop'), backdropAnimation, animateOptions)]);\n        promise = promise.then(function() {\n          return markAsAnimating(false);\n        });\n        return promise;\n      }\n    };\n\n    /***\n    This event is [emitted](/up.emit) when a modal dialog\n    is starting to [close](/up.modal.close).\n    \n    @event up:modal:close\n    @param event.preventDefault()\n      Event listeners may call this method to prevent the modal from closing.\n    @stable\n     */\n\n    /***\n    This event is [emitted](/up.emit) when a modal dialog\n    is done [closing](/up.modal.close).\n    \n    @event up:modal:closed\n    @stable\n     */\n    autoclose = function() {\n      if (!state.sticky) {\n        discardHistory();\n        return closeAsap();\n      }\n    };\n\n    /***\n    Returns whether the given element or selector is contained\n    within the current modal.\n    \n    @function up.modal.contains\n    @param {string} elementOrSelector\n      The element to test\n    @return {boolean}\n    @stable\n     */\n    contains = function(elementOrSelector) {\n      var element;\n      element = e.get(elementOrSelector);\n      return !!e.closest(element, '.up-modal');\n    };\n    flavor = function(name, overrideConfig) {\n      if (overrideConfig == null) {\n        overrideConfig = {};\n      }\n      up.legacy.warn('up.modal.flavor() is deprecated. Use the up.modal.flavors property instead.');\n      return u.assign(flavorOverrides(name), overrideConfig);\n    };\n\n    /***\n    Returns a config object for the given flavor.\n    Properties in that config should be preferred to the defaults in\n    [`/up.modal.config`](/up.modal.config).\n    \n    @function flavorOverrides\n    @internal\n     */\n    flavorOverrides = function(flavor) {\n      return flavors[flavor] || (flavors[flavor] = {});\n    };\n\n    /***\n    Returns the config option for the current flavor.\n    \n    @function flavorDefault\n    @internal\n     */\n    flavorDefault = function(key, flavorName) {\n      var value;\n      if (flavorName == null) {\n        flavorName = state.flavor;\n      }\n      if (flavorName) {\n        value = flavorOverrides(flavorName)[key];\n      }\n      if (u.isMissing(value)) {\n        value = config[key];\n      }\n      return value;\n    };\n\n    /***\n    Clicking this link will load the destination via AJAX and open\n    the given selector in a modal dialog.\n    \n    \\#\\#\\# Example\n    \n        <a href=\"/blogs\" up-modal=\".blog-list\">Switch blog</a>\n    \n    Clicking would request the path `/blog` and select `.blog-list` from\n    the HTML response. Unpoly will dim the page\n    and place the matching `.blog-list` tag in\n    a modal dialog.\n    \n    @selector a[up-modal]\n    @param {string} up-modal\n      The CSS selector that will be extracted from the response and displayed in a modal dialog.\n    @param {string} [up-confirm]\n      A message that will be displayed in a cancelable confirmation dialog\n      before the modal is opened.\n    @param {string} [up-method='GET']\n      Override the request method.\n    @param {string} [up-sticky]\n      If set to `\"true\"`, the modal remains\n      open even if the page changes in the background.\n    @param {boolean} [up-closable]\n      When `true`, the modal will render a close icon and close when the user\n      clicks on the backdrop or presses Escape.\n    \n      When `false`, you need to either supply an element with `[up-close]` or\n      close the modal manually with `up.modal.close()`.\n    @param {string} [up-animation]\n      The animation to use when opening the viewport containing the dialog.\n    @param {string} [up-backdrop-animation]\n      The animation to use when opening the backdrop that dims the page below the dialog.\n    @param {string} [up-height]\n      The width of the dialog in pixels.\n      By [default](/up.modal.config) the dialog will grow to fit its contents.\n    @param {string} [up-width]\n      The width of the dialog in pixels.\n      By [default](/up.modal.config) the dialog will grow to fit its contents.\n    @param {string} [up-history]\n      Whether to push an entry to the browser history for the modal's source URL.\n    \n      Set this to `'false'` to prevent the URL bar from being updated.\n      Set this to a URL string to update the history with the given URL.\n    \n    @stable\n     */\n    up.link.addFollowVariant('[up-modal]', {\n      follow: function(link, options) {\n        return followAsap(link, options);\n      },\n      preload: function(link, options) {\n        return preloadNow(link, options);\n      }\n    });\n    up.on('click', '.up-modal', function(event) {\n      var target;\n      if (!state.closable) {\n        return;\n      }\n      target = event.target;\n      if (!(e.closest(target, '.up-modal-dialog') || e.closest(target, '[up-modal]'))) {\n        up.event.consumeAction(event);\n        return u.muteRejection(closeAsap());\n      }\n    });\n    up.on('up:fragment:inserted', function(event, fragment) {\n      var newSource;\n      if (contains(fragment)) {\n        if (newSource = fragment.getAttribute('up-source')) {\n          return state.url = newSource;\n        }\n      } else if (event.origin && contains(event.origin) && !up.popup.contains(fragment)) {\n        return u.muteRejection(autoclose());\n      }\n    });\n    up.event.onEscape(function() {\n      if (state.closable) {\n        return u.muteRejection(closeAsap());\n      }\n    });\n\n    /***\n    When this element is clicked, closes a currently open dialog.\n    \n    Does nothing if no modal is currently open.\n    \n    To make a link that closes the current modal, but follows to\n    a fallback destination if no modal is open:\n    \n        <a href=\"/fallback\" up-close>Okay</a>\n    \n    @selector .up-modal [up-close]\n    @stable\n     */\n    up.on('click', '.up-modal [up-close]', function(event) {\n      u.muteRejection(closeAsap());\n      return up.event.consumeAction(event);\n    });\n\n    /***\n    Clicking this link will load the destination via AJAX and open\n    the given selector in a modal drawer that slides in from the edge of the screen.\n    \n    You can configure drawers using the [`up.modal.flavors.drawer`](/up.modal.flavors.drawer) property.\n    \n    \\#\\#\\# Example\n    \n        <a href=\"/blogs\" up-drawer=\".blog-list\">Switch blog</a>\n    \n    Clicking would request the path `/blog` and select `.blog-list` from\n    the HTML response. Unpoly will dim the page\n    and place the matching `.blog-list` tag will be placed in\n    a modal drawer.\n    \n    @selector a[up-drawer]\n    @param {string} up-drawer\n      The CSS selector to extract from the response and open in the drawer.\n    @param {string} [up-position='auto']\n      The side from which the drawer slides in.\n    \n      Valid values are `'left'`, `'right'` and `'auto'`. If set to `'auto'`, the\n      drawer will slide in from left if the opening link is on the left half of the screen.\n      Otherwise it will slide in from the right.\n    @stable\n     */\n    up.macro('a[up-drawer], [up-href][up-drawer]', function(link) {\n      var target;\n      target = link.getAttribute('up-drawer');\n      return e.setAttrs(link, {\n        'up-modal': target,\n        'up-flavor': 'drawer'\n      });\n    });\n\n    /***\n    Sets default options for future drawers.\n    \n    @property up.modal.flavors.drawer\n    @param {Object} config\n      Default options for future drawers.\n    \n      See [`up.modal.config`](/up.modal.config) for available options.\n    @experimental\n     */\n    flavors.drawer = {\n      openAnimation: function(options) {\n        switch (options.position) {\n          case 'left':\n            return 'move-from-left';\n          case 'right':\n            return 'move-from-right';\n        }\n      },\n      closeAnimation: function(options) {\n        switch (options.position) {\n          case 'left':\n            return 'move-to-left';\n          case 'right':\n            return 'move-to-right';\n        }\n      },\n      position: function(options) {\n        if (u.isPresent(options.link)) {\n          return u.horizontalScreenHalf(options.link);\n        } else {\n          return 'left';\n        }\n      }\n    };\n    up.on('up:history:restore', function() {\n      return u.muteRejection(closeAsap());\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      visit: visitAsap,\n      follow: followAsap,\n      extract: extractAsap,\n      close: closeAsap,\n      url: function() {\n        return state.url;\n      },\n      coveredUrl: function() {\n        return state.coveredUrl;\n      },\n      config: config,\n      flavors: flavors,\n      contains: contains,\n      isOpen: isOpen,\n      flavor: flavor\n    };\n  })();\n\n}).call(this);\n\n/***\nTooltips\n========\n\nUnpoly comes with a basic tooltip implementation.\n\nAdd an [`up-tooltip`](/up-tooltip) attribute to any HTML tag to show a tooltip whenever\nthe user hovers over the element:\n\n      <a href=\"/decks\" up-tooltip=\"Show all decks\">Decks</a>\n\n\n\\#\\#\\# Styling\n\nThe default styles\nrender a tooltip with white text on a gray background.\nA gray triangle points to the element.\n\nTo change the styling, simply override the [CSS rules](https://github.com/unpoly/unpoly/blob/master/lib/assets/stylesheets/unpoly/tooltip.sass) for the `.up-tooltip` selector and its `:after`\nselector that is used for the triangle.\n\nThe HTML of a tooltip element looks like this:\n\n    <div class=\"up-tooltip\">\n      <div class=\"up-tooltip-content\">\n        Tooltip text here\n      </div>\n    </div>\n\nThe tooltip element is appended to the [viewport](/up.viewport) of the anchor element.\n\n@module up.tooltip\n */\n\n(function() {\n  up.tooltip = (function() {\n    var attachAsap, attachNow, chain, closeAsap, closeNow, config, createElement, e, isOpen, reset, state, syncPosition, u;\n    u = up.util;\n    e = up.element;\n\n    /***\n    Configures defaults for future tooltips.\n    \n    @property up.tooltip.config\n    @param {string} [config.position]\n      The default position of tooltips relative to the opening element.\n    \n      Valid values are `'top'`, `'right'`, `'bottom'` or `'left'`.\n    @param {string} [config.align]\n      Defines the alignment of the tooltip along its side.\n    \n      When the tooltip's `{ position }` is `'top'` or `'bottom'`, valid `{ align }` values are `'left'`, `center'` and `'right'`.\n      When the tooltip's `{ position }` is `'left'` or `'right'`, valid `{ align }` values are `top'`, `center'` and `bottom'`.\n    @param {string} [config.openAnimation='fade-in']\n      The animation used to open a tooltip.\n    @param {string} [config.closeAnimation='fade-out']\n      The animation used to close a tooltip.\n    @param {number} [config.openDuration]\n      The duration of the open animation (in milliseconds).\n    @param {number} [config.closeDuration]\n      The duration of the close animation (in milliseconds).\n    @param {string} [config.openEasing]\n      The timing function controlling the acceleration of the opening animation.\n    @param {string} [config.closeEasing]\n      The timing function controlling the acceleration of the closing animation.\n    @stable\n     */\n    config = new up.Config({\n      position: 'top',\n      align: 'center',\n      openAnimation: 'fade-in',\n      closeAnimation: 'fade-out',\n      openDuration: 100,\n      closeDuration: 50,\n      openEasing: null,\n      closeEasing: null\n    });\n    state = new up.Config({\n      phase: 'closed',\n      anchor: null,\n      tooltip: null,\n      content: null,\n      tether: null,\n      position: null,\n      align: null\n    });\n    chain = new up.DivertibleChain();\n    reset = function() {\n      var ref;\n      if ((ref = state.tether) != null) {\n        ref.destroy();\n      }\n      state.reset();\n      chain.reset();\n      return config.reset();\n    };\n    createElement = function(options) {\n      state.tether = new up.Tether(u.only(state, 'anchor', 'position', 'align'));\n      state.tooltip = e.affix(state.tether.root, '.up-tooltip', {\n        'up-position': state.position,\n        'up-align': state.align\n      });\n      state.content = e.affix(state.tooltip, '.up-tooltip-content');\n      if (options.text) {\n        return state.content.innerText = options.text;\n      } else {\n        return state.content.innerHTML = options.html;\n      }\n    };\n\n    /***\n    Forces the tooltip to update its position relative to its anchor element.\n    \n    Unpoly will automatically keep tooltips aligned when\n    the document is resized or scrolled. Complex layout changes may make\n    it necessary to call this function.\n    \n    @function up.tooltip.sync\n    @experimental\n     */\n    syncPosition = function() {\n      var ref;\n      return (ref = state.tether) != null ? ref.sync() : void 0;\n    };\n\n    /***\n    Opens a tooltip over the given element.\n    \n    The unobtrusive variant of this is the [`[up-tooltip]`](/up-tooltip) selector.\n    \n    \\#\\#\\# Examples\n    \n    In order to attach a tooltip to a `<span class=\"help\">?</span>`:\n    \n        up.tooltip.attach('.help', { text: 'Useful info' })\n    \n    @function up.tooltip.attach\n    @param {Element|jQuery|string} elementOrSelector\n    @param {string} [options.text]\n      The text to display in the tooltip.\n    \n      Any HTML control characters will be escaped.\n      If you need to use HTML formatting in the tooltip, use `options.html` instead.\n    @param {string} [options.html]\n      The HTML to display in the tooltip unescaped.\n    \n      Make sure to escape any user-provided text before passing it as this option,\n      or use `options.text` (which automatically escapes).\n    @param {string} [options.position]\n      The tooltip's position relative to the opening element.\n    \n      Valid values are `'top'`, `'right'`, `'bottom'` or `'left'`.\n    @param {string} [options.align]\n      Defines the alignment of the tooltip along its side.\n    \n      When the tooltip's `{ position }` is `'top'` or `'bottom'`, valid `{ align }` values are `'left'`, `center'` and `'right'`.\n      When the tooltip's `{ position }` is `'left'` or `'right'`, valid `{ align }` values are `top'`, `center'` and `bottom'`.\n    @param {string} [options.animation]\n      The [animation](/up.motion) to use when opening the tooltip.\n    @return {Promise}\n      A promise that will be fulfilled when the tooltip's opening animation has finished.\n    @stable\n     */\n    attachAsap = function(elementOrSelector, options) {\n      return chain.asap(closeNow, (function() {\n        return attachNow(elementOrSelector, options);\n      }));\n    };\n    attachNow = function(elementOrSelector, options) {\n      var align, anchor, animateOptions, animation, html, position, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, text;\n      if (options == null) {\n        options = {};\n      }\n      anchor = e.get(elementOrSelector);\n      html = (ref = options.html) != null ? ref : anchor.getAttribute('up-tooltip-html');\n      text = (ref1 = options.text) != null ? ref1 : anchor.getAttribute('up-tooltip');\n      position = (ref2 = (ref3 = options.position) != null ? ref3 : anchor.getAttribute('up-position')) != null ? ref2 : config.position;\n      align = (ref4 = (ref5 = options.align) != null ? ref5 : anchor.getAttribute('up-align')) != null ? ref4 : config.align;\n      animation = (ref6 = (ref7 = options.animation) != null ? ref7 : e.booleanOrStringAttr(anchor, 'up-animation')) != null ? ref6 : config.openAnimation;\n      animateOptions = up.motion.animateOptions(options, anchor, {\n        duration: config.openDuration,\n        easing: config.openEasing\n      });\n      state.phase = 'opening';\n      state.anchor = anchor;\n      state.position = position;\n      state.align = align;\n      createElement({\n        text: text,\n        html: html\n      });\n      syncPosition();\n      return up.animate(state.tooltip, animation, animateOptions).then(function() {\n        return state.phase = 'opened';\n      });\n    };\n\n    /***\n    Closes a currently shown tooltip.\n    \n    Does nothing if no tooltip is currently shown.\n    \n    @function up.tooltip.close\n    @param {Object} options\n      See options for [`up.animate()`](/up.animate).\n    @return {Promise}\n      A promise for the end of the closing animation.\n    @stable\n     */\n    closeAsap = function(options) {\n      return chain.asap(function() {\n        return closeNow(options);\n      });\n    };\n    closeNow = function(options) {\n      var animateOptions;\n      if (!isOpen()) {\n        return Promise.resolve();\n      }\n      options = u.options(options, {\n        animation: config.closeAnimation\n      });\n      animateOptions = up.motion.animateOptions(options, {\n        duration: config.closeDuration,\n        easing: config.closeEasing\n      });\n      u.assign(options, animateOptions);\n      state.phase = 'closing';\n      return up.destroy(state.tooltip, options).then(function() {\n        state.phase = 'closed';\n        state.tether.destroy();\n        state.tether = null;\n        state.tooltip = null;\n        state.content = null;\n        return state.anchor = null;\n      });\n    };\n\n    /***\n    Returns whether a tooltip is currently showing.\n    \n    @function up.tooltip.isOpen\n    @stable\n     */\n    isOpen = function() {\n      return state.phase === 'opening' || state.phase === 'opened';\n    };\n\n    /***\n    Displays a tooltip with text content when hovering the mouse over this element.\n    \n    \\#\\#\\# Example\n    \n        <a href=\"/decks\" up-tooltip=\"Show all decks\">Decks</a>\n    \n    To make the tooltip appear below the element instead of above the element,\n    add an `up-position` attribute:\n    \n        <a href=\"/decks\" up-tooltip=\"Show all decks\" up-position=\"bottom\">Decks</a>\n    \n    @selector [up-tooltip]\n    @param {string} [up-animation]\n      The animation used to open the tooltip.\n      Defaults to [`up.tooltip.config.openAnimation`](/up.tooltip.config).\n    @param {string} [up-position]\n      The tooltip's position relative to the opening element.\n    \n      Valid values are `'top'`, `'right'`, `'bottom'` or `'left'`.\n    @param {string} [up-align]\n      Defines the alignment of the tooltip along its side.\n    \n      When the tooltip's `{ position }` is `'top'` or `'bottom'`, valid `{ align }` values are `'left'`, `center'` and `'right'`.\n      When the tooltip's `{ position }` is `'left'` or `'right'`, valid `{ align }` values are `top'`, `center'` and `bottom'`.\n    @stable\n     */\n\n    /***\n    Displays a tooltip with HTML content when hovering the mouse over this element:\n    \n        <a href=\"/decks\" up-tooltip-html=\"Show &lt;b&gt;all&lt;/b&gt; decks\">Decks</a>\n    \n    @selector [up-tooltip-html]\n    @stable\n     */\n    up.compiler('[up-tooltip], [up-tooltip-html]', function(opener) {\n      opener.addEventListener('mouseenter', function() {\n        return attachAsap(opener);\n      });\n      return opener.addEventListener('mouseleave', function() {\n        return closeAsap();\n      });\n    });\n    up.on('click up:action:consumed', function(_event) {\n      return closeAsap();\n    });\n    up.on('up:framework:reset', reset);\n    up.event.onEscape(function() {\n      return closeAsap();\n    });\n    return {\n      config: config,\n      attach: attachAsap,\n      isOpen: isOpen,\n      close: closeAsap,\n      sync: syncPosition\n    };\n  })();\n\n}).call(this);\n\n/***\nNavigation feedback\n===================\n\nThe `up.feedback` module adds useful CSS classes to links while they are loading,\nor when they point to the current URL. By styling these classes you may\nprovide instant feedback to user interactions. This improves the perceived speed of your interface.\n\n\n\\#\\#\\# Example\n\nLet's say we have an navigation bar with two links, pointing to `/foo` and `/bar` respectively:\n\n    <div up-nav>\n      <a href=\"/foo\" up-follow>Foo</a>\n      <a href=\"/bar\" up-follow>Bar</a>\n    </div>\n\nIf the current URL is `/foo`, the first link is automatically marked with an [`.up-current`](/a.up-current) class:\n\n    <div up-nav>\n      <a href=\"/foo\" up-follow class=\"up-current\">Foo</a>\n      <a href=\"/bar\" up-follow>Bar</a>\n    </div>\n\nWhen the user clicks on the `/bar` link, the link will receive the [`up-active`](/a.up-active) class while it is waiting\nfor the server to respond:\n\n    <div up-nav>\n      <a href=\"/foo\" up-follow class=\"up-current\">Foo</a>\n      <a href=\"/bar\" up-follow class=\"up-active\">Bar</a>\n    </div>\n\nOnce the response is received the URL will change to `/bar` and the `up-active` class is removed:\n\n    <div up-nav>\n      <a href=\"/foo\" up-follow>Foo</a>\n      <a href=\"/bar\" up-follow class=\"up-current\">Bar</a>\n    </div>\n\n\n@module up.feedback\n */\n\n(function() {\n  up.feedback = (function() {\n    var CLASS_ACTIVE, SELECTOR_LINK, buildCurrentUrlSet, buildSectionUrls, config, currentUrlSet, e, findActivatableArea, navSelector, normalizeUrl, previousUrlSet, reset, sectionUrls, start, stop, u, updateAllNavigationSections, updateAllNavigationSectionsIfLocationChanged, updateCurrentClassForLinks, updateNavigationSectionsInNewFragment;\n    u = up.util;\n    e = up.element;\n\n    /***\n    Sets default options for this module.\n    \n    @property up.feedback.config\n    @param {Array<string>} [config.currentClasses]\n      An array of classes to set on [links that point the current location](/a.up-current).\n    @param {Array<string>} [config.navs]\n      An array of CSS selectors that match [navigation components](/up-nav).\n    @stable\n     */\n    config = new up.Config({\n      currentClasses: ['up-current'],\n      navs: ['[up-nav]']\n    });\n    previousUrlSet = void 0;\n    currentUrlSet = void 0;\n    reset = function() {\n      config.reset();\n      previousUrlSet = void 0;\n      return currentUrlSet = void 0;\n    };\n    CLASS_ACTIVE = 'up-active';\n    SELECTOR_LINK = 'a, [up-href]';\n    navSelector = function() {\n      return config.navs.join(',');\n    };\n    normalizeUrl = function(url) {\n      if (u.isPresent(url)) {\n        return u.normalizeUrl(url, {\n          stripTrailingSlash: true\n        });\n      }\n    };\n    sectionUrls = function(section) {\n      var urls;\n      if (!(urls = section.upNormalizedUrls)) {\n        urls = buildSectionUrls(section);\n        section.upNormalizedUrls = urls;\n      }\n      return urls;\n    };\n    buildSectionUrls = function(section) {\n      var attr, i, j, len, len1, ref, ref1, url, urls, value;\n      urls = [];\n      if (up.link.isSafe(section)) {\n        ref = ['href', 'up-href', 'up-alias'];\n        for (i = 0, len = ref.length; i < len; i++) {\n          attr = ref[i];\n          if (value = section.getAttribute(attr)) {\n            ref1 = u.splitValues(value);\n            for (j = 0, len1 = ref1.length; j < len1; j++) {\n              url = ref1[j];\n              if (url !== '#') {\n                url = normalizeUrl(url);\n                urls.push(url);\n              }\n            }\n          }\n        }\n      }\n      return urls;\n    };\n    buildCurrentUrlSet = function() {\n      var urls;\n      urls = [up.browser.url(), up.modal.url(), up.modal.coveredUrl(), up.popup.url(), up.popup.coveredUrl()];\n      return new up.UrlSet(urls, {\n        normalizeUrl: normalizeUrl\n      });\n    };\n    updateAllNavigationSectionsIfLocationChanged = function() {\n      previousUrlSet = currentUrlSet;\n      currentUrlSet = buildCurrentUrlSet();\n      if (!u.isEqual(currentUrlSet, previousUrlSet)) {\n        return updateAllNavigationSections(document.body);\n      }\n    };\n    updateAllNavigationSections = function(root) {\n      var navs, sections;\n      navs = e.subtree(root, navSelector());\n      sections = u.flatMap(navs, function(nav) {\n        return e.subtree(nav, SELECTOR_LINK);\n      });\n      return updateCurrentClassForLinks(sections);\n    };\n    updateNavigationSectionsInNewFragment = function(fragment) {\n      var sections;\n      if (e.closest(fragment, navSelector())) {\n        sections = e.subtree(fragment, SELECTOR_LINK);\n        return updateCurrentClassForLinks(sections);\n      } else {\n        return updateAllNavigationSections(fragment);\n      }\n    };\n    updateCurrentClassForLinks = function(links) {\n      currentUrlSet || (currentUrlSet = buildCurrentUrlSet());\n      return u.each(links, function(link) {\n        var classList, i, j, klass, len, len1, ref, ref1, results, results1, urls;\n        urls = sectionUrls(link);\n        classList = link.classList;\n        if (currentUrlSet.matchesAny(urls)) {\n          ref = config.currentClasses;\n          results = [];\n          for (i = 0, len = ref.length; i < len; i++) {\n            klass = ref[i];\n            results.push(classList.add(klass));\n          }\n          return results;\n        } else {\n          ref1 = config.currentClasses;\n          results1 = [];\n          for (j = 0, len1 = ref1.length; j < len1; j++) {\n            klass = ref1[j];\n            results1.push(classList.remove(klass));\n          }\n          return results1;\n        }\n      });\n    };\n\n    /***\n    @function findActivatableArea\n    @param {string|Element|jQuery} elementOrSelector\n    @internal\n     */\n    findActivatableArea = function(element) {\n      element = e.get(element);\n      return e.ancestor(element, SELECTOR_LINK) || element;\n    };\n\n    /***\n    Marks the given element as currently loading, by assigning the CSS class [`up-active`](/a.up-active).\n    \n    This happens automatically when following links or submitting forms through the Unpoly API.\n    Use this function if you make custom network calls from your own JavaScript code.\n    \n    If the given element is a link within an [expanded click area](/up-expand),\n    the class will be assigned to the expanded area.\n    \n    \\#\\#\\# Example\n    \n        var button = document.querySelector('button')\n    \n        button.addEventListener('click', () => {\n          up.feedback.start(button)\n          up.request(...).then(() => {\n            up.feedback.stop(button)\n          })\n        })\n    \n    @method up.feedback.start\n    @param {Element|jQuery|string} element\n      The element to mark as active\n    @internal\n     */\n    start = function(element) {\n      return findActivatableArea(element).classList.add(CLASS_ACTIVE);\n    };\n\n    /***\n    Links that are currently [loading through Unpoly](/form-up-target)\n    are assigned the `up-active` class automatically.\n    Style `.up-active` in your CSS to improve the perceived responsiveness\n    of your user interface.\n    \n    The `up-active` class will be removed when the link is done loading.\n    \n    \\#\\#\\# Example\n    \n    We have a link:\n    \n        <a href=\"/foo\" up-follow>Foo</a>\n    \n    The user clicks on the link. While the request is loading,\n    the link has the `up-active` class:\n    \n        <a href=\"/foo\" up-follow class=\"up-active\">Foo</a>\n    \n    Once the link destination has loaded and rendered, the `up-active` class\n    is removed and the [`up-current`](/a.up-current) class is added:\n    \n        <a href=\"/foo\" up-follow class=\"up-current\">Foo</a>\n    \n    @selector a.up-active\n    @stable\n     */\n\n    /***\n    Forms that are currently [loading through Unpoly](/a-up-target)\n    are assigned the `up-active` class automatically.\n    Style `.up-active` in your CSS to improve the perceived responsiveness\n    of your user interface.\n    \n    The `up-active` class will be removed as soon as the response to the\n    form submission has been received.\n    \n    \\#\\#\\# Example\n    \n    We have a form:\n    \n        <form up-target=\".foo\">\n          <button type=\"submit\">Submit</button>\n        </form>\n    \n    The user clicks on the submit button. While the form is being submitted\n    and waiting for the server to respond, the form has the `up-active` class:\n    \n        <form up-target=\".foo\" class=\"up-active\">\n          <button type=\"submit\">Submit</button>\n        </form>\n    \n    Once the link destination has loaded and rendered, the `up-active` class\n    is removed.\n    \n    @selector form.up-active\n    @stable\n     */\n\n    /***\n    Marks the given element as no longer loading, by removing the CSS class [`up-active`](/a.up-active).\n    \n    This happens automatically when network requests initiated by the Unpoly API have completed.\n    Use this function if you make custom network calls from your own JavaScript code.\n    \n    @function up.feedback.stop\n    @param {Element|jQuery|string} element\n      The link or form that has finished loading.\n    @internal\n     */\n    stop = function(element) {\n      return findActivatableArea(element).classList.remove(CLASS_ACTIVE);\n    };\n\n    /***\n    Marks this element as a navigation component, such as a menu or navigation bar.\n    \n    When a link within an `[up-nav]` element points to the current location, it is assigned the `.up-current` class. When the browser navigates to another location, the class is removed automatically.\n    \n    You may also assign `[up-nav]` to an individual link instead of an navigational container.\n    \n    If you don't want to manually add this attribute to every navigational element, you can configure selectors to automatically match your navigation components in [`up.feedback.config.navs`](/up.feedback.config#config.navs).\n    \n    \n    \\#\\#\\# Example\n    \n    Let's take a simple menu with two links. The menu has been marked with the `[up-nav]` attribute:\n    \n        <div up-nav>\n          <a href=\"/foo\">Foo</a>\n          <a href=\"/bar\">Bar</a>\n        </div>\n    \n    If the browser location changes to `/foo`, the first link is marked as `.up-current`:\n    \n        <div up-nav>\n          <a href=\"/foo\" class=\"up-current\">Foo</a>\n          <a href=\"/bar\">Bar</a>\n        </div>\n    \n    If the browser location changes to `/bar`, the first link automatically loses its `.up-current` class. Now the second link is marked as `.up-current`:\n    \n        <div up-nav>\n          <a href=\"/foo\">Foo</a>\n          <a href=\"/bar\" class=\"up-current\">Bar</a>\n        </div>\n    \n    \n    \\#\\#\\# What is considered to be \"current\"?\n    \n    The current location is considered to be either:\n    \n    - the URL displayed in the browser window's location bar\n    - the source URL of a [modal dialog](/up.modal)\n    - the URL of the page behind a [modal dialog](/up.modal)\n    - the source URL of a [popup overlay](/up.popup)\n    - the URL of the content behind a [popup overlay](/up.popup)\n    \n    A link matches the current location (and is marked as `.up-current`) if it matches either:\n    \n    - the link's `href` attribute\n    - the link's `up-href` attribute\n    - a space-separated list of URLs in the link's `up-alias` attribute\n    \n    \\#\\#\\# Matching URL by pattern\n    \n    You can mark a link as `.up-current` whenever the current URL matches a prefix or suffix.\n    To do so, include an asterisk (`*`) in the `up-alias` attribute.\n    \n    For instance, the following `[up-nav]` link is highlighted for both `/reports` and `/reports/123`:\n    \n        <a up-nav href=\"/reports\" up-alias=\"/reports/*\">Reports</a>\n    \n    @selector [up-nav]\n    @stable\n     */\n\n    /***\n    When a link within an `[up-nav]` element points to the current location, it is assigned the `.up-current` class.\n    \n    See [`[up-nav]`](/up-nav) for more documentation and examples.\n    \n    @selector [up-nav] a.up-current\n    @stable\n     */\n    up.on('up:history:pushed up:history:replaced up:history:restored up:modal:opened up:modal:closed up:popup:opened up:popup:closed', function(event) {\n      return updateAllNavigationSectionsIfLocationChanged();\n    });\n    up.on('up:fragment:inserted', function(event, newFragment) {\n      return updateNavigationSectionsInNewFragment(newFragment);\n    });\n    up.on('up:framework:reset', reset);\n    return {\n      config: config,\n      start: start,\n      stop: stop\n    };\n  })();\n\n  up.legacy.renamedModule('navigation', 'feedback');\n\n}).call(this);\n\n/***\nPassive updates\n===============\n\nThis work-in-progress package will contain functionality to\npassively receive updates from the server.\n\n@module up.radio\n */\n\n(function() {\n  up.radio = (function() {\n    var config, hungrySelector, reset, u;\n    u = up.util;\n\n    /***\n    Configures defaults for passive updates.\n    \n    @property up.radio.config\n    @param {Array<string>} [options.hungry]\n      An array of CSS selectors that is replaced whenever a matching element is found in a response.\n      These elements are replaced even when they were not targeted directly.\n    \n      By default this contains the [`[up-hungry]`](/up-hungry) attribute.\n    @param {string} [options.hungryTransition=null]\n      The transition to use when a [hungry element](/up-hungry) is replacing itself\n      while another target is replaced.\n    \n      By default this is not set and the original replacement's transition is used.\n    @stable\n     */\n    config = new up.Config({\n      hungry: ['[up-hungry]'],\n      hungryTransition: null\n    });\n    reset = function() {\n      return config.reset();\n    };\n\n    /***\n    @function up.radio.hungrySelector\n    @internal\n     */\n    hungrySelector = function() {\n      return config.hungry.join(',');\n    };\n\n    /***\n    Elements with this attribute are [updated](/up.replace) whenever there is a\n    matching element found in a successful response. The element is replaced even\n    when it isn't [targeted](/a-up-target) directly.\n    \n    Use cases for this are unread message counters or notification flashes.\n    Such elements often live in the layout, outside of the content area that is\n    being replaced.\n    \n    @selector [up-hungry]\n    @stable\n     */\n    up.on('up:framework:reset', reset);\n    return {\n      config: config,\n      hungrySelector: hungrySelector\n    };\n  })();\n\n}).call(this);\n\n/***\nPlay nice with Rails UJS\n========================\n */\n\n(function() {\n  up.rails = (function() {\n    var e, isRails, u;\n    u = up.util;\n    e = up.element;\n    isRails = function() {\n      var ref;\n      return !!(window.Rails || ((ref = window.jQuery) != null ? ref.rails : void 0));\n    };\n    return u.each(['method', 'confirm'], function(feature) {\n      var dataAttribute, upAttribute;\n      dataAttribute = \"data-\" + feature;\n      upAttribute = \"up-\" + feature;\n      return up.macro(\"[\" + dataAttribute + \"]\", function(element) {\n        var replacement;\n        if (isRails() && up.link.isFollowable(element)) {\n          replacement = {};\n          replacement[upAttribute] = element.getAttribute(dataAttribute);\n          e.setMissingAttrs(element, replacement);\n          return element.removeAttribute(dataAttribute);\n        }\n      });\n    });\n  })();\n\n}).call(this);\n(function() {\n  up.framework.boot();\n\n}).call(this);\n\n\n//# sourceURL=webpack:///./node_modules/unpoly/dist/unpoly.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	// startup
/******/ 	// Load entry module
/******/ 	__webpack_require__("./_webpack/main.js");
/******/ 	// This entry module used 'exports' so it can't be inlined
/******/ })()
;